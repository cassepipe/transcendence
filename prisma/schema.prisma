// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["extendedWhereUnique"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum PermissionList {
  SEND_MESSAGE
  DELETE_MESSAGE
  EDIT_TITLE
  EDIT_PASSWORD
  EDIT_VISIBILITY
  INVITE
  KICK
  BAN
  MUTE
  DESTROY
}

enum RoleApplyingType {
  NONE
  ROLES
  ROLES_AND_SELF
}

model Role {
  id Int @id @default(autoincrement())

  name        String
  permissions PermissionList[]

  roleApplyOn RoleApplyingType
  roles       Role[]           @relation("roles")
  rolesSym    Role[]           @relation("roles")

  users User[]

  chan   Chan @relation(fields: [chanId], references: [id], onDelete: Cascade)
  chanId Int

  @@unique(fields: [chanId, name], name: "chanId_name")
}

model FriendInvitation {
  id Int @id @default(autoincrement())

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  invitingUser     User   @relation(name: "outcomingFriendInvitation", fields: [invitingUserName], references: [name])
  invitingUserName String
  invitedUser      User?  @relation("incomingFriendInvitation", fields: [invitedUserName], references: [name])
  invitedUserName  String

  @@unique([invitingUserName, invitedUserName])
}

model User {
  name String @id

  password String

  roles Role[] // maybe @Default here instead of default in chan creation function (not sure it's possible)

  directMessage DirectMessage[] @relation(name: "directMessage")
  chans         Chan[]
  ownedChans    Chan[]          @relation("owner")

  friendList   User[] @relation("friendList")
  friendOfList User[] @relation("friendList")

  outcomingFriendInvitation FriendInvitation[] @relation("outcomingFriendInvitation")
  incomingFriendInvitation  FriendInvitation[] @relation("incomingFriendInvitation")

  blockedUserList   User[] @relation("blockedUser")
  blockedByUserList User[] @relation("blockedUser")

  discussionElement DiscussionElement[]
  discussionEvent   DiscussionEvent[]
}

enum ChanType {
  PUBLIC
  PRIVATE
}

model Chan {
  id Int @id @default(autoincrement())

  type     ChanType
  title    String?  @unique
  password String?

  users        User[]
  roles        Role[]
  owner        User       @relation("owner", fields: [ownerName], references: [name])
  ownerName    String
  discussion   Discussion @relation(name: "discussion", fields: [discussionId], references: [id], onDelete: Cascade)
  discussionId Int        @unique
}

model DirectMessage {
  id Int @id @default(autoincrement())

  users        User[]     @relation(name: "directMessage")
  discussion   Discussion @relation(fields: [discussionId], references: [id])
  discussionId Int        @unique
}

model Discussion {
  id Int @id @default(autoincrement())

  directMessage DirectMessage?
  chan          Chan?          @relation(name: "discussion")

  elements DiscussionElement[]
}

model DiscussionElement {
  id Int @id @default(autoincrement())

  message DiscussionMessage?
  event   DiscussionEvent?

  authorRelation User   @relation(fields: [author], references: [name])
  author         String @unique

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  discussion   Discussion @relation(fields: [discussionId], references: [id], onDelete: Cascade)
  discussionId Int
}

model DiscussionEvent {
  id Int @id @default(autoincrement())

  eventType String

  concernedUserRelation User?   @relation(fields: [concernedUser], references: [name])
  concernedUser         String? @unique

  discussionElement   DiscussionElement @relation(fields: [discussionElementId], references: [id], onDelete: Cascade)
  discussionElementId Int               @unique
}

model DiscussionMessage {
  id Int @id @default(autoincrement())

  content String

  discussionElement   DiscussionElement @relation(fields: [discussionElementId], references: [id], onDelete: Cascade)
  discussionElementId Int               @unique
}
