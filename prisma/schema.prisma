// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["extendedWhereUnique"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum PermissionList {
  SEND_MESSAGE
  DELETE_MESSAGE
  EDIT
  INVITE
  KICK
  BAN
  MUTE
  DESTROY
}

enum RoleApplyingType {
  NONE
  ROLES
  ROLES_AND_SELF
}

model Role {
  id String @id @default(uuid())

  name        String
  permissions PermissionList[]

  roleApplyOn RoleApplyingType
  roles       Role[]           @relation("roles")
  rolesSym    Role[]           @relation("roles")

  users User[]

  chan   Chan @relation(fields: [chanId], references: [id], onDelete: Cascade)
  chanId String

  relatedDiscussionMessage ChanDiscussionMessage[]

  @@unique(fields: [chanId, name], name: "chanId_name")
}

enum FriendInvitationStatus {
	PENDING
	ACCEPTED
	REFUSED
	CANCELED
	DELETED_USER
}

model FriendInvitation {
  id String @id @default(uuid())

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  invitingUser     User   @relation(name: "outcomingFriendInvitation", fields: [invitingUserName], references: [name])
  invitingUserName String
  invitedUser      User   @relation("incomingFriendInvitation", fields: [invitedUserName], references: [name])
  invitedUserName  String

  status FriendInvitationStatus @default(PENDING)
}

enum ChanInvitationStatus {
	PENDING
	ACCEPTED
	REFUSED
	CANCELED
	DELETED_CHAN
}

model ChanInvitation {
  id String @id @default(uuid())

  chan              Chan            @relation(fields: [chanId, chanTitle], references: [id, title], onDelete: Cascade)
  chanId           String 
  chanTitle			String
  friendShip        FriendShip      @relation(fields: [friendShipId], references: [id])
  friendShipId      String
  discussionEvent   DmDiscussionEvent @relation(fields: [discussionEventId], references: [id])
  discussionEventId String @unique
  requestingUser	User @relation(name: "outcomingChanInvitation", fields: [requestingUserName], references: [name])
  requestingUserName	String
  requestedUser	User @relation(name: "incomingChanInvitation", fields: [requestedUserName], references: [name])
  requestedUserName	String

  status ChanInvitationStatus @default(PENDING)
}

// TODO: let one of the users disconnect without deleting FriendShip to display removed friend notification to the other
// user at connexion and not only by sse
model FriendShip {
  id String @id @default(uuid())

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  requestingUser     User   @relation(name: "friend", fields: [requestingUserName], references: [name])
  requestingUserName String
  requestedUser      User   @relation("friendOf", fields: [requestedUserName], references: [name])
  requestedUserName  String

  directMessage DirectMessage?

  chanInvitations ChanInvitation[]

  @@unique([requestingUserName, requestedUserName])
}

model BlockedShip {
  id String @id @default(uuid())

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  blockingUser     User   @relation(name: "blocked", fields: [blockingUserName], references: [name])
  blockingUserName String
  blockedUser      User   @relation("blockedBy", fields: [blockedUserName], references: [name])
  blockedUserName  String

  @@unique([blockingUserName, blockedUserName])
}

model User {
  name String @id

  password String

  roles Role[]

  directMessage   DirectMessage[] @relation(name: "directMessage")
  directMessageOf DirectMessage[] @relation(name: "directMessageOf")
  chans           Chan[]
  ownedChans      Chan[]          @relation("owner")

  friend   FriendShip[] @relation("friend")
  friendOf FriendShip[] @relation("friendOf")

  outcomingFriendInvitation FriendInvitation[] @relation("outcomingFriendInvitation")
  incomingFriendInvitation  FriendInvitation[] @relation("incomingFriendInvitation")

  outcomingChanInvitation	ChanInvitation[] @relation("outcomingChanInvitation")
  incomingChanInvitation	ChanInvitation[] @relation("incomingChanInvitation")

  blockedUser   BlockedShip[] @relation("blocked")
  blockedByUser BlockedShip[] @relation("blockedBy")

  chanDiscussionElement ChanDiscussionElement[]
  chanDiscussionEvent   ChanDiscussionEvent[]
  chanDiscussionMessage ChanDiscussionMessage[]

  dmDiscussionElement DmDiscussionElement[]
  dmDiscussionMessage DmDiscussionMessage[]

  mutedUserChan MutedUserChan[]
}


// DM

model DirectMessage {
  id String @id @default(uuid())

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  requestingUser                 User                @relation(name: "directMessage", fields: [requestingUserName], references: [name])
  requestingUserName             String
  requestingUserStatus           DirectMessageStatus @default(OPEN)
  requestingUserStatusMutedUntil DateTime?
  requestedUser                  User                @relation("directMessageOf", fields: [requestedUserName], references: [name])
  requestedUserName              String
  requestedUserStatus            DirectMessageStatus @default(OPEN)
  requestedUserStatusMutedUntil  DateTime?

  friendShip   FriendShip? @relation(fields: [friendShipId], references: [id])
  friendShipId String?        @unique

  @@unique([requestingUserName, requestedUserName])

  elements DmDiscussionElement[]
}

enum DirectMessageStatus {
  CLOSED
  OPEN
  MUTED
}

model DmDiscussionElement {
  id String @id @default(uuid())

  message   DmDiscussionMessage?  @relation(name: "ownship")
  relatedOf DmDiscussionMessage[] @relation(name: "related")
  event     DmDiscussionEvent?

  authorRelation User   @relation(fields: [author], references: [name], onDelete: Cascade)
  author         String

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  directMessage   DirectMessage @relation(fields: [directMessageId], references: [id], onDelete: Cascade)
  directMessageId String
}

model DmDiscussionMessage {
  id String @id @default(uuid())

  content String

  relatedUsers        User[]
  related             DmDiscussionElement? @relation(name: "related", fields: [relatedTo], references: [id])
  relatedTo           String?
  discussionElement   DmDiscussionElement  @relation(name: "ownship", fields: [discussionElementId], references: [id], onDelete: Cascade)
  discussionElementId String                @unique
}

model DmDiscussionEvent {
  id String @id @default(uuid())

  eventType DmEventType

  discussionElement   DmDiscussionElement @relation(fields: [discussionElementId], references: [id], onDelete: Cascade)
  discussionElementId String               @unique
  chanInvitation      ChanInvitation?
}

enum DmEventType {
  CREATED_FRIENDSHIP
  DELETED_FRIENDSHIP
  DELETED_MESSAGE
  CHAN_INVITATION
}


// CHAN

model Chan {
  id String @id @default(uuid())

  type     ChanType
  title    String?  @unique
  password String?

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  users     User[]
  roles     Role[]
  owner     User   @relation("owner", fields: [ownerName], references: [name])
  ownerName String

  mutedUsers MutedUserChan[]

  invitations ChanInvitation[]

  elements ChanDiscussionElement[]

	@@unique([id, title])
}

model MutedUserChan {
  id String @id @default(uuid())

  creationDate DateTime  @default(now())
  untilDate    DateTime?

  mutedUser     User   @relation(fields: [mutedUserName], references: [name])
  mutedUserName String

  chan   Chan @relation(fields: [chanId], references: [id])
  chanId String

  @@unique([chanId, mutedUserName])
}

enum ChanType {
  PUBLIC
  PRIVATE
}


model ChanDiscussionElement {
  id String @id @default(uuid())

  message   ChanDiscussionMessage?  @relation(name: "ownship")
  event     ChanDiscussionEvent?

  relatedOf ChanDiscussionMessage[] @relation(name: "related") // other side

  authorRelation User   @relation(fields: [author], references: [name], onDelete: Cascade)
  author         String

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  chan            Chan		@relation(fields: [chanId], references: [id], onDelete: Cascade)
  chanId          String

  @@index(fields: [creationDate(sort: Asc)])
}

model ChanDiscussionMessage {
  id String @id @default(uuid())

  content String

  relatedUsers        User[]
  relatedRoles        Role[]
  related             ChanDiscussionElement? @relation(name: "related", fields: [relatedTo], references: [id])
  relatedTo           String?
  discussionElement   ChanDiscussionElement  @relation(name: "ownship", fields: [discussionElementId], references: [id], onDelete: Cascade)
  discussionElementId String                @unique
}

model ChanDiscussionEvent {
  id String @id @default(uuid())

  eventType ChanEventType

  concernedUserRelation User?   @relation(fields: [concernedUser], references: [name])
  concernedUser         String?

  discussionElement   ChanDiscussionElement @relation(fields: [discussionElementId], references: [id], onDelete: Cascade)
  discussionElementId String               @unique
}

enum ChanEventType {
  AUTHOR_LEAVED
  AUTHOR_KICKED_CONCERNED
  AUTHOR_JOINED
  AUTHOR_MUTED_CONCERNED
  DELETED_MESSAGE
}
