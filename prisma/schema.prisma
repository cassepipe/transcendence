// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["extendedWhereUnique"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum PermissionList {
  SEND_MESSAGE
  DELETE_MESSAGE
  EDIT_TITLE
  EDIT_PASSWORD
  EDIT_VISIBILITY
  INVITE
  KICK
  BAN
  MUTE
  DESTROY
}

enum RoleApplyingType {
  NONE
  ROLES
  ROLES_AND_SELF
}

model Role {
  id Int @id @default(autoincrement())

  name        String
  permissions PermissionList[]

  roleApplyOn RoleApplyingType
  roles       Role[]           @relation("roles")
  rolesSym    Role[]           @relation("roles")

  users User[]

  chan   Chan @relation(fields: [chanId], references: [id], onDelete: Cascade)
  chanId Int

  @@unique(fields: [chanId, name], name: "chanId_name")
}

// TODO: let invited User disconnect without deleting FriendInvitation to display refused invitation notification
// to invitingUser at connexion and not only by sse
model FriendInvitation {
  id Int @id @default(autoincrement())

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  invitingUser     User   @relation(name: "outcomingFriendInvitation", fields: [invitingUserName], references: [name])
  invitingUserName String
  invitedUser      User   @relation("incomingFriendInvitation", fields: [invitedUserName], references: [name])
  invitedUserName  String

  @@unique([invitingUserName, invitedUserName])
}

// TODO: let one of the users disconnect without deleting FriendShip to display removed friend notification to the other
// user at connexion and not only by sse
model FriendShip {
  id Int @id @default(autoincrement())

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  requestingUser     User   @relation(name: "friend", fields: [requestingUserName], references: [name])
  requestingUserName String
  requestedUser      User   @relation("friendOf", fields: [requestedUserName], references: [name])
  requestedUserName  String

  directMessage DirectMessage?

  @@unique([requestingUserName, requestedUserName])
}

model BlockedShip {
  id Int @id @default(autoincrement())

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  blockingUser     User   @relation(name: "blocked", fields: [blockingUserName], references: [name])
  blockingUserName String
  blockedUser      User   @relation("blockedBy", fields: [blockedUserName], references: [name])
  blockedUserName  String

  @@unique([blockingUserName, blockedUserName])
}

model User {
  name String @id

  password String

  roles Role[]

  directMessage   DirectMessage[] @relation(name: "directMessage")
  directMessageOf DirectMessage[] @relation(name: "directMessageOf")
  chans           Chan[]
  ownedChans      Chan[]          @relation("owner")

  friend   FriendShip[] @relation("friend")
  friendOf FriendShip[] @relation("friendOf")

  outcomingFriendInvitation FriendInvitation[] @relation("outcomingFriendInvitation")
  incomingFriendInvitation  FriendInvitation[] @relation("incomingFriendInvitation")

  blockedUser   BlockedShip[] @relation("blocked")
  blockedByUser BlockedShip[] @relation("blockedBy")

  discussionElement DiscussionElement[]
  discussionEvent   DiscussionEvent[]
}

enum ChanType {
  PUBLIC
  PRIVATE
}

model Chan {
  id Int @id @default(autoincrement())

  type     ChanType
  title    String?  @unique
  password String?

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  users     User[]
  roles     Role[]
  owner     User   @relation("owner", fields: [ownerName], references: [name])
  ownerName String

  elements DiscussionElement[]
}

model DirectMessage {
  id Int @id @default(autoincrement())

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  requestingUser     User?   @relation(name: "directMessage", fields: [requestingUserName], references: [name])
  requestingUserName String?
  requestedUser      User?   @relation("directMessageOf", fields: [requestedUserName], references: [name])
  requestedUserName  String?

  friendShip   FriendShip @relation(fields: [friendShipId], references: [id], onDelete: Cascade)
  friendShipId Int        @unique

  elements DiscussionElement[]
}

model DiscussionElement {
  id Int @id @default(autoincrement())

  message   DiscussionMessage?  @relation(name: "ownship")
  relatedOf DiscussionMessage[] @relation(name: "related")
  event     DiscussionEvent?

  authorRelation User   @relation(fields: [author], references: [name], onDelete: Cascade)
  author         String

  creationDate     DateTime  @default(now())
  modificationDate DateTime? @updatedAt

  directMessage   DirectMessage? @relation(fields: [directMessageId], references: [id], onDelete: Cascade)
  directMessageId Int?
  chan            Chan?          @relation(fields: [chanId], references: [id], onDelete: Cascade)
  chanId          Int?
}

enum EventType {
  AUTHOR_LEAVED
  AUTHOR_KICKED_CONCERNED
  AUTHOR_JOINED
}

model DiscussionEvent {
  id Int @id @default(autoincrement())

  eventType String

  concernedUserRelation User?   @relation(fields: [concernedUser], references: [name])
  concernedUser         String? @unique

  discussionElement   DiscussionElement @relation(fields: [discussionElementId], references: [id], onDelete: Cascade)
  discussionElementId Int               @unique
}

model DiscussionMessage {
  id Int @id @default(autoincrement())

  content String

  related             DiscussionElement? @relation(name: "related", fields: [relatedId], references: [id])
  relatedId           Int?
  discussionElement   DiscussionElement  @relation(name: "ownship", fields: [discussionElementId], references: [id], onDelete: Cascade)
  discussionElementId Int                @unique
}
