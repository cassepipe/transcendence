
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Role
 * 
 */
export type Role = {
  id: string
  name: string
  permissions: PermissionList[]
  roleApplyOn: RoleApplyingType
  chanId: string
}

/**
 * Model FriendInvitation
 * 
 */
export type FriendInvitation = {
  id: string
  creationDate: Date
  modificationDate: Date | null
  invitingUserName: string
  invitedUserName: string
  status: FriendInvitationStatus
}

/**
 * Model ChanInvitation
 * 
 */
export type ChanInvitation = {
  id: string
  creationDate: Date
  modificationDate: Date | null
  chanId: string
  chanTitle: string
  invitingUserName: string
  invitedUserName: string
  status: ChanInvitationStatus
}

/**
 * Model FriendShip
 * 
 */
export type FriendShip = {
  id: string
  creationDate: Date
  modificationDate: Date | null
  requestingUserName: string
  requestedUserName: string
}

/**
 * Model BlockedShip
 * 
 */
export type BlockedShip = {
  id: string
  creationDate: Date
  modificationDate: Date | null
  blockingUserName: string
  blockedUserName: string
}

/**
 * Model User
 * 
 */
export type User = {
  name: string
  password: string
  dmPolicyLevel: dmPolicyLevelType
}

/**
 * Model DirectMessage
 * 
 */
export type DirectMessage = {
  id: string
  creationDate: Date
  modificationDate: Date | null
  requestingUserName: string
  requestingUserStatus: DirectMessageUserStatus
  requestingUserStatusMutedUntil: Date | null
  requestedUserName: string
  requestedUserStatus: DirectMessageUserStatus
  requestedUserStatusMutedUntil: Date | null
  status: DirectMessageStatus
}

/**
 * Model DmDiscussionElement
 * 
 */
export type DmDiscussionElement = {
  id: string
  messageId: string | null
  eventId: string | null
  author: string
  creationDate: Date
  modificationDate: Date | null
  directMessageId: string
}

/**
 * Model DmDiscussionMessage
 * 
 */
export type DmDiscussionMessage = {
  id: string
  content: string
  relatedTo: string | null
}

/**
 * Model DmDiscussionEvent
 * 
 */
export type DmDiscussionEvent = {
  id: string
  classicDmDiscussionEventId: string | null
  chanInvitationDmDiscussionEventId: string | null
}

/**
 * Model ChanInvitationDmDiscussionEvent
 * 
 */
export type ChanInvitationDmDiscussionEvent = {
  id: string
  chanInvitationId: string
}

/**
 * Model ClassicDmDiscussionEvent
 * 
 */
export type ClassicDmDiscussionEvent = {
  id: string
  eventType: ClassicDmEventType
}

/**
 * Model Chan
 * 
 */
export type Chan = {
  id: string
  type: ChanType
  title: string | null
  password: string | null
  creationDate: Date
  modificationDate: Date | null
  ownerName: string
}

/**
 * Model MutedUserChan
 * 
 */
export type MutedUserChan = {
  id: string
  creationDate: Date
  untilDate: Date | null
  mutedUserName: string
  chanId: string
}

/**
 * Model ChanDiscussionElement
 * 
 */
export type ChanDiscussionElement = {
  id: string
  messageId: string | null
  eventId: string | null
  authorName: string
  creationDate: Date
  modificationDate: Date | null
  chanId: string
}

/**
 * Model ChanDiscussionMessage
 * 
 */
export type ChanDiscussionMessage = {
  id: string
  content: string
  relatedTo: string | null
}

/**
 * Model ChanDiscussionEvent
 * 
 */
export type ChanDiscussionEvent = {
  id: string
  concernedUserName: string | null
  classicChanDiscussionEventId: string | null
  changedTitleChanDiscussionEventId: string | null
  deletedMessageChanDiscussionEventId: string | null
}

/**
 * Model ChangedTitleChanDiscussionEvent
 * 
 */
export type ChangedTitleChanDiscussionEvent = {
  id: string
  oldTitle: string
  newTitle: string
}

/**
 * Model DeletedMessageChanDiscussionEvent
 * 
 */
export type DeletedMessageChanDiscussionEvent = {
  id: string
  deletingUserName: string
}

/**
 * Model ClassicChanDiscussionEvent
 * 
 */
export type ClassicChanDiscussionEvent = {
  id: string
  eventType: ClassicChanEventType
}


/**
 * Enums
 */

export const ChanInvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REFUSED: 'REFUSED',
  CANCELED: 'CANCELED',
  DELETED_CHAN: 'DELETED_CHAN',
  BLOCKED_USER: 'BLOCKED_USER',
  BANNED_FROM_CHAN: 'BANNED_FROM_CHAN'
};

export type ChanInvitationStatus = (typeof ChanInvitationStatus)[keyof typeof ChanInvitationStatus]


export const ChanType: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE'
};

export type ChanType = (typeof ChanType)[keyof typeof ChanType]


export const ClassicChanEventType: {
  AUTHOR_LEAVED: 'AUTHOR_LEAVED',
  AUTHOR_KICKED_CONCERNED: 'AUTHOR_KICKED_CONCERNED',
  AUTHOR_JOINED: 'AUTHOR_JOINED',
  AUTHOR_MUTED_CONCERNED: 'AUTHOR_MUTED_CONCERNED'
};

export type ClassicChanEventType = (typeof ClassicChanEventType)[keyof typeof ClassicChanEventType]


export const ClassicDmEventType: {
  CREATED_FRIENDSHIP: 'CREATED_FRIENDSHIP',
  DELETED_FRIENDSHIP: 'DELETED_FRIENDSHIP',
  DELETED_MESSAGE: 'DELETED_MESSAGE',
  DISABLED_DM: 'DISABLED_DM',
  ENABLED_DM: 'ENABLED_DM'
};

export type ClassicDmEventType = (typeof ClassicDmEventType)[keyof typeof ClassicDmEventType]


export const DirectMessageStatus: {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED'
};

export type DirectMessageStatus = (typeof DirectMessageStatus)[keyof typeof DirectMessageStatus]


export const DirectMessageUserStatus: {
  CLOSED: 'CLOSED',
  OPEN: 'OPEN',
  MUTED: 'MUTED'
};

export type DirectMessageUserStatus = (typeof DirectMessageUserStatus)[keyof typeof DirectMessageUserStatus]


export const FriendInvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REFUSED: 'REFUSED',
  CANCELED: 'CANCELED',
  BLOCKED_USER: 'BLOCKED_USER'
};

export type FriendInvitationStatus = (typeof FriendInvitationStatus)[keyof typeof FriendInvitationStatus]


export const PermissionList: {
  SEND_MESSAGE: 'SEND_MESSAGE',
  DELETE_MESSAGE: 'DELETE_MESSAGE',
  EDIT: 'EDIT',
  INVITE: 'INVITE',
  KICK: 'KICK',
  BAN: 'BAN',
  MUTE: 'MUTE',
  DESTROY: 'DESTROY'
};

export type PermissionList = (typeof PermissionList)[keyof typeof PermissionList]


export const RoleApplyingType: {
  NONE: 'NONE',
  ROLES: 'ROLES',
  ROLES_AND_SELF: 'ROLES_AND_SELF'
};

export type RoleApplyingType = (typeof RoleApplyingType)[keyof typeof RoleApplyingType]


export const dmPolicyLevelType: {
  ONLY_FRIEND: 'ONLY_FRIEND',
  IN_COMMON_CHAN: 'IN_COMMON_CHAN',
  ANYONE: 'ANYONE'
};

export type dmPolicyLevelType = (typeof dmPolicyLevelType)[keyof typeof dmPolicyLevelType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.friendInvitation`: Exposes CRUD operations for the **FriendInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FriendInvitations
    * const friendInvitations = await prisma.friendInvitation.findMany()
    * ```
    */
  get friendInvitation(): Prisma.FriendInvitationDelegate<GlobalReject>;

  /**
   * `prisma.chanInvitation`: Exposes CRUD operations for the **ChanInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChanInvitations
    * const chanInvitations = await prisma.chanInvitation.findMany()
    * ```
    */
  get chanInvitation(): Prisma.ChanInvitationDelegate<GlobalReject>;

  /**
   * `prisma.friendShip`: Exposes CRUD operations for the **FriendShip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FriendShips
    * const friendShips = await prisma.friendShip.findMany()
    * ```
    */
  get friendShip(): Prisma.FriendShipDelegate<GlobalReject>;

  /**
   * `prisma.blockedShip`: Exposes CRUD operations for the **BlockedShip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedShips
    * const blockedShips = await prisma.blockedShip.findMany()
    * ```
    */
  get blockedShip(): Prisma.BlockedShipDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.directMessage`: Exposes CRUD operations for the **DirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectMessages
    * const directMessages = await prisma.directMessage.findMany()
    * ```
    */
  get directMessage(): Prisma.DirectMessageDelegate<GlobalReject>;

  /**
   * `prisma.dmDiscussionElement`: Exposes CRUD operations for the **DmDiscussionElement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DmDiscussionElements
    * const dmDiscussionElements = await prisma.dmDiscussionElement.findMany()
    * ```
    */
  get dmDiscussionElement(): Prisma.DmDiscussionElementDelegate<GlobalReject>;

  /**
   * `prisma.dmDiscussionMessage`: Exposes CRUD operations for the **DmDiscussionMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DmDiscussionMessages
    * const dmDiscussionMessages = await prisma.dmDiscussionMessage.findMany()
    * ```
    */
  get dmDiscussionMessage(): Prisma.DmDiscussionMessageDelegate<GlobalReject>;

  /**
   * `prisma.dmDiscussionEvent`: Exposes CRUD operations for the **DmDiscussionEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DmDiscussionEvents
    * const dmDiscussionEvents = await prisma.dmDiscussionEvent.findMany()
    * ```
    */
  get dmDiscussionEvent(): Prisma.DmDiscussionEventDelegate<GlobalReject>;

  /**
   * `prisma.chanInvitationDmDiscussionEvent`: Exposes CRUD operations for the **ChanInvitationDmDiscussionEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChanInvitationDmDiscussionEvents
    * const chanInvitationDmDiscussionEvents = await prisma.chanInvitationDmDiscussionEvent.findMany()
    * ```
    */
  get chanInvitationDmDiscussionEvent(): Prisma.ChanInvitationDmDiscussionEventDelegate<GlobalReject>;

  /**
   * `prisma.classicDmDiscussionEvent`: Exposes CRUD operations for the **ClassicDmDiscussionEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassicDmDiscussionEvents
    * const classicDmDiscussionEvents = await prisma.classicDmDiscussionEvent.findMany()
    * ```
    */
  get classicDmDiscussionEvent(): Prisma.ClassicDmDiscussionEventDelegate<GlobalReject>;

  /**
   * `prisma.chan`: Exposes CRUD operations for the **Chan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chans
    * const chans = await prisma.chan.findMany()
    * ```
    */
  get chan(): Prisma.ChanDelegate<GlobalReject>;

  /**
   * `prisma.mutedUserChan`: Exposes CRUD operations for the **MutedUserChan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MutedUserChans
    * const mutedUserChans = await prisma.mutedUserChan.findMany()
    * ```
    */
  get mutedUserChan(): Prisma.MutedUserChanDelegate<GlobalReject>;

  /**
   * `prisma.chanDiscussionElement`: Exposes CRUD operations for the **ChanDiscussionElement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChanDiscussionElements
    * const chanDiscussionElements = await prisma.chanDiscussionElement.findMany()
    * ```
    */
  get chanDiscussionElement(): Prisma.ChanDiscussionElementDelegate<GlobalReject>;

  /**
   * `prisma.chanDiscussionMessage`: Exposes CRUD operations for the **ChanDiscussionMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChanDiscussionMessages
    * const chanDiscussionMessages = await prisma.chanDiscussionMessage.findMany()
    * ```
    */
  get chanDiscussionMessage(): Prisma.ChanDiscussionMessageDelegate<GlobalReject>;

  /**
   * `prisma.chanDiscussionEvent`: Exposes CRUD operations for the **ChanDiscussionEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChanDiscussionEvents
    * const chanDiscussionEvents = await prisma.chanDiscussionEvent.findMany()
    * ```
    */
  get chanDiscussionEvent(): Prisma.ChanDiscussionEventDelegate<GlobalReject>;

  /**
   * `prisma.changedTitleChanDiscussionEvent`: Exposes CRUD operations for the **ChangedTitleChanDiscussionEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangedTitleChanDiscussionEvents
    * const changedTitleChanDiscussionEvents = await prisma.changedTitleChanDiscussionEvent.findMany()
    * ```
    */
  get changedTitleChanDiscussionEvent(): Prisma.ChangedTitleChanDiscussionEventDelegate<GlobalReject>;

  /**
   * `prisma.deletedMessageChanDiscussionEvent`: Exposes CRUD operations for the **DeletedMessageChanDiscussionEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeletedMessageChanDiscussionEvents
    * const deletedMessageChanDiscussionEvents = await prisma.deletedMessageChanDiscussionEvent.findMany()
    * ```
    */
  get deletedMessageChanDiscussionEvent(): Prisma.DeletedMessageChanDiscussionEventDelegate<GlobalReject>;

  /**
   * `prisma.classicChanDiscussionEvent`: Exposes CRUD operations for the **ClassicChanDiscussionEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassicChanDiscussionEvents
    * const classicChanDiscussionEvents = await prisma.classicChanDiscussionEvent.findMany()
    * ```
    */
  get classicChanDiscussionEvent(): Prisma.ClassicChanDiscussionEventDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.15.0
   * Query Engine version: 8fbc245156db7124f997f4cecdd8d1219e360944
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    FriendInvitation: 'FriendInvitation',
    ChanInvitation: 'ChanInvitation',
    FriendShip: 'FriendShip',
    BlockedShip: 'BlockedShip',
    User: 'User',
    DirectMessage: 'DirectMessage',
    DmDiscussionElement: 'DmDiscussionElement',
    DmDiscussionMessage: 'DmDiscussionMessage',
    DmDiscussionEvent: 'DmDiscussionEvent',
    ChanInvitationDmDiscussionEvent: 'ChanInvitationDmDiscussionEvent',
    ClassicDmDiscussionEvent: 'ClassicDmDiscussionEvent',
    Chan: 'Chan',
    MutedUserChan: 'MutedUserChan',
    ChanDiscussionElement: 'ChanDiscussionElement',
    ChanDiscussionMessage: 'ChanDiscussionMessage',
    ChanDiscussionEvent: 'ChanDiscussionEvent',
    ChangedTitleChanDiscussionEvent: 'ChangedTitleChanDiscussionEvent',
    DeletedMessageChanDiscussionEvent: 'DeletedMessageChanDiscussionEvent',
    ClassicChanDiscussionEvent: 'ClassicChanDiscussionEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    roles: number
    rolesSym: number
    users: number
    relatedDiscussionMessage: number
  }

  export type RoleCountOutputTypeSelect = {
    roles?: boolean
    rolesSym?: boolean
    users?: boolean
    relatedDiscussionMessage?: boolean
  }

  export type RoleCountOutputTypeGetPayload<S extends boolean | null | undefined | RoleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RoleCountOutputTypeArgs)
    ? RoleCountOutputType 
    : S extends { select: any } & (RoleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoleCountOutputType ? RoleCountOutputType[P] : never
  } 
      : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    roles: number
    directMessage: number
    directMessageOf: number
    chans: number
    ownedChans: number
    friend: number
    friendOf: number
    outcomingFriendInvitation: number
    incomingFriendInvitation: number
    outcomingChanInvitation: number
    incomingChanInvitation: number
    blockedUser: number
    blockedByUser: number
    chanDiscussionElement: number
    chanDiscussionEvent: number
    deletedMessageChanDiscussionEvent: number
    chanDiscussionMessage: number
    dmDiscussionElement: number
    dmDiscussionMessage: number
    mutedUserChan: number
  }

  export type UserCountOutputTypeSelect = {
    roles?: boolean
    directMessage?: boolean
    directMessageOf?: boolean
    chans?: boolean
    ownedChans?: boolean
    friend?: boolean
    friendOf?: boolean
    outcomingFriendInvitation?: boolean
    incomingFriendInvitation?: boolean
    outcomingChanInvitation?: boolean
    incomingChanInvitation?: boolean
    blockedUser?: boolean
    blockedByUser?: boolean
    chanDiscussionElement?: boolean
    chanDiscussionEvent?: boolean
    deletedMessageChanDiscussionEvent?: boolean
    chanDiscussionMessage?: boolean
    dmDiscussionElement?: boolean
    dmDiscussionMessage?: boolean
    mutedUserChan?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type DirectMessageCountOutputType
   */


  export type DirectMessageCountOutputType = {
    elements: number
  }

  export type DirectMessageCountOutputTypeSelect = {
    elements?: boolean
  }

  export type DirectMessageCountOutputTypeGetPayload<S extends boolean | null | undefined | DirectMessageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DirectMessageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DirectMessageCountOutputTypeArgs)
    ? DirectMessageCountOutputType 
    : S extends { select: any } & (DirectMessageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DirectMessageCountOutputType ? DirectMessageCountOutputType[P] : never
  } 
      : DirectMessageCountOutputType




  // Custom InputTypes

  /**
   * DirectMessageCountOutputType without action
   */
  export type DirectMessageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DirectMessageCountOutputType
     */
    select?: DirectMessageCountOutputTypeSelect | null
  }



  /**
   * Count Type DmDiscussionElementCountOutputType
   */


  export type DmDiscussionElementCountOutputType = {
    relatedOf: number
  }

  export type DmDiscussionElementCountOutputTypeSelect = {
    relatedOf?: boolean
  }

  export type DmDiscussionElementCountOutputTypeGetPayload<S extends boolean | null | undefined | DmDiscussionElementCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DmDiscussionElementCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DmDiscussionElementCountOutputTypeArgs)
    ? DmDiscussionElementCountOutputType 
    : S extends { select: any } & (DmDiscussionElementCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DmDiscussionElementCountOutputType ? DmDiscussionElementCountOutputType[P] : never
  } 
      : DmDiscussionElementCountOutputType




  // Custom InputTypes

  /**
   * DmDiscussionElementCountOutputType without action
   */
  export type DmDiscussionElementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElementCountOutputType
     */
    select?: DmDiscussionElementCountOutputTypeSelect | null
  }



  /**
   * Count Type DmDiscussionMessageCountOutputType
   */


  export type DmDiscussionMessageCountOutputType = {
    relatedUsers: number
  }

  export type DmDiscussionMessageCountOutputTypeSelect = {
    relatedUsers?: boolean
  }

  export type DmDiscussionMessageCountOutputTypeGetPayload<S extends boolean | null | undefined | DmDiscussionMessageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DmDiscussionMessageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DmDiscussionMessageCountOutputTypeArgs)
    ? DmDiscussionMessageCountOutputType 
    : S extends { select: any } & (DmDiscussionMessageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DmDiscussionMessageCountOutputType ? DmDiscussionMessageCountOutputType[P] : never
  } 
      : DmDiscussionMessageCountOutputType




  // Custom InputTypes

  /**
   * DmDiscussionMessageCountOutputType without action
   */
  export type DmDiscussionMessageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessageCountOutputType
     */
    select?: DmDiscussionMessageCountOutputTypeSelect | null
  }



  /**
   * Count Type ChanCountOutputType
   */


  export type ChanCountOutputType = {
    users: number
    roles: number
    mutedUsers: number
    invitations: number
    elements: number
  }

  export type ChanCountOutputTypeSelect = {
    users?: boolean
    roles?: boolean
    mutedUsers?: boolean
    invitations?: boolean
    elements?: boolean
  }

  export type ChanCountOutputTypeGetPayload<S extends boolean | null | undefined | ChanCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChanCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChanCountOutputTypeArgs)
    ? ChanCountOutputType 
    : S extends { select: any } & (ChanCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChanCountOutputType ? ChanCountOutputType[P] : never
  } 
      : ChanCountOutputType




  // Custom InputTypes

  /**
   * ChanCountOutputType without action
   */
  export type ChanCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChanCountOutputType
     */
    select?: ChanCountOutputTypeSelect | null
  }



  /**
   * Count Type ChanDiscussionElementCountOutputType
   */


  export type ChanDiscussionElementCountOutputType = {
    relatedOf: number
  }

  export type ChanDiscussionElementCountOutputTypeSelect = {
    relatedOf?: boolean
  }

  export type ChanDiscussionElementCountOutputTypeGetPayload<S extends boolean | null | undefined | ChanDiscussionElementCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChanDiscussionElementCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChanDiscussionElementCountOutputTypeArgs)
    ? ChanDiscussionElementCountOutputType 
    : S extends { select: any } & (ChanDiscussionElementCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChanDiscussionElementCountOutputType ? ChanDiscussionElementCountOutputType[P] : never
  } 
      : ChanDiscussionElementCountOutputType




  // Custom InputTypes

  /**
   * ChanDiscussionElementCountOutputType without action
   */
  export type ChanDiscussionElementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElementCountOutputType
     */
    select?: ChanDiscussionElementCountOutputTypeSelect | null
  }



  /**
   * Count Type ChanDiscussionMessageCountOutputType
   */


  export type ChanDiscussionMessageCountOutputType = {
    relatedUsers: number
    relatedRoles: number
  }

  export type ChanDiscussionMessageCountOutputTypeSelect = {
    relatedUsers?: boolean
    relatedRoles?: boolean
  }

  export type ChanDiscussionMessageCountOutputTypeGetPayload<S extends boolean | null | undefined | ChanDiscussionMessageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChanDiscussionMessageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChanDiscussionMessageCountOutputTypeArgs)
    ? ChanDiscussionMessageCountOutputType 
    : S extends { select: any } & (ChanDiscussionMessageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChanDiscussionMessageCountOutputType ? ChanDiscussionMessageCountOutputType[P] : never
  } 
      : ChanDiscussionMessageCountOutputType




  // Custom InputTypes

  /**
   * ChanDiscussionMessageCountOutputType without action
   */
  export type ChanDiscussionMessageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessageCountOutputType
     */
    select?: ChanDiscussionMessageCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    roleApplyOn: RoleApplyingType | null
    chanId: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    roleApplyOn: RoleApplyingType | null
    chanId: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    permissions: number
    roleApplyOn: number
    chanId: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    roleApplyOn?: true
    chanId?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    roleApplyOn?: true
    chanId?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    permissions?: true
    roleApplyOn?: true
    chanId?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: RoleScalarFieldEnum[]
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: string
    name: string
    permissions: PermissionList[]
    roleApplyOn: RoleApplyingType
    chanId: string
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    name?: boolean
    permissions?: boolean
    roleApplyOn?: boolean
    chanId?: boolean
    roles?: boolean | Role$rolesArgs
    rolesSym?: boolean | Role$rolesSymArgs
    users?: boolean | Role$usersArgs
    chan?: boolean | ChanArgs
    relatedDiscussionMessage?: boolean | Role$relatedDiscussionMessageArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }


  export type RoleInclude = {
    roles?: boolean | Role$rolesArgs
    rolesSym?: boolean | Role$rolesSymArgs
    users?: boolean | Role$usersArgs
    chan?: boolean | ChanArgs
    relatedDiscussionMessage?: boolean | Role$relatedDiscussionMessageArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<S extends boolean | null | undefined | RoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Role :
    S extends undefined ? never :
    S extends { include: any } & (RoleArgs | RoleFindManyArgs)
    ? Role  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'roles' ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'rolesSym' ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'chan' ? ChanGetPayload<S['include'][P]> :
        P extends 'relatedDiscussionMessage' ? Array < ChanDiscussionMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoleArgs | RoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'roles' ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'rolesSym' ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'chan' ? ChanGetPayload<S['select'][P]> :
        P extends 'relatedDiscussionMessage' ? Array < ChanDiscussionMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Role ? Role[P] : never
  } 
      : Role


  type RoleCountArgs = 
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): Prisma.PrismaPromise<Array<RoleGetPayload<T>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    roles<T extends Role$rolesArgs= {}>(args?: Subset<T, Role$rolesArgs>): Prisma.PrismaPromise<Array<RoleGetPayload<T>>| Null>;

    rolesSym<T extends Role$rolesSymArgs= {}>(args?: Subset<T, Role$rolesSymArgs>): Prisma.PrismaPromise<Array<RoleGetPayload<T>>| Null>;

    users<T extends Role$usersArgs= {}>(args?: Subset<T, Role$usersArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    chan<T extends ChanArgs= {}>(args?: Subset<T, ChanArgs>): Prisma__ChanClient<ChanGetPayload<T> | Null>;

    relatedDiscussionMessage<T extends Role$relatedDiscussionMessageArgs= {}>(args?: Subset<T, Role$relatedDiscussionMessageArgs>): Prisma.PrismaPromise<Array<ChanDiscussionMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Role base type for findUnique actions
   */
  export type RoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUnique
   */
  export interface RoleFindUniqueArgs extends RoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role base type for findFirst actions
   */
  export type RoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * Role findFirst
   */
  export interface RoleFindFirstArgs extends RoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     */
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }


  /**
   * Role.roles
   */
  export type Role$rolesArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role.rolesSym
   */
  export type Role$rolesSymArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role.users
   */
  export type Role$usersArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Role.relatedDiscussionMessage
   */
  export type Role$relatedDiscussionMessageArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    where?: ChanDiscussionMessageWhereInput
    orderBy?: Enumerable<ChanDiscussionMessageOrderByWithRelationInput>
    cursor?: ChanDiscussionMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanDiscussionMessageScalarFieldEnum>
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
  }



  /**
   * Model FriendInvitation
   */


  export type AggregateFriendInvitation = {
    _count: FriendInvitationCountAggregateOutputType | null
    _min: FriendInvitationMinAggregateOutputType | null
    _max: FriendInvitationMaxAggregateOutputType | null
  }

  export type FriendInvitationMinAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    invitingUserName: string | null
    invitedUserName: string | null
    status: FriendInvitationStatus | null
  }

  export type FriendInvitationMaxAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    invitingUserName: string | null
    invitedUserName: string | null
    status: FriendInvitationStatus | null
  }

  export type FriendInvitationCountAggregateOutputType = {
    id: number
    creationDate: number
    modificationDate: number
    invitingUserName: number
    invitedUserName: number
    status: number
    _all: number
  }


  export type FriendInvitationMinAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    invitingUserName?: true
    invitedUserName?: true
    status?: true
  }

  export type FriendInvitationMaxAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    invitingUserName?: true
    invitedUserName?: true
    status?: true
  }

  export type FriendInvitationCountAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    invitingUserName?: true
    invitedUserName?: true
    status?: true
    _all?: true
  }

  export type FriendInvitationAggregateArgs = {
    /**
     * Filter which FriendInvitation to aggregate.
     */
    where?: FriendInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendInvitations to fetch.
     */
    orderBy?: Enumerable<FriendInvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FriendInvitations
    **/
    _count?: true | FriendInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendInvitationMaxAggregateInputType
  }

  export type GetFriendInvitationAggregateType<T extends FriendInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendInvitation[P]>
      : GetScalarType<T[P], AggregateFriendInvitation[P]>
  }




  export type FriendInvitationGroupByArgs = {
    where?: FriendInvitationWhereInput
    orderBy?: Enumerable<FriendInvitationOrderByWithAggregationInput>
    by: FriendInvitationScalarFieldEnum[]
    having?: FriendInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendInvitationCountAggregateInputType | true
    _min?: FriendInvitationMinAggregateInputType
    _max?: FriendInvitationMaxAggregateInputType
  }


  export type FriendInvitationGroupByOutputType = {
    id: string
    creationDate: Date
    modificationDate: Date | null
    invitingUserName: string
    invitedUserName: string
    status: FriendInvitationStatus
    _count: FriendInvitationCountAggregateOutputType | null
    _min: FriendInvitationMinAggregateOutputType | null
    _max: FriendInvitationMaxAggregateOutputType | null
  }

  type GetFriendInvitationGroupByPayload<T extends FriendInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FriendInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], FriendInvitationGroupByOutputType[P]>
        }
      >
    >


  export type FriendInvitationSelect = {
    id?: boolean
    creationDate?: boolean
    modificationDate?: boolean
    invitingUserName?: boolean
    invitedUserName?: boolean
    status?: boolean
    invitingUser?: boolean | UserArgs
    invitedUser?: boolean | UserArgs
  }


  export type FriendInvitationInclude = {
    invitingUser?: boolean | UserArgs
    invitedUser?: boolean | UserArgs
  }

  export type FriendInvitationGetPayload<S extends boolean | null | undefined | FriendInvitationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FriendInvitation :
    S extends undefined ? never :
    S extends { include: any } & (FriendInvitationArgs | FriendInvitationFindManyArgs)
    ? FriendInvitation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'invitingUser' ? UserGetPayload<S['include'][P]> :
        P extends 'invitedUser' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FriendInvitationArgs | FriendInvitationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'invitingUser' ? UserGetPayload<S['select'][P]> :
        P extends 'invitedUser' ? UserGetPayload<S['select'][P]> :  P extends keyof FriendInvitation ? FriendInvitation[P] : never
  } 
      : FriendInvitation


  type FriendInvitationCountArgs = 
    Omit<FriendInvitationFindManyArgs, 'select' | 'include'> & {
      select?: FriendInvitationCountAggregateInputType | true
    }

  export interface FriendInvitationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FriendInvitation that matches the filter.
     * @param {FriendInvitationFindUniqueArgs} args - Arguments to find a FriendInvitation
     * @example
     * // Get one FriendInvitation
     * const friendInvitation = await prisma.friendInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FriendInvitationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FriendInvitationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FriendInvitation'> extends True ? Prisma__FriendInvitationClient<FriendInvitationGetPayload<T>> : Prisma__FriendInvitationClient<FriendInvitationGetPayload<T> | null, null>

    /**
     * Find one FriendInvitation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FriendInvitationFindUniqueOrThrowArgs} args - Arguments to find a FriendInvitation
     * @example
     * // Get one FriendInvitation
     * const friendInvitation = await prisma.friendInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FriendInvitationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FriendInvitationFindUniqueOrThrowArgs>
    ): Prisma__FriendInvitationClient<FriendInvitationGetPayload<T>>

    /**
     * Find the first FriendInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendInvitationFindFirstArgs} args - Arguments to find a FriendInvitation
     * @example
     * // Get one FriendInvitation
     * const friendInvitation = await prisma.friendInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FriendInvitationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FriendInvitationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FriendInvitation'> extends True ? Prisma__FriendInvitationClient<FriendInvitationGetPayload<T>> : Prisma__FriendInvitationClient<FriendInvitationGetPayload<T> | null, null>

    /**
     * Find the first FriendInvitation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendInvitationFindFirstOrThrowArgs} args - Arguments to find a FriendInvitation
     * @example
     * // Get one FriendInvitation
     * const friendInvitation = await prisma.friendInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FriendInvitationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FriendInvitationFindFirstOrThrowArgs>
    ): Prisma__FriendInvitationClient<FriendInvitationGetPayload<T>>

    /**
     * Find zero or more FriendInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendInvitationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FriendInvitations
     * const friendInvitations = await prisma.friendInvitation.findMany()
     * 
     * // Get first 10 FriendInvitations
     * const friendInvitations = await prisma.friendInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendInvitationWithIdOnly = await prisma.friendInvitation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FriendInvitationFindManyArgs>(
      args?: SelectSubset<T, FriendInvitationFindManyArgs>
    ): Prisma.PrismaPromise<Array<FriendInvitationGetPayload<T>>>

    /**
     * Create a FriendInvitation.
     * @param {FriendInvitationCreateArgs} args - Arguments to create a FriendInvitation.
     * @example
     * // Create one FriendInvitation
     * const FriendInvitation = await prisma.friendInvitation.create({
     *   data: {
     *     // ... data to create a FriendInvitation
     *   }
     * })
     * 
    **/
    create<T extends FriendInvitationCreateArgs>(
      args: SelectSubset<T, FriendInvitationCreateArgs>
    ): Prisma__FriendInvitationClient<FriendInvitationGetPayload<T>>

    /**
     * Create many FriendInvitations.
     *     @param {FriendInvitationCreateManyArgs} args - Arguments to create many FriendInvitations.
     *     @example
     *     // Create many FriendInvitations
     *     const friendInvitation = await prisma.friendInvitation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FriendInvitationCreateManyArgs>(
      args?: SelectSubset<T, FriendInvitationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FriendInvitation.
     * @param {FriendInvitationDeleteArgs} args - Arguments to delete one FriendInvitation.
     * @example
     * // Delete one FriendInvitation
     * const FriendInvitation = await prisma.friendInvitation.delete({
     *   where: {
     *     // ... filter to delete one FriendInvitation
     *   }
     * })
     * 
    **/
    delete<T extends FriendInvitationDeleteArgs>(
      args: SelectSubset<T, FriendInvitationDeleteArgs>
    ): Prisma__FriendInvitationClient<FriendInvitationGetPayload<T>>

    /**
     * Update one FriendInvitation.
     * @param {FriendInvitationUpdateArgs} args - Arguments to update one FriendInvitation.
     * @example
     * // Update one FriendInvitation
     * const friendInvitation = await prisma.friendInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FriendInvitationUpdateArgs>(
      args: SelectSubset<T, FriendInvitationUpdateArgs>
    ): Prisma__FriendInvitationClient<FriendInvitationGetPayload<T>>

    /**
     * Delete zero or more FriendInvitations.
     * @param {FriendInvitationDeleteManyArgs} args - Arguments to filter FriendInvitations to delete.
     * @example
     * // Delete a few FriendInvitations
     * const { count } = await prisma.friendInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FriendInvitationDeleteManyArgs>(
      args?: SelectSubset<T, FriendInvitationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FriendInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FriendInvitations
     * const friendInvitation = await prisma.friendInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FriendInvitationUpdateManyArgs>(
      args: SelectSubset<T, FriendInvitationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FriendInvitation.
     * @param {FriendInvitationUpsertArgs} args - Arguments to update or create a FriendInvitation.
     * @example
     * // Update or create a FriendInvitation
     * const friendInvitation = await prisma.friendInvitation.upsert({
     *   create: {
     *     // ... data to create a FriendInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FriendInvitation we want to update
     *   }
     * })
    **/
    upsert<T extends FriendInvitationUpsertArgs>(
      args: SelectSubset<T, FriendInvitationUpsertArgs>
    ): Prisma__FriendInvitationClient<FriendInvitationGetPayload<T>>

    /**
     * Count the number of FriendInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendInvitationCountArgs} args - Arguments to filter FriendInvitations to count.
     * @example
     * // Count the number of FriendInvitations
     * const count = await prisma.friendInvitation.count({
     *   where: {
     *     // ... the filter for the FriendInvitations we want to count
     *   }
     * })
    **/
    count<T extends FriendInvitationCountArgs>(
      args?: Subset<T, FriendInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FriendInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendInvitationAggregateArgs>(args: Subset<T, FriendInvitationAggregateArgs>): Prisma.PrismaPromise<GetFriendInvitationAggregateType<T>>

    /**
     * Group by FriendInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendInvitationGroupByArgs['orderBy'] }
        : { orderBy?: FriendInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FriendInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FriendInvitationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    invitingUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    invitedUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FriendInvitation base type for findUnique actions
   */
  export type FriendInvitationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    /**
     * Filter, which FriendInvitation to fetch.
     */
    where: FriendInvitationWhereUniqueInput
  }

  /**
   * FriendInvitation findUnique
   */
  export interface FriendInvitationFindUniqueArgs extends FriendInvitationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FriendInvitation findUniqueOrThrow
   */
  export type FriendInvitationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    /**
     * Filter, which FriendInvitation to fetch.
     */
    where: FriendInvitationWhereUniqueInput
  }


  /**
   * FriendInvitation base type for findFirst actions
   */
  export type FriendInvitationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    /**
     * Filter, which FriendInvitation to fetch.
     */
    where?: FriendInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendInvitations to fetch.
     */
    orderBy?: Enumerable<FriendInvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendInvitations.
     */
    cursor?: FriendInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendInvitations.
     */
    distinct?: Enumerable<FriendInvitationScalarFieldEnum>
  }

  /**
   * FriendInvitation findFirst
   */
  export interface FriendInvitationFindFirstArgs extends FriendInvitationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FriendInvitation findFirstOrThrow
   */
  export type FriendInvitationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    /**
     * Filter, which FriendInvitation to fetch.
     */
    where?: FriendInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendInvitations to fetch.
     */
    orderBy?: Enumerable<FriendInvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendInvitations.
     */
    cursor?: FriendInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendInvitations.
     */
    distinct?: Enumerable<FriendInvitationScalarFieldEnum>
  }


  /**
   * FriendInvitation findMany
   */
  export type FriendInvitationFindManyArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    /**
     * Filter, which FriendInvitations to fetch.
     */
    where?: FriendInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendInvitations to fetch.
     */
    orderBy?: Enumerable<FriendInvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FriendInvitations.
     */
    cursor?: FriendInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendInvitations.
     */
    skip?: number
    distinct?: Enumerable<FriendInvitationScalarFieldEnum>
  }


  /**
   * FriendInvitation create
   */
  export type FriendInvitationCreateArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    /**
     * The data needed to create a FriendInvitation.
     */
    data: XOR<FriendInvitationCreateInput, FriendInvitationUncheckedCreateInput>
  }


  /**
   * FriendInvitation createMany
   */
  export type FriendInvitationCreateManyArgs = {
    /**
     * The data used to create many FriendInvitations.
     */
    data: Enumerable<FriendInvitationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FriendInvitation update
   */
  export type FriendInvitationUpdateArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    /**
     * The data needed to update a FriendInvitation.
     */
    data: XOR<FriendInvitationUpdateInput, FriendInvitationUncheckedUpdateInput>
    /**
     * Choose, which FriendInvitation to update.
     */
    where: FriendInvitationWhereUniqueInput
  }


  /**
   * FriendInvitation updateMany
   */
  export type FriendInvitationUpdateManyArgs = {
    /**
     * The data used to update FriendInvitations.
     */
    data: XOR<FriendInvitationUpdateManyMutationInput, FriendInvitationUncheckedUpdateManyInput>
    /**
     * Filter which FriendInvitations to update
     */
    where?: FriendInvitationWhereInput
  }


  /**
   * FriendInvitation upsert
   */
  export type FriendInvitationUpsertArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    /**
     * The filter to search for the FriendInvitation to update in case it exists.
     */
    where: FriendInvitationWhereUniqueInput
    /**
     * In case the FriendInvitation found by the `where` argument doesn't exist, create a new FriendInvitation with this data.
     */
    create: XOR<FriendInvitationCreateInput, FriendInvitationUncheckedCreateInput>
    /**
     * In case the FriendInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendInvitationUpdateInput, FriendInvitationUncheckedUpdateInput>
  }


  /**
   * FriendInvitation delete
   */
  export type FriendInvitationDeleteArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    /**
     * Filter which FriendInvitation to delete.
     */
    where: FriendInvitationWhereUniqueInput
  }


  /**
   * FriendInvitation deleteMany
   */
  export type FriendInvitationDeleteManyArgs = {
    /**
     * Filter which FriendInvitations to delete
     */
    where?: FriendInvitationWhereInput
  }


  /**
   * FriendInvitation without action
   */
  export type FriendInvitationArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
  }



  /**
   * Model ChanInvitation
   */


  export type AggregateChanInvitation = {
    _count: ChanInvitationCountAggregateOutputType | null
    _min: ChanInvitationMinAggregateOutputType | null
    _max: ChanInvitationMaxAggregateOutputType | null
  }

  export type ChanInvitationMinAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    chanId: string | null
    chanTitle: string | null
    invitingUserName: string | null
    invitedUserName: string | null
    status: ChanInvitationStatus | null
  }

  export type ChanInvitationMaxAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    chanId: string | null
    chanTitle: string | null
    invitingUserName: string | null
    invitedUserName: string | null
    status: ChanInvitationStatus | null
  }

  export type ChanInvitationCountAggregateOutputType = {
    id: number
    creationDate: number
    modificationDate: number
    chanId: number
    chanTitle: number
    invitingUserName: number
    invitedUserName: number
    status: number
    _all: number
  }


  export type ChanInvitationMinAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    chanId?: true
    chanTitle?: true
    invitingUserName?: true
    invitedUserName?: true
    status?: true
  }

  export type ChanInvitationMaxAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    chanId?: true
    chanTitle?: true
    invitingUserName?: true
    invitedUserName?: true
    status?: true
  }

  export type ChanInvitationCountAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    chanId?: true
    chanTitle?: true
    invitingUserName?: true
    invitedUserName?: true
    status?: true
    _all?: true
  }

  export type ChanInvitationAggregateArgs = {
    /**
     * Filter which ChanInvitation to aggregate.
     */
    where?: ChanInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanInvitations to fetch.
     */
    orderBy?: Enumerable<ChanInvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChanInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChanInvitations
    **/
    _count?: true | ChanInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChanInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChanInvitationMaxAggregateInputType
  }

  export type GetChanInvitationAggregateType<T extends ChanInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateChanInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChanInvitation[P]>
      : GetScalarType<T[P], AggregateChanInvitation[P]>
  }




  export type ChanInvitationGroupByArgs = {
    where?: ChanInvitationWhereInput
    orderBy?: Enumerable<ChanInvitationOrderByWithAggregationInput>
    by: ChanInvitationScalarFieldEnum[]
    having?: ChanInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChanInvitationCountAggregateInputType | true
    _min?: ChanInvitationMinAggregateInputType
    _max?: ChanInvitationMaxAggregateInputType
  }


  export type ChanInvitationGroupByOutputType = {
    id: string
    creationDate: Date
    modificationDate: Date | null
    chanId: string
    chanTitle: string
    invitingUserName: string
    invitedUserName: string
    status: ChanInvitationStatus
    _count: ChanInvitationCountAggregateOutputType | null
    _min: ChanInvitationMinAggregateOutputType | null
    _max: ChanInvitationMaxAggregateOutputType | null
  }

  type GetChanInvitationGroupByPayload<T extends ChanInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChanInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChanInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChanInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], ChanInvitationGroupByOutputType[P]>
        }
      >
    >


  export type ChanInvitationSelect = {
    id?: boolean
    creationDate?: boolean
    modificationDate?: boolean
    chanId?: boolean
    chanTitle?: boolean
    invitingUserName?: boolean
    invitedUserName?: boolean
    status?: boolean
    chan?: boolean | ChanArgs
    discussionEvent?: boolean | ChanInvitation$discussionEventArgs
    invitingUser?: boolean | UserArgs
    invitedUser?: boolean | UserArgs
  }


  export type ChanInvitationInclude = {
    chan?: boolean | ChanArgs
    discussionEvent?: boolean | ChanInvitation$discussionEventArgs
    invitingUser?: boolean | UserArgs
    invitedUser?: boolean | UserArgs
  }

  export type ChanInvitationGetPayload<S extends boolean | null | undefined | ChanInvitationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChanInvitation :
    S extends undefined ? never :
    S extends { include: any } & (ChanInvitationArgs | ChanInvitationFindManyArgs)
    ? ChanInvitation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'chan' ? ChanGetPayload<S['include'][P]> :
        P extends 'discussionEvent' ? ChanInvitationDmDiscussionEventGetPayload<S['include'][P]> | null :
        P extends 'invitingUser' ? UserGetPayload<S['include'][P]> :
        P extends 'invitedUser' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChanInvitationArgs | ChanInvitationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'chan' ? ChanGetPayload<S['select'][P]> :
        P extends 'discussionEvent' ? ChanInvitationDmDiscussionEventGetPayload<S['select'][P]> | null :
        P extends 'invitingUser' ? UserGetPayload<S['select'][P]> :
        P extends 'invitedUser' ? UserGetPayload<S['select'][P]> :  P extends keyof ChanInvitation ? ChanInvitation[P] : never
  } 
      : ChanInvitation


  type ChanInvitationCountArgs = 
    Omit<ChanInvitationFindManyArgs, 'select' | 'include'> & {
      select?: ChanInvitationCountAggregateInputType | true
    }

  export interface ChanInvitationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChanInvitation that matches the filter.
     * @param {ChanInvitationFindUniqueArgs} args - Arguments to find a ChanInvitation
     * @example
     * // Get one ChanInvitation
     * const chanInvitation = await prisma.chanInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChanInvitationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChanInvitationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChanInvitation'> extends True ? Prisma__ChanInvitationClient<ChanInvitationGetPayload<T>> : Prisma__ChanInvitationClient<ChanInvitationGetPayload<T> | null, null>

    /**
     * Find one ChanInvitation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChanInvitationFindUniqueOrThrowArgs} args - Arguments to find a ChanInvitation
     * @example
     * // Get one ChanInvitation
     * const chanInvitation = await prisma.chanInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChanInvitationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChanInvitationFindUniqueOrThrowArgs>
    ): Prisma__ChanInvitationClient<ChanInvitationGetPayload<T>>

    /**
     * Find the first ChanInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationFindFirstArgs} args - Arguments to find a ChanInvitation
     * @example
     * // Get one ChanInvitation
     * const chanInvitation = await prisma.chanInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChanInvitationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChanInvitationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChanInvitation'> extends True ? Prisma__ChanInvitationClient<ChanInvitationGetPayload<T>> : Prisma__ChanInvitationClient<ChanInvitationGetPayload<T> | null, null>

    /**
     * Find the first ChanInvitation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationFindFirstOrThrowArgs} args - Arguments to find a ChanInvitation
     * @example
     * // Get one ChanInvitation
     * const chanInvitation = await prisma.chanInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChanInvitationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChanInvitationFindFirstOrThrowArgs>
    ): Prisma__ChanInvitationClient<ChanInvitationGetPayload<T>>

    /**
     * Find zero or more ChanInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChanInvitations
     * const chanInvitations = await prisma.chanInvitation.findMany()
     * 
     * // Get first 10 ChanInvitations
     * const chanInvitations = await prisma.chanInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chanInvitationWithIdOnly = await prisma.chanInvitation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChanInvitationFindManyArgs>(
      args?: SelectSubset<T, ChanInvitationFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChanInvitationGetPayload<T>>>

    /**
     * Create a ChanInvitation.
     * @param {ChanInvitationCreateArgs} args - Arguments to create a ChanInvitation.
     * @example
     * // Create one ChanInvitation
     * const ChanInvitation = await prisma.chanInvitation.create({
     *   data: {
     *     // ... data to create a ChanInvitation
     *   }
     * })
     * 
    **/
    create<T extends ChanInvitationCreateArgs>(
      args: SelectSubset<T, ChanInvitationCreateArgs>
    ): Prisma__ChanInvitationClient<ChanInvitationGetPayload<T>>

    /**
     * Create many ChanInvitations.
     *     @param {ChanInvitationCreateManyArgs} args - Arguments to create many ChanInvitations.
     *     @example
     *     // Create many ChanInvitations
     *     const chanInvitation = await prisma.chanInvitation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChanInvitationCreateManyArgs>(
      args?: SelectSubset<T, ChanInvitationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChanInvitation.
     * @param {ChanInvitationDeleteArgs} args - Arguments to delete one ChanInvitation.
     * @example
     * // Delete one ChanInvitation
     * const ChanInvitation = await prisma.chanInvitation.delete({
     *   where: {
     *     // ... filter to delete one ChanInvitation
     *   }
     * })
     * 
    **/
    delete<T extends ChanInvitationDeleteArgs>(
      args: SelectSubset<T, ChanInvitationDeleteArgs>
    ): Prisma__ChanInvitationClient<ChanInvitationGetPayload<T>>

    /**
     * Update one ChanInvitation.
     * @param {ChanInvitationUpdateArgs} args - Arguments to update one ChanInvitation.
     * @example
     * // Update one ChanInvitation
     * const chanInvitation = await prisma.chanInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChanInvitationUpdateArgs>(
      args: SelectSubset<T, ChanInvitationUpdateArgs>
    ): Prisma__ChanInvitationClient<ChanInvitationGetPayload<T>>

    /**
     * Delete zero or more ChanInvitations.
     * @param {ChanInvitationDeleteManyArgs} args - Arguments to filter ChanInvitations to delete.
     * @example
     * // Delete a few ChanInvitations
     * const { count } = await prisma.chanInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChanInvitationDeleteManyArgs>(
      args?: SelectSubset<T, ChanInvitationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChanInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChanInvitations
     * const chanInvitation = await prisma.chanInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChanInvitationUpdateManyArgs>(
      args: SelectSubset<T, ChanInvitationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChanInvitation.
     * @param {ChanInvitationUpsertArgs} args - Arguments to update or create a ChanInvitation.
     * @example
     * // Update or create a ChanInvitation
     * const chanInvitation = await prisma.chanInvitation.upsert({
     *   create: {
     *     // ... data to create a ChanInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChanInvitation we want to update
     *   }
     * })
    **/
    upsert<T extends ChanInvitationUpsertArgs>(
      args: SelectSubset<T, ChanInvitationUpsertArgs>
    ): Prisma__ChanInvitationClient<ChanInvitationGetPayload<T>>

    /**
     * Count the number of ChanInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationCountArgs} args - Arguments to filter ChanInvitations to count.
     * @example
     * // Count the number of ChanInvitations
     * const count = await prisma.chanInvitation.count({
     *   where: {
     *     // ... the filter for the ChanInvitations we want to count
     *   }
     * })
    **/
    count<T extends ChanInvitationCountArgs>(
      args?: Subset<T, ChanInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChanInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChanInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChanInvitationAggregateArgs>(args: Subset<T, ChanInvitationAggregateArgs>): Prisma.PrismaPromise<GetChanInvitationAggregateType<T>>

    /**
     * Group by ChanInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChanInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChanInvitationGroupByArgs['orderBy'] }
        : { orderBy?: ChanInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChanInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChanInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChanInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChanInvitationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chan<T extends ChanArgs= {}>(args?: Subset<T, ChanArgs>): Prisma__ChanClient<ChanGetPayload<T> | Null>;

    discussionEvent<T extends ChanInvitation$discussionEventArgs= {}>(args?: Subset<T, ChanInvitation$discussionEventArgs>): Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T> | Null>;

    invitingUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    invitedUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChanInvitation base type for findUnique actions
   */
  export type ChanInvitationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    /**
     * Filter, which ChanInvitation to fetch.
     */
    where: ChanInvitationWhereUniqueInput
  }

  /**
   * ChanInvitation findUnique
   */
  export interface ChanInvitationFindUniqueArgs extends ChanInvitationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanInvitation findUniqueOrThrow
   */
  export type ChanInvitationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    /**
     * Filter, which ChanInvitation to fetch.
     */
    where: ChanInvitationWhereUniqueInput
  }


  /**
   * ChanInvitation base type for findFirst actions
   */
  export type ChanInvitationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    /**
     * Filter, which ChanInvitation to fetch.
     */
    where?: ChanInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanInvitations to fetch.
     */
    orderBy?: Enumerable<ChanInvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanInvitations.
     */
    cursor?: ChanInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanInvitations.
     */
    distinct?: Enumerable<ChanInvitationScalarFieldEnum>
  }

  /**
   * ChanInvitation findFirst
   */
  export interface ChanInvitationFindFirstArgs extends ChanInvitationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanInvitation findFirstOrThrow
   */
  export type ChanInvitationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    /**
     * Filter, which ChanInvitation to fetch.
     */
    where?: ChanInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanInvitations to fetch.
     */
    orderBy?: Enumerable<ChanInvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanInvitations.
     */
    cursor?: ChanInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanInvitations.
     */
    distinct?: Enumerable<ChanInvitationScalarFieldEnum>
  }


  /**
   * ChanInvitation findMany
   */
  export type ChanInvitationFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    /**
     * Filter, which ChanInvitations to fetch.
     */
    where?: ChanInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanInvitations to fetch.
     */
    orderBy?: Enumerable<ChanInvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChanInvitations.
     */
    cursor?: ChanInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanInvitations.
     */
    skip?: number
    distinct?: Enumerable<ChanInvitationScalarFieldEnum>
  }


  /**
   * ChanInvitation create
   */
  export type ChanInvitationCreateArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    /**
     * The data needed to create a ChanInvitation.
     */
    data: XOR<ChanInvitationCreateInput, ChanInvitationUncheckedCreateInput>
  }


  /**
   * ChanInvitation createMany
   */
  export type ChanInvitationCreateManyArgs = {
    /**
     * The data used to create many ChanInvitations.
     */
    data: Enumerable<ChanInvitationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChanInvitation update
   */
  export type ChanInvitationUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    /**
     * The data needed to update a ChanInvitation.
     */
    data: XOR<ChanInvitationUpdateInput, ChanInvitationUncheckedUpdateInput>
    /**
     * Choose, which ChanInvitation to update.
     */
    where: ChanInvitationWhereUniqueInput
  }


  /**
   * ChanInvitation updateMany
   */
  export type ChanInvitationUpdateManyArgs = {
    /**
     * The data used to update ChanInvitations.
     */
    data: XOR<ChanInvitationUpdateManyMutationInput, ChanInvitationUncheckedUpdateManyInput>
    /**
     * Filter which ChanInvitations to update
     */
    where?: ChanInvitationWhereInput
  }


  /**
   * ChanInvitation upsert
   */
  export type ChanInvitationUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    /**
     * The filter to search for the ChanInvitation to update in case it exists.
     */
    where: ChanInvitationWhereUniqueInput
    /**
     * In case the ChanInvitation found by the `where` argument doesn't exist, create a new ChanInvitation with this data.
     */
    create: XOR<ChanInvitationCreateInput, ChanInvitationUncheckedCreateInput>
    /**
     * In case the ChanInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChanInvitationUpdateInput, ChanInvitationUncheckedUpdateInput>
  }


  /**
   * ChanInvitation delete
   */
  export type ChanInvitationDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    /**
     * Filter which ChanInvitation to delete.
     */
    where: ChanInvitationWhereUniqueInput
  }


  /**
   * ChanInvitation deleteMany
   */
  export type ChanInvitationDeleteManyArgs = {
    /**
     * Filter which ChanInvitations to delete
     */
    where?: ChanInvitationWhereInput
  }


  /**
   * ChanInvitation.discussionEvent
   */
  export type ChanInvitation$discussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    where?: ChanInvitationDmDiscussionEventWhereInput
  }


  /**
   * ChanInvitation without action
   */
  export type ChanInvitationArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
  }



  /**
   * Model FriendShip
   */


  export type AggregateFriendShip = {
    _count: FriendShipCountAggregateOutputType | null
    _min: FriendShipMinAggregateOutputType | null
    _max: FriendShipMaxAggregateOutputType | null
  }

  export type FriendShipMinAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    requestingUserName: string | null
    requestedUserName: string | null
  }

  export type FriendShipMaxAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    requestingUserName: string | null
    requestedUserName: string | null
  }

  export type FriendShipCountAggregateOutputType = {
    id: number
    creationDate: number
    modificationDate: number
    requestingUserName: number
    requestedUserName: number
    _all: number
  }


  export type FriendShipMinAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    requestingUserName?: true
    requestedUserName?: true
  }

  export type FriendShipMaxAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    requestingUserName?: true
    requestedUserName?: true
  }

  export type FriendShipCountAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    requestingUserName?: true
    requestedUserName?: true
    _all?: true
  }

  export type FriendShipAggregateArgs = {
    /**
     * Filter which FriendShip to aggregate.
     */
    where?: FriendShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendShips to fetch.
     */
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FriendShips
    **/
    _count?: true | FriendShipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendShipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendShipMaxAggregateInputType
  }

  export type GetFriendShipAggregateType<T extends FriendShipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendShip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendShip[P]>
      : GetScalarType<T[P], AggregateFriendShip[P]>
  }




  export type FriendShipGroupByArgs = {
    where?: FriendShipWhereInput
    orderBy?: Enumerable<FriendShipOrderByWithAggregationInput>
    by: FriendShipScalarFieldEnum[]
    having?: FriendShipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendShipCountAggregateInputType | true
    _min?: FriendShipMinAggregateInputType
    _max?: FriendShipMaxAggregateInputType
  }


  export type FriendShipGroupByOutputType = {
    id: string
    creationDate: Date
    modificationDate: Date | null
    requestingUserName: string
    requestedUserName: string
    _count: FriendShipCountAggregateOutputType | null
    _min: FriendShipMinAggregateOutputType | null
    _max: FriendShipMaxAggregateOutputType | null
  }

  type GetFriendShipGroupByPayload<T extends FriendShipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FriendShipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendShipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendShipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendShipGroupByOutputType[P]>
        }
      >
    >


  export type FriendShipSelect = {
    id?: boolean
    creationDate?: boolean
    modificationDate?: boolean
    requestingUserName?: boolean
    requestedUserName?: boolean
    requestingUser?: boolean | UserArgs
    requestedUser?: boolean | UserArgs
  }


  export type FriendShipInclude = {
    requestingUser?: boolean | UserArgs
    requestedUser?: boolean | UserArgs
  }

  export type FriendShipGetPayload<S extends boolean | null | undefined | FriendShipArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FriendShip :
    S extends undefined ? never :
    S extends { include: any } & (FriendShipArgs | FriendShipFindManyArgs)
    ? FriendShip  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'requestingUser' ? UserGetPayload<S['include'][P]> :
        P extends 'requestedUser' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FriendShipArgs | FriendShipFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'requestingUser' ? UserGetPayload<S['select'][P]> :
        P extends 'requestedUser' ? UserGetPayload<S['select'][P]> :  P extends keyof FriendShip ? FriendShip[P] : never
  } 
      : FriendShip


  type FriendShipCountArgs = 
    Omit<FriendShipFindManyArgs, 'select' | 'include'> & {
      select?: FriendShipCountAggregateInputType | true
    }

  export interface FriendShipDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FriendShip that matches the filter.
     * @param {FriendShipFindUniqueArgs} args - Arguments to find a FriendShip
     * @example
     * // Get one FriendShip
     * const friendShip = await prisma.friendShip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FriendShipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FriendShipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FriendShip'> extends True ? Prisma__FriendShipClient<FriendShipGetPayload<T>> : Prisma__FriendShipClient<FriendShipGetPayload<T> | null, null>

    /**
     * Find one FriendShip that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FriendShipFindUniqueOrThrowArgs} args - Arguments to find a FriendShip
     * @example
     * // Get one FriendShip
     * const friendShip = await prisma.friendShip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FriendShipFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FriendShipFindUniqueOrThrowArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Find the first FriendShip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipFindFirstArgs} args - Arguments to find a FriendShip
     * @example
     * // Get one FriendShip
     * const friendShip = await prisma.friendShip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FriendShipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FriendShipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FriendShip'> extends True ? Prisma__FriendShipClient<FriendShipGetPayload<T>> : Prisma__FriendShipClient<FriendShipGetPayload<T> | null, null>

    /**
     * Find the first FriendShip that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipFindFirstOrThrowArgs} args - Arguments to find a FriendShip
     * @example
     * // Get one FriendShip
     * const friendShip = await prisma.friendShip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FriendShipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FriendShipFindFirstOrThrowArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Find zero or more FriendShips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FriendShips
     * const friendShips = await prisma.friendShip.findMany()
     * 
     * // Get first 10 FriendShips
     * const friendShips = await prisma.friendShip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendShipWithIdOnly = await prisma.friendShip.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FriendShipFindManyArgs>(
      args?: SelectSubset<T, FriendShipFindManyArgs>
    ): Prisma.PrismaPromise<Array<FriendShipGetPayload<T>>>

    /**
     * Create a FriendShip.
     * @param {FriendShipCreateArgs} args - Arguments to create a FriendShip.
     * @example
     * // Create one FriendShip
     * const FriendShip = await prisma.friendShip.create({
     *   data: {
     *     // ... data to create a FriendShip
     *   }
     * })
     * 
    **/
    create<T extends FriendShipCreateArgs>(
      args: SelectSubset<T, FriendShipCreateArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Create many FriendShips.
     *     @param {FriendShipCreateManyArgs} args - Arguments to create many FriendShips.
     *     @example
     *     // Create many FriendShips
     *     const friendShip = await prisma.friendShip.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FriendShipCreateManyArgs>(
      args?: SelectSubset<T, FriendShipCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FriendShip.
     * @param {FriendShipDeleteArgs} args - Arguments to delete one FriendShip.
     * @example
     * // Delete one FriendShip
     * const FriendShip = await prisma.friendShip.delete({
     *   where: {
     *     // ... filter to delete one FriendShip
     *   }
     * })
     * 
    **/
    delete<T extends FriendShipDeleteArgs>(
      args: SelectSubset<T, FriendShipDeleteArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Update one FriendShip.
     * @param {FriendShipUpdateArgs} args - Arguments to update one FriendShip.
     * @example
     * // Update one FriendShip
     * const friendShip = await prisma.friendShip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FriendShipUpdateArgs>(
      args: SelectSubset<T, FriendShipUpdateArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Delete zero or more FriendShips.
     * @param {FriendShipDeleteManyArgs} args - Arguments to filter FriendShips to delete.
     * @example
     * // Delete a few FriendShips
     * const { count } = await prisma.friendShip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FriendShipDeleteManyArgs>(
      args?: SelectSubset<T, FriendShipDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FriendShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FriendShips
     * const friendShip = await prisma.friendShip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FriendShipUpdateManyArgs>(
      args: SelectSubset<T, FriendShipUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FriendShip.
     * @param {FriendShipUpsertArgs} args - Arguments to update or create a FriendShip.
     * @example
     * // Update or create a FriendShip
     * const friendShip = await prisma.friendShip.upsert({
     *   create: {
     *     // ... data to create a FriendShip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FriendShip we want to update
     *   }
     * })
    **/
    upsert<T extends FriendShipUpsertArgs>(
      args: SelectSubset<T, FriendShipUpsertArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Count the number of FriendShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipCountArgs} args - Arguments to filter FriendShips to count.
     * @example
     * // Count the number of FriendShips
     * const count = await prisma.friendShip.count({
     *   where: {
     *     // ... the filter for the FriendShips we want to count
     *   }
     * })
    **/
    count<T extends FriendShipCountArgs>(
      args?: Subset<T, FriendShipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendShipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FriendShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendShipAggregateArgs>(args: Subset<T, FriendShipAggregateArgs>): Prisma.PrismaPromise<GetFriendShipAggregateType<T>>

    /**
     * Group by FriendShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendShipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendShipGroupByArgs['orderBy'] }
        : { orderBy?: FriendShipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendShipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendShipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FriendShip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FriendShipClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    requestingUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    requestedUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FriendShip base type for findUnique actions
   */
  export type FriendShipFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    /**
     * Filter, which FriendShip to fetch.
     */
    where: FriendShipWhereUniqueInput
  }

  /**
   * FriendShip findUnique
   */
  export interface FriendShipFindUniqueArgs extends FriendShipFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FriendShip findUniqueOrThrow
   */
  export type FriendShipFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    /**
     * Filter, which FriendShip to fetch.
     */
    where: FriendShipWhereUniqueInput
  }


  /**
   * FriendShip base type for findFirst actions
   */
  export type FriendShipFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    /**
     * Filter, which FriendShip to fetch.
     */
    where?: FriendShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendShips to fetch.
     */
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendShips.
     */
    cursor?: FriendShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendShips.
     */
    distinct?: Enumerable<FriendShipScalarFieldEnum>
  }

  /**
   * FriendShip findFirst
   */
  export interface FriendShipFindFirstArgs extends FriendShipFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FriendShip findFirstOrThrow
   */
  export type FriendShipFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    /**
     * Filter, which FriendShip to fetch.
     */
    where?: FriendShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendShips to fetch.
     */
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendShips.
     */
    cursor?: FriendShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendShips.
     */
    distinct?: Enumerable<FriendShipScalarFieldEnum>
  }


  /**
   * FriendShip findMany
   */
  export type FriendShipFindManyArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    /**
     * Filter, which FriendShips to fetch.
     */
    where?: FriendShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendShips to fetch.
     */
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FriendShips.
     */
    cursor?: FriendShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendShips.
     */
    skip?: number
    distinct?: Enumerable<FriendShipScalarFieldEnum>
  }


  /**
   * FriendShip create
   */
  export type FriendShipCreateArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    /**
     * The data needed to create a FriendShip.
     */
    data: XOR<FriendShipCreateInput, FriendShipUncheckedCreateInput>
  }


  /**
   * FriendShip createMany
   */
  export type FriendShipCreateManyArgs = {
    /**
     * The data used to create many FriendShips.
     */
    data: Enumerable<FriendShipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FriendShip update
   */
  export type FriendShipUpdateArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    /**
     * The data needed to update a FriendShip.
     */
    data: XOR<FriendShipUpdateInput, FriendShipUncheckedUpdateInput>
    /**
     * Choose, which FriendShip to update.
     */
    where: FriendShipWhereUniqueInput
  }


  /**
   * FriendShip updateMany
   */
  export type FriendShipUpdateManyArgs = {
    /**
     * The data used to update FriendShips.
     */
    data: XOR<FriendShipUpdateManyMutationInput, FriendShipUncheckedUpdateManyInput>
    /**
     * Filter which FriendShips to update
     */
    where?: FriendShipWhereInput
  }


  /**
   * FriendShip upsert
   */
  export type FriendShipUpsertArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    /**
     * The filter to search for the FriendShip to update in case it exists.
     */
    where: FriendShipWhereUniqueInput
    /**
     * In case the FriendShip found by the `where` argument doesn't exist, create a new FriendShip with this data.
     */
    create: XOR<FriendShipCreateInput, FriendShipUncheckedCreateInput>
    /**
     * In case the FriendShip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendShipUpdateInput, FriendShipUncheckedUpdateInput>
  }


  /**
   * FriendShip delete
   */
  export type FriendShipDeleteArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    /**
     * Filter which FriendShip to delete.
     */
    where: FriendShipWhereUniqueInput
  }


  /**
   * FriendShip deleteMany
   */
  export type FriendShipDeleteManyArgs = {
    /**
     * Filter which FriendShips to delete
     */
    where?: FriendShipWhereInput
  }


  /**
   * FriendShip without action
   */
  export type FriendShipArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
  }



  /**
   * Model BlockedShip
   */


  export type AggregateBlockedShip = {
    _count: BlockedShipCountAggregateOutputType | null
    _min: BlockedShipMinAggregateOutputType | null
    _max: BlockedShipMaxAggregateOutputType | null
  }

  export type BlockedShipMinAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    blockingUserName: string | null
    blockedUserName: string | null
  }

  export type BlockedShipMaxAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    blockingUserName: string | null
    blockedUserName: string | null
  }

  export type BlockedShipCountAggregateOutputType = {
    id: number
    creationDate: number
    modificationDate: number
    blockingUserName: number
    blockedUserName: number
    _all: number
  }


  export type BlockedShipMinAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    blockingUserName?: true
    blockedUserName?: true
  }

  export type BlockedShipMaxAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    blockingUserName?: true
    blockedUserName?: true
  }

  export type BlockedShipCountAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    blockingUserName?: true
    blockedUserName?: true
    _all?: true
  }

  export type BlockedShipAggregateArgs = {
    /**
     * Filter which BlockedShip to aggregate.
     */
    where?: BlockedShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedShips to fetch.
     */
    orderBy?: Enumerable<BlockedShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedShips
    **/
    _count?: true | BlockedShipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedShipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedShipMaxAggregateInputType
  }

  export type GetBlockedShipAggregateType<T extends BlockedShipAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedShip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedShip[P]>
      : GetScalarType<T[P], AggregateBlockedShip[P]>
  }




  export type BlockedShipGroupByArgs = {
    where?: BlockedShipWhereInput
    orderBy?: Enumerable<BlockedShipOrderByWithAggregationInput>
    by: BlockedShipScalarFieldEnum[]
    having?: BlockedShipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedShipCountAggregateInputType | true
    _min?: BlockedShipMinAggregateInputType
    _max?: BlockedShipMaxAggregateInputType
  }


  export type BlockedShipGroupByOutputType = {
    id: string
    creationDate: Date
    modificationDate: Date | null
    blockingUserName: string
    blockedUserName: string
    _count: BlockedShipCountAggregateOutputType | null
    _min: BlockedShipMinAggregateOutputType | null
    _max: BlockedShipMaxAggregateOutputType | null
  }

  type GetBlockedShipGroupByPayload<T extends BlockedShipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BlockedShipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedShipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedShipGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedShipGroupByOutputType[P]>
        }
      >
    >


  export type BlockedShipSelect = {
    id?: boolean
    creationDate?: boolean
    modificationDate?: boolean
    blockingUserName?: boolean
    blockedUserName?: boolean
    blockingUser?: boolean | UserArgs
    blockedUser?: boolean | UserArgs
  }


  export type BlockedShipInclude = {
    blockingUser?: boolean | UserArgs
    blockedUser?: boolean | UserArgs
  }

  export type BlockedShipGetPayload<S extends boolean | null | undefined | BlockedShipArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BlockedShip :
    S extends undefined ? never :
    S extends { include: any } & (BlockedShipArgs | BlockedShipFindManyArgs)
    ? BlockedShip  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'blockingUser' ? UserGetPayload<S['include'][P]> :
        P extends 'blockedUser' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BlockedShipArgs | BlockedShipFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'blockingUser' ? UserGetPayload<S['select'][P]> :
        P extends 'blockedUser' ? UserGetPayload<S['select'][P]> :  P extends keyof BlockedShip ? BlockedShip[P] : never
  } 
      : BlockedShip


  type BlockedShipCountArgs = 
    Omit<BlockedShipFindManyArgs, 'select' | 'include'> & {
      select?: BlockedShipCountAggregateInputType | true
    }

  export interface BlockedShipDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BlockedShip that matches the filter.
     * @param {BlockedShipFindUniqueArgs} args - Arguments to find a BlockedShip
     * @example
     * // Get one BlockedShip
     * const blockedShip = await prisma.blockedShip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlockedShipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BlockedShipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BlockedShip'> extends True ? Prisma__BlockedShipClient<BlockedShipGetPayload<T>> : Prisma__BlockedShipClient<BlockedShipGetPayload<T> | null, null>

    /**
     * Find one BlockedShip that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlockedShipFindUniqueOrThrowArgs} args - Arguments to find a BlockedShip
     * @example
     * // Get one BlockedShip
     * const blockedShip = await prisma.blockedShip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlockedShipFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BlockedShipFindUniqueOrThrowArgs>
    ): Prisma__BlockedShipClient<BlockedShipGetPayload<T>>

    /**
     * Find the first BlockedShip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedShipFindFirstArgs} args - Arguments to find a BlockedShip
     * @example
     * // Get one BlockedShip
     * const blockedShip = await prisma.blockedShip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlockedShipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BlockedShipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BlockedShip'> extends True ? Prisma__BlockedShipClient<BlockedShipGetPayload<T>> : Prisma__BlockedShipClient<BlockedShipGetPayload<T> | null, null>

    /**
     * Find the first BlockedShip that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedShipFindFirstOrThrowArgs} args - Arguments to find a BlockedShip
     * @example
     * // Get one BlockedShip
     * const blockedShip = await prisma.blockedShip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlockedShipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BlockedShipFindFirstOrThrowArgs>
    ): Prisma__BlockedShipClient<BlockedShipGetPayload<T>>

    /**
     * Find zero or more BlockedShips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedShipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedShips
     * const blockedShips = await prisma.blockedShip.findMany()
     * 
     * // Get first 10 BlockedShips
     * const blockedShips = await prisma.blockedShip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockedShipWithIdOnly = await prisma.blockedShip.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlockedShipFindManyArgs>(
      args?: SelectSubset<T, BlockedShipFindManyArgs>
    ): Prisma.PrismaPromise<Array<BlockedShipGetPayload<T>>>

    /**
     * Create a BlockedShip.
     * @param {BlockedShipCreateArgs} args - Arguments to create a BlockedShip.
     * @example
     * // Create one BlockedShip
     * const BlockedShip = await prisma.blockedShip.create({
     *   data: {
     *     // ... data to create a BlockedShip
     *   }
     * })
     * 
    **/
    create<T extends BlockedShipCreateArgs>(
      args: SelectSubset<T, BlockedShipCreateArgs>
    ): Prisma__BlockedShipClient<BlockedShipGetPayload<T>>

    /**
     * Create many BlockedShips.
     *     @param {BlockedShipCreateManyArgs} args - Arguments to create many BlockedShips.
     *     @example
     *     // Create many BlockedShips
     *     const blockedShip = await prisma.blockedShip.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlockedShipCreateManyArgs>(
      args?: SelectSubset<T, BlockedShipCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlockedShip.
     * @param {BlockedShipDeleteArgs} args - Arguments to delete one BlockedShip.
     * @example
     * // Delete one BlockedShip
     * const BlockedShip = await prisma.blockedShip.delete({
     *   where: {
     *     // ... filter to delete one BlockedShip
     *   }
     * })
     * 
    **/
    delete<T extends BlockedShipDeleteArgs>(
      args: SelectSubset<T, BlockedShipDeleteArgs>
    ): Prisma__BlockedShipClient<BlockedShipGetPayload<T>>

    /**
     * Update one BlockedShip.
     * @param {BlockedShipUpdateArgs} args - Arguments to update one BlockedShip.
     * @example
     * // Update one BlockedShip
     * const blockedShip = await prisma.blockedShip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlockedShipUpdateArgs>(
      args: SelectSubset<T, BlockedShipUpdateArgs>
    ): Prisma__BlockedShipClient<BlockedShipGetPayload<T>>

    /**
     * Delete zero or more BlockedShips.
     * @param {BlockedShipDeleteManyArgs} args - Arguments to filter BlockedShips to delete.
     * @example
     * // Delete a few BlockedShips
     * const { count } = await prisma.blockedShip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlockedShipDeleteManyArgs>(
      args?: SelectSubset<T, BlockedShipDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedShipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedShips
     * const blockedShip = await prisma.blockedShip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlockedShipUpdateManyArgs>(
      args: SelectSubset<T, BlockedShipUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockedShip.
     * @param {BlockedShipUpsertArgs} args - Arguments to update or create a BlockedShip.
     * @example
     * // Update or create a BlockedShip
     * const blockedShip = await prisma.blockedShip.upsert({
     *   create: {
     *     // ... data to create a BlockedShip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedShip we want to update
     *   }
     * })
    **/
    upsert<T extends BlockedShipUpsertArgs>(
      args: SelectSubset<T, BlockedShipUpsertArgs>
    ): Prisma__BlockedShipClient<BlockedShipGetPayload<T>>

    /**
     * Count the number of BlockedShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedShipCountArgs} args - Arguments to filter BlockedShips to count.
     * @example
     * // Count the number of BlockedShips
     * const count = await prisma.blockedShip.count({
     *   where: {
     *     // ... the filter for the BlockedShips we want to count
     *   }
     * })
    **/
    count<T extends BlockedShipCountArgs>(
      args?: Subset<T, BlockedShipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedShipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedShipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedShipAggregateArgs>(args: Subset<T, BlockedShipAggregateArgs>): Prisma.PrismaPromise<GetBlockedShipAggregateType<T>>

    /**
     * Group by BlockedShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedShipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedShipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedShipGroupByArgs['orderBy'] }
        : { orderBy?: BlockedShipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedShipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedShipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedShip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BlockedShipClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    blockingUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    blockedUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BlockedShip base type for findUnique actions
   */
  export type BlockedShipFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    /**
     * Filter, which BlockedShip to fetch.
     */
    where: BlockedShipWhereUniqueInput
  }

  /**
   * BlockedShip findUnique
   */
  export interface BlockedShipFindUniqueArgs extends BlockedShipFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BlockedShip findUniqueOrThrow
   */
  export type BlockedShipFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    /**
     * Filter, which BlockedShip to fetch.
     */
    where: BlockedShipWhereUniqueInput
  }


  /**
   * BlockedShip base type for findFirst actions
   */
  export type BlockedShipFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    /**
     * Filter, which BlockedShip to fetch.
     */
    where?: BlockedShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedShips to fetch.
     */
    orderBy?: Enumerable<BlockedShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedShips.
     */
    cursor?: BlockedShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedShips.
     */
    distinct?: Enumerable<BlockedShipScalarFieldEnum>
  }

  /**
   * BlockedShip findFirst
   */
  export interface BlockedShipFindFirstArgs extends BlockedShipFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BlockedShip findFirstOrThrow
   */
  export type BlockedShipFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    /**
     * Filter, which BlockedShip to fetch.
     */
    where?: BlockedShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedShips to fetch.
     */
    orderBy?: Enumerable<BlockedShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedShips.
     */
    cursor?: BlockedShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedShips.
     */
    distinct?: Enumerable<BlockedShipScalarFieldEnum>
  }


  /**
   * BlockedShip findMany
   */
  export type BlockedShipFindManyArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    /**
     * Filter, which BlockedShips to fetch.
     */
    where?: BlockedShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedShips to fetch.
     */
    orderBy?: Enumerable<BlockedShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedShips.
     */
    cursor?: BlockedShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedShips.
     */
    skip?: number
    distinct?: Enumerable<BlockedShipScalarFieldEnum>
  }


  /**
   * BlockedShip create
   */
  export type BlockedShipCreateArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    /**
     * The data needed to create a BlockedShip.
     */
    data: XOR<BlockedShipCreateInput, BlockedShipUncheckedCreateInput>
  }


  /**
   * BlockedShip createMany
   */
  export type BlockedShipCreateManyArgs = {
    /**
     * The data used to create many BlockedShips.
     */
    data: Enumerable<BlockedShipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BlockedShip update
   */
  export type BlockedShipUpdateArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    /**
     * The data needed to update a BlockedShip.
     */
    data: XOR<BlockedShipUpdateInput, BlockedShipUncheckedUpdateInput>
    /**
     * Choose, which BlockedShip to update.
     */
    where: BlockedShipWhereUniqueInput
  }


  /**
   * BlockedShip updateMany
   */
  export type BlockedShipUpdateManyArgs = {
    /**
     * The data used to update BlockedShips.
     */
    data: XOR<BlockedShipUpdateManyMutationInput, BlockedShipUncheckedUpdateManyInput>
    /**
     * Filter which BlockedShips to update
     */
    where?: BlockedShipWhereInput
  }


  /**
   * BlockedShip upsert
   */
  export type BlockedShipUpsertArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    /**
     * The filter to search for the BlockedShip to update in case it exists.
     */
    where: BlockedShipWhereUniqueInput
    /**
     * In case the BlockedShip found by the `where` argument doesn't exist, create a new BlockedShip with this data.
     */
    create: XOR<BlockedShipCreateInput, BlockedShipUncheckedCreateInput>
    /**
     * In case the BlockedShip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedShipUpdateInput, BlockedShipUncheckedUpdateInput>
  }


  /**
   * BlockedShip delete
   */
  export type BlockedShipDeleteArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    /**
     * Filter which BlockedShip to delete.
     */
    where: BlockedShipWhereUniqueInput
  }


  /**
   * BlockedShip deleteMany
   */
  export type BlockedShipDeleteManyArgs = {
    /**
     * Filter which BlockedShips to delete
     */
    where?: BlockedShipWhereInput
  }


  /**
   * BlockedShip without action
   */
  export type BlockedShipArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    name: string | null
    password: string | null
    dmPolicyLevel: dmPolicyLevelType | null
  }

  export type UserMaxAggregateOutputType = {
    name: string | null
    password: string | null
    dmPolicyLevel: dmPolicyLevelType | null
  }

  export type UserCountAggregateOutputType = {
    name: number
    password: number
    dmPolicyLevel: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    name?: true
    password?: true
    dmPolicyLevel?: true
  }

  export type UserMaxAggregateInputType = {
    name?: true
    password?: true
    dmPolicyLevel?: true
  }

  export type UserCountAggregateInputType = {
    name?: true
    password?: true
    dmPolicyLevel?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    name: string
    password: string
    dmPolicyLevel: dmPolicyLevelType
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    name?: boolean
    password?: boolean
    dmPolicyLevel?: boolean
    roles?: boolean | User$rolesArgs
    directMessage?: boolean | User$directMessageArgs
    directMessageOf?: boolean | User$directMessageOfArgs
    chans?: boolean | User$chansArgs
    ownedChans?: boolean | User$ownedChansArgs
    friend?: boolean | User$friendArgs
    friendOf?: boolean | User$friendOfArgs
    outcomingFriendInvitation?: boolean | User$outcomingFriendInvitationArgs
    incomingFriendInvitation?: boolean | User$incomingFriendInvitationArgs
    outcomingChanInvitation?: boolean | User$outcomingChanInvitationArgs
    incomingChanInvitation?: boolean | User$incomingChanInvitationArgs
    blockedUser?: boolean | User$blockedUserArgs
    blockedByUser?: boolean | User$blockedByUserArgs
    chanDiscussionElement?: boolean | User$chanDiscussionElementArgs
    chanDiscussionEvent?: boolean | User$chanDiscussionEventArgs
    deletedMessageChanDiscussionEvent?: boolean | User$deletedMessageChanDiscussionEventArgs
    chanDiscussionMessage?: boolean | User$chanDiscussionMessageArgs
    dmDiscussionElement?: boolean | User$dmDiscussionElementArgs
    dmDiscussionMessage?: boolean | User$dmDiscussionMessageArgs
    mutedUserChan?: boolean | User$mutedUserChanArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    roles?: boolean | User$rolesArgs
    directMessage?: boolean | User$directMessageArgs
    directMessageOf?: boolean | User$directMessageOfArgs
    chans?: boolean | User$chansArgs
    ownedChans?: boolean | User$ownedChansArgs
    friend?: boolean | User$friendArgs
    friendOf?: boolean | User$friendOfArgs
    outcomingFriendInvitation?: boolean | User$outcomingFriendInvitationArgs
    incomingFriendInvitation?: boolean | User$incomingFriendInvitationArgs
    outcomingChanInvitation?: boolean | User$outcomingChanInvitationArgs
    incomingChanInvitation?: boolean | User$incomingChanInvitationArgs
    blockedUser?: boolean | User$blockedUserArgs
    blockedByUser?: boolean | User$blockedByUserArgs
    chanDiscussionElement?: boolean | User$chanDiscussionElementArgs
    chanDiscussionEvent?: boolean | User$chanDiscussionEventArgs
    deletedMessageChanDiscussionEvent?: boolean | User$deletedMessageChanDiscussionEventArgs
    chanDiscussionMessage?: boolean | User$chanDiscussionMessageArgs
    dmDiscussionElement?: boolean | User$dmDiscussionElementArgs
    dmDiscussionMessage?: boolean | User$dmDiscussionMessageArgs
    mutedUserChan?: boolean | User$mutedUserChanArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'roles' ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'directMessage' ? Array < DirectMessageGetPayload<S['include'][P]>>  :
        P extends 'directMessageOf' ? Array < DirectMessageGetPayload<S['include'][P]>>  :
        P extends 'chans' ? Array < ChanGetPayload<S['include'][P]>>  :
        P extends 'ownedChans' ? Array < ChanGetPayload<S['include'][P]>>  :
        P extends 'friend' ? Array < FriendShipGetPayload<S['include'][P]>>  :
        P extends 'friendOf' ? Array < FriendShipGetPayload<S['include'][P]>>  :
        P extends 'outcomingFriendInvitation' ? Array < FriendInvitationGetPayload<S['include'][P]>>  :
        P extends 'incomingFriendInvitation' ? Array < FriendInvitationGetPayload<S['include'][P]>>  :
        P extends 'outcomingChanInvitation' ? Array < ChanInvitationGetPayload<S['include'][P]>>  :
        P extends 'incomingChanInvitation' ? Array < ChanInvitationGetPayload<S['include'][P]>>  :
        P extends 'blockedUser' ? Array < BlockedShipGetPayload<S['include'][P]>>  :
        P extends 'blockedByUser' ? Array < BlockedShipGetPayload<S['include'][P]>>  :
        P extends 'chanDiscussionElement' ? Array < ChanDiscussionElementGetPayload<S['include'][P]>>  :
        P extends 'chanDiscussionEvent' ? Array < ChanDiscussionEventGetPayload<S['include'][P]>>  :
        P extends 'deletedMessageChanDiscussionEvent' ? Array < DeletedMessageChanDiscussionEventGetPayload<S['include'][P]>>  :
        P extends 'chanDiscussionMessage' ? Array < ChanDiscussionMessageGetPayload<S['include'][P]>>  :
        P extends 'dmDiscussionElement' ? Array < DmDiscussionElementGetPayload<S['include'][P]>>  :
        P extends 'dmDiscussionMessage' ? Array < DmDiscussionMessageGetPayload<S['include'][P]>>  :
        P extends 'mutedUserChan' ? Array < MutedUserChanGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'roles' ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'directMessage' ? Array < DirectMessageGetPayload<S['select'][P]>>  :
        P extends 'directMessageOf' ? Array < DirectMessageGetPayload<S['select'][P]>>  :
        P extends 'chans' ? Array < ChanGetPayload<S['select'][P]>>  :
        P extends 'ownedChans' ? Array < ChanGetPayload<S['select'][P]>>  :
        P extends 'friend' ? Array < FriendShipGetPayload<S['select'][P]>>  :
        P extends 'friendOf' ? Array < FriendShipGetPayload<S['select'][P]>>  :
        P extends 'outcomingFriendInvitation' ? Array < FriendInvitationGetPayload<S['select'][P]>>  :
        P extends 'incomingFriendInvitation' ? Array < FriendInvitationGetPayload<S['select'][P]>>  :
        P extends 'outcomingChanInvitation' ? Array < ChanInvitationGetPayload<S['select'][P]>>  :
        P extends 'incomingChanInvitation' ? Array < ChanInvitationGetPayload<S['select'][P]>>  :
        P extends 'blockedUser' ? Array < BlockedShipGetPayload<S['select'][P]>>  :
        P extends 'blockedByUser' ? Array < BlockedShipGetPayload<S['select'][P]>>  :
        P extends 'chanDiscussionElement' ? Array < ChanDiscussionElementGetPayload<S['select'][P]>>  :
        P extends 'chanDiscussionEvent' ? Array < ChanDiscussionEventGetPayload<S['select'][P]>>  :
        P extends 'deletedMessageChanDiscussionEvent' ? Array < DeletedMessageChanDiscussionEventGetPayload<S['select'][P]>>  :
        P extends 'chanDiscussionMessage' ? Array < ChanDiscussionMessageGetPayload<S['select'][P]>>  :
        P extends 'dmDiscussionElement' ? Array < DmDiscussionElementGetPayload<S['select'][P]>>  :
        P extends 'dmDiscussionMessage' ? Array < DmDiscussionMessageGetPayload<S['select'][P]>>  :
        P extends 'mutedUserChan' ? Array < MutedUserChanGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const userWithNameOnly = await prisma.user.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    roles<T extends User$rolesArgs= {}>(args?: Subset<T, User$rolesArgs>): Prisma.PrismaPromise<Array<RoleGetPayload<T>>| Null>;

    directMessage<T extends User$directMessageArgs= {}>(args?: Subset<T, User$directMessageArgs>): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>| Null>;

    directMessageOf<T extends User$directMessageOfArgs= {}>(args?: Subset<T, User$directMessageOfArgs>): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>| Null>;

    chans<T extends User$chansArgs= {}>(args?: Subset<T, User$chansArgs>): Prisma.PrismaPromise<Array<ChanGetPayload<T>>| Null>;

    ownedChans<T extends User$ownedChansArgs= {}>(args?: Subset<T, User$ownedChansArgs>): Prisma.PrismaPromise<Array<ChanGetPayload<T>>| Null>;

    friend<T extends User$friendArgs= {}>(args?: Subset<T, User$friendArgs>): Prisma.PrismaPromise<Array<FriendShipGetPayload<T>>| Null>;

    friendOf<T extends User$friendOfArgs= {}>(args?: Subset<T, User$friendOfArgs>): Prisma.PrismaPromise<Array<FriendShipGetPayload<T>>| Null>;

    outcomingFriendInvitation<T extends User$outcomingFriendInvitationArgs= {}>(args?: Subset<T, User$outcomingFriendInvitationArgs>): Prisma.PrismaPromise<Array<FriendInvitationGetPayload<T>>| Null>;

    incomingFriendInvitation<T extends User$incomingFriendInvitationArgs= {}>(args?: Subset<T, User$incomingFriendInvitationArgs>): Prisma.PrismaPromise<Array<FriendInvitationGetPayload<T>>| Null>;

    outcomingChanInvitation<T extends User$outcomingChanInvitationArgs= {}>(args?: Subset<T, User$outcomingChanInvitationArgs>): Prisma.PrismaPromise<Array<ChanInvitationGetPayload<T>>| Null>;

    incomingChanInvitation<T extends User$incomingChanInvitationArgs= {}>(args?: Subset<T, User$incomingChanInvitationArgs>): Prisma.PrismaPromise<Array<ChanInvitationGetPayload<T>>| Null>;

    blockedUser<T extends User$blockedUserArgs= {}>(args?: Subset<T, User$blockedUserArgs>): Prisma.PrismaPromise<Array<BlockedShipGetPayload<T>>| Null>;

    blockedByUser<T extends User$blockedByUserArgs= {}>(args?: Subset<T, User$blockedByUserArgs>): Prisma.PrismaPromise<Array<BlockedShipGetPayload<T>>| Null>;

    chanDiscussionElement<T extends User$chanDiscussionElementArgs= {}>(args?: Subset<T, User$chanDiscussionElementArgs>): Prisma.PrismaPromise<Array<ChanDiscussionElementGetPayload<T>>| Null>;

    chanDiscussionEvent<T extends User$chanDiscussionEventArgs= {}>(args?: Subset<T, User$chanDiscussionEventArgs>): Prisma.PrismaPromise<Array<ChanDiscussionEventGetPayload<T>>| Null>;

    deletedMessageChanDiscussionEvent<T extends User$deletedMessageChanDiscussionEventArgs= {}>(args?: Subset<T, User$deletedMessageChanDiscussionEventArgs>): Prisma.PrismaPromise<Array<DeletedMessageChanDiscussionEventGetPayload<T>>| Null>;

    chanDiscussionMessage<T extends User$chanDiscussionMessageArgs= {}>(args?: Subset<T, User$chanDiscussionMessageArgs>): Prisma.PrismaPromise<Array<ChanDiscussionMessageGetPayload<T>>| Null>;

    dmDiscussionElement<T extends User$dmDiscussionElementArgs= {}>(args?: Subset<T, User$dmDiscussionElementArgs>): Prisma.PrismaPromise<Array<DmDiscussionElementGetPayload<T>>| Null>;

    dmDiscussionMessage<T extends User$dmDiscussionMessageArgs= {}>(args?: Subset<T, User$dmDiscussionMessageArgs>): Prisma.PrismaPromise<Array<DmDiscussionMessageGetPayload<T>>| Null>;

    mutedUserChan<T extends User$mutedUserChanArgs= {}>(args?: Subset<T, User$mutedUserChanArgs>): Prisma.PrismaPromise<Array<MutedUserChanGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.roles
   */
  export type User$rolesArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * User.directMessage
   */
  export type User$directMessageArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * User.directMessageOf
   */
  export type User$directMessageOfArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * User.chans
   */
  export type User$chansArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    where?: ChanWhereInput
    orderBy?: Enumerable<ChanOrderByWithRelationInput>
    cursor?: ChanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanScalarFieldEnum>
  }


  /**
   * User.ownedChans
   */
  export type User$ownedChansArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    where?: ChanWhereInput
    orderBy?: Enumerable<ChanOrderByWithRelationInput>
    cursor?: ChanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanScalarFieldEnum>
  }


  /**
   * User.friend
   */
  export type User$friendArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    where?: FriendShipWhereInput
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    cursor?: FriendShipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FriendShipScalarFieldEnum>
  }


  /**
   * User.friendOf
   */
  export type User$friendOfArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendShipInclude | null
    where?: FriendShipWhereInput
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    cursor?: FriendShipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FriendShipScalarFieldEnum>
  }


  /**
   * User.outcomingFriendInvitation
   */
  export type User$outcomingFriendInvitationArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    where?: FriendInvitationWhereInput
    orderBy?: Enumerable<FriendInvitationOrderByWithRelationInput>
    cursor?: FriendInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FriendInvitationScalarFieldEnum>
  }


  /**
   * User.incomingFriendInvitation
   */
  export type User$incomingFriendInvitationArgs = {
    /**
     * Select specific fields to fetch from the FriendInvitation
     */
    select?: FriendInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendInvitationInclude | null
    where?: FriendInvitationWhereInput
    orderBy?: Enumerable<FriendInvitationOrderByWithRelationInput>
    cursor?: FriendInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FriendInvitationScalarFieldEnum>
  }


  /**
   * User.outcomingChanInvitation
   */
  export type User$outcomingChanInvitationArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    where?: ChanInvitationWhereInput
    orderBy?: Enumerable<ChanInvitationOrderByWithRelationInput>
    cursor?: ChanInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanInvitationScalarFieldEnum>
  }


  /**
   * User.incomingChanInvitation
   */
  export type User$incomingChanInvitationArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    where?: ChanInvitationWhereInput
    orderBy?: Enumerable<ChanInvitationOrderByWithRelationInput>
    cursor?: ChanInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanInvitationScalarFieldEnum>
  }


  /**
   * User.blockedUser
   */
  export type User$blockedUserArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    where?: BlockedShipWhereInput
    orderBy?: Enumerable<BlockedShipOrderByWithRelationInput>
    cursor?: BlockedShipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BlockedShipScalarFieldEnum>
  }


  /**
   * User.blockedByUser
   */
  export type User$blockedByUserArgs = {
    /**
     * Select specific fields to fetch from the BlockedShip
     */
    select?: BlockedShipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockedShipInclude | null
    where?: BlockedShipWhereInput
    orderBy?: Enumerable<BlockedShipOrderByWithRelationInput>
    cursor?: BlockedShipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BlockedShipScalarFieldEnum>
  }


  /**
   * User.chanDiscussionElement
   */
  export type User$chanDiscussionElementArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    where?: ChanDiscussionElementWhereInput
    orderBy?: Enumerable<ChanDiscussionElementOrderByWithRelationInput>
    cursor?: ChanDiscussionElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanDiscussionElementScalarFieldEnum>
  }


  /**
   * User.chanDiscussionEvent
   */
  export type User$chanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    where?: ChanDiscussionEventWhereInput
    orderBy?: Enumerable<ChanDiscussionEventOrderByWithRelationInput>
    cursor?: ChanDiscussionEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanDiscussionEventScalarFieldEnum>
  }


  /**
   * User.deletedMessageChanDiscussionEvent
   */
  export type User$deletedMessageChanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    where?: DeletedMessageChanDiscussionEventWhereInput
    orderBy?: Enumerable<DeletedMessageChanDiscussionEventOrderByWithRelationInput>
    cursor?: DeletedMessageChanDiscussionEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DeletedMessageChanDiscussionEventScalarFieldEnum>
  }


  /**
   * User.chanDiscussionMessage
   */
  export type User$chanDiscussionMessageArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    where?: ChanDiscussionMessageWhereInput
    orderBy?: Enumerable<ChanDiscussionMessageOrderByWithRelationInput>
    cursor?: ChanDiscussionMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanDiscussionMessageScalarFieldEnum>
  }


  /**
   * User.dmDiscussionElement
   */
  export type User$dmDiscussionElementArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    where?: DmDiscussionElementWhereInput
    orderBy?: Enumerable<DmDiscussionElementOrderByWithRelationInput>
    cursor?: DmDiscussionElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DmDiscussionElementScalarFieldEnum>
  }


  /**
   * User.dmDiscussionMessage
   */
  export type User$dmDiscussionMessageArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    where?: DmDiscussionMessageWhereInput
    orderBy?: Enumerable<DmDiscussionMessageOrderByWithRelationInput>
    cursor?: DmDiscussionMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DmDiscussionMessageScalarFieldEnum>
  }


  /**
   * User.mutedUserChan
   */
  export type User$mutedUserChanArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    where?: MutedUserChanWhereInput
    orderBy?: Enumerable<MutedUserChanOrderByWithRelationInput>
    cursor?: MutedUserChanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MutedUserChanScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model DirectMessage
   */


  export type AggregateDirectMessage = {
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  export type DirectMessageMinAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    requestingUserName: string | null
    requestingUserStatus: DirectMessageUserStatus | null
    requestingUserStatusMutedUntil: Date | null
    requestedUserName: string | null
    requestedUserStatus: DirectMessageUserStatus | null
    requestedUserStatusMutedUntil: Date | null
    status: DirectMessageStatus | null
  }

  export type DirectMessageMaxAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    modificationDate: Date | null
    requestingUserName: string | null
    requestingUserStatus: DirectMessageUserStatus | null
    requestingUserStatusMutedUntil: Date | null
    requestedUserName: string | null
    requestedUserStatus: DirectMessageUserStatus | null
    requestedUserStatusMutedUntil: Date | null
    status: DirectMessageStatus | null
  }

  export type DirectMessageCountAggregateOutputType = {
    id: number
    creationDate: number
    modificationDate: number
    requestingUserName: number
    requestingUserStatus: number
    requestingUserStatusMutedUntil: number
    requestedUserName: number
    requestedUserStatus: number
    requestedUserStatusMutedUntil: number
    status: number
    _all: number
  }


  export type DirectMessageMinAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    requestingUserName?: true
    requestingUserStatus?: true
    requestingUserStatusMutedUntil?: true
    requestedUserName?: true
    requestedUserStatus?: true
    requestedUserStatusMutedUntil?: true
    status?: true
  }

  export type DirectMessageMaxAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    requestingUserName?: true
    requestingUserStatus?: true
    requestingUserStatusMutedUntil?: true
    requestedUserName?: true
    requestedUserStatus?: true
    requestedUserStatusMutedUntil?: true
    status?: true
  }

  export type DirectMessageCountAggregateInputType = {
    id?: true
    creationDate?: true
    modificationDate?: true
    requestingUserName?: true
    requestingUserStatus?: true
    requestingUserStatusMutedUntil?: true
    requestedUserName?: true
    requestedUserStatus?: true
    requestedUserStatusMutedUntil?: true
    status?: true
    _all?: true
  }

  export type DirectMessageAggregateArgs = {
    /**
     * Filter which DirectMessage to aggregate.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectMessages
    **/
    _count?: true | DirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectMessageMaxAggregateInputType
  }

  export type GetDirectMessageAggregateType<T extends DirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectMessage[P]>
      : GetScalarType<T[P], AggregateDirectMessage[P]>
  }




  export type DirectMessageGroupByArgs = {
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithAggregationInput>
    by: DirectMessageScalarFieldEnum[]
    having?: DirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectMessageCountAggregateInputType | true
    _min?: DirectMessageMinAggregateInputType
    _max?: DirectMessageMaxAggregateInputType
  }


  export type DirectMessageGroupByOutputType = {
    id: string
    creationDate: Date
    modificationDate: Date | null
    requestingUserName: string
    requestingUserStatus: DirectMessageUserStatus
    requestingUserStatusMutedUntil: Date | null
    requestedUserName: string
    requestedUserStatus: DirectMessageUserStatus
    requestedUserStatusMutedUntil: Date | null
    status: DirectMessageStatus
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  type GetDirectMessageGroupByPayload<T extends DirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type DirectMessageSelect = {
    id?: boolean
    creationDate?: boolean
    modificationDate?: boolean
    requestingUserName?: boolean
    requestingUserStatus?: boolean
    requestingUserStatusMutedUntil?: boolean
    requestedUserName?: boolean
    requestedUserStatus?: boolean
    requestedUserStatusMutedUntil?: boolean
    status?: boolean
    requestingUser?: boolean | UserArgs
    requestedUser?: boolean | UserArgs
    elements?: boolean | DirectMessage$elementsArgs
    _count?: boolean | DirectMessageCountOutputTypeArgs
  }


  export type DirectMessageInclude = {
    requestingUser?: boolean | UserArgs
    requestedUser?: boolean | UserArgs
    elements?: boolean | DirectMessage$elementsArgs
    _count?: boolean | DirectMessageCountOutputTypeArgs
  }

  export type DirectMessageGetPayload<S extends boolean | null | undefined | DirectMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DirectMessage :
    S extends undefined ? never :
    S extends { include: any } & (DirectMessageArgs | DirectMessageFindManyArgs)
    ? DirectMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'requestingUser' ? UserGetPayload<S['include'][P]> :
        P extends 'requestedUser' ? UserGetPayload<S['include'][P]> :
        P extends 'elements' ? Array < DmDiscussionElementGetPayload<S['include'][P]>>  :
        P extends '_count' ? DirectMessageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DirectMessageArgs | DirectMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'requestingUser' ? UserGetPayload<S['select'][P]> :
        P extends 'requestedUser' ? UserGetPayload<S['select'][P]> :
        P extends 'elements' ? Array < DmDiscussionElementGetPayload<S['select'][P]>>  :
        P extends '_count' ? DirectMessageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DirectMessage ? DirectMessage[P] : never
  } 
      : DirectMessage


  type DirectMessageCountArgs = 
    Omit<DirectMessageFindManyArgs, 'select' | 'include'> & {
      select?: DirectMessageCountAggregateInputType | true
    }

  export interface DirectMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DirectMessage that matches the filter.
     * @param {DirectMessageFindUniqueArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DirectMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DirectMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DirectMessage'> extends True ? Prisma__DirectMessageClient<DirectMessageGetPayload<T>> : Prisma__DirectMessageClient<DirectMessageGetPayload<T> | null, null>

    /**
     * Find one DirectMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DirectMessageFindUniqueOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DirectMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DirectMessageFindUniqueOrThrowArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Find the first DirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DirectMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DirectMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DirectMessage'> extends True ? Prisma__DirectMessageClient<DirectMessageGetPayload<T>> : Prisma__DirectMessageClient<DirectMessageGetPayload<T> | null, null>

    /**
     * Find the first DirectMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DirectMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DirectMessageFindFirstOrThrowArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Find zero or more DirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectMessages
     * const directMessages = await prisma.directMessage.findMany()
     * 
     * // Get first 10 DirectMessages
     * const directMessages = await prisma.directMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DirectMessageFindManyArgs>(
      args?: SelectSubset<T, DirectMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>>

    /**
     * Create a DirectMessage.
     * @param {DirectMessageCreateArgs} args - Arguments to create a DirectMessage.
     * @example
     * // Create one DirectMessage
     * const DirectMessage = await prisma.directMessage.create({
     *   data: {
     *     // ... data to create a DirectMessage
     *   }
     * })
     * 
    **/
    create<T extends DirectMessageCreateArgs>(
      args: SelectSubset<T, DirectMessageCreateArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Create many DirectMessages.
     *     @param {DirectMessageCreateManyArgs} args - Arguments to create many DirectMessages.
     *     @example
     *     // Create many DirectMessages
     *     const directMessage = await prisma.directMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DirectMessageCreateManyArgs>(
      args?: SelectSubset<T, DirectMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DirectMessage.
     * @param {DirectMessageDeleteArgs} args - Arguments to delete one DirectMessage.
     * @example
     * // Delete one DirectMessage
     * const DirectMessage = await prisma.directMessage.delete({
     *   where: {
     *     // ... filter to delete one DirectMessage
     *   }
     * })
     * 
    **/
    delete<T extends DirectMessageDeleteArgs>(
      args: SelectSubset<T, DirectMessageDeleteArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Update one DirectMessage.
     * @param {DirectMessageUpdateArgs} args - Arguments to update one DirectMessage.
     * @example
     * // Update one DirectMessage
     * const directMessage = await prisma.directMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DirectMessageUpdateArgs>(
      args: SelectSubset<T, DirectMessageUpdateArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Delete zero or more DirectMessages.
     * @param {DirectMessageDeleteManyArgs} args - Arguments to filter DirectMessages to delete.
     * @example
     * // Delete a few DirectMessages
     * const { count } = await prisma.directMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DirectMessageDeleteManyArgs>(
      args?: SelectSubset<T, DirectMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DirectMessageUpdateManyArgs>(
      args: SelectSubset<T, DirectMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DirectMessage.
     * @param {DirectMessageUpsertArgs} args - Arguments to update or create a DirectMessage.
     * @example
     * // Update or create a DirectMessage
     * const directMessage = await prisma.directMessage.upsert({
     *   create: {
     *     // ... data to create a DirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectMessage we want to update
     *   }
     * })
    **/
    upsert<T extends DirectMessageUpsertArgs>(
      args: SelectSubset<T, DirectMessageUpsertArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Count the number of DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageCountArgs} args - Arguments to filter DirectMessages to count.
     * @example
     * // Count the number of DirectMessages
     * const count = await prisma.directMessage.count({
     *   where: {
     *     // ... the filter for the DirectMessages we want to count
     *   }
     * })
    **/
    count<T extends DirectMessageCountArgs>(
      args?: Subset<T, DirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectMessageAggregateArgs>(args: Subset<T, DirectMessageAggregateArgs>): Prisma.PrismaPromise<GetDirectMessageAggregateType<T>>

    /**
     * Group by DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: DirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DirectMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    requestingUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    requestedUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    elements<T extends DirectMessage$elementsArgs= {}>(args?: Subset<T, DirectMessage$elementsArgs>): Prisma.PrismaPromise<Array<DmDiscussionElementGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DirectMessage base type for findUnique actions
   */
  export type DirectMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findUnique
   */
  export interface DirectMessageFindUniqueArgs extends DirectMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DirectMessage findUniqueOrThrow
   */
  export type DirectMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage base type for findFirst actions
   */
  export type DirectMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }

  /**
   * DirectMessage findFirst
   */
  export interface DirectMessageFindFirstArgs extends DirectMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DirectMessage findFirstOrThrow
   */
  export type DirectMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * DirectMessage findMany
   */
  export type DirectMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessages to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * DirectMessage create
   */
  export type DirectMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The data needed to create a DirectMessage.
     */
    data: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
  }


  /**
   * DirectMessage createMany
   */
  export type DirectMessageCreateManyArgs = {
    /**
     * The data used to create many DirectMessages.
     */
    data: Enumerable<DirectMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DirectMessage update
   */
  export type DirectMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The data needed to update a DirectMessage.
     */
    data: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
    /**
     * Choose, which DirectMessage to update.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage updateMany
   */
  export type DirectMessageUpdateManyArgs = {
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
  }


  /**
   * DirectMessage upsert
   */
  export type DirectMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The filter to search for the DirectMessage to update in case it exists.
     */
    where: DirectMessageWhereUniqueInput
    /**
     * In case the DirectMessage found by the `where` argument doesn't exist, create a new DirectMessage with this data.
     */
    create: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
    /**
     * In case the DirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
  }


  /**
   * DirectMessage delete
   */
  export type DirectMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter which DirectMessage to delete.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage deleteMany
   */
  export type DirectMessageDeleteManyArgs = {
    /**
     * Filter which DirectMessages to delete
     */
    where?: DirectMessageWhereInput
  }


  /**
   * DirectMessage.elements
   */
  export type DirectMessage$elementsArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    where?: DmDiscussionElementWhereInput
    orderBy?: Enumerable<DmDiscussionElementOrderByWithRelationInput>
    cursor?: DmDiscussionElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DmDiscussionElementScalarFieldEnum>
  }


  /**
   * DirectMessage without action
   */
  export type DirectMessageArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
  }



  /**
   * Model DmDiscussionElement
   */


  export type AggregateDmDiscussionElement = {
    _count: DmDiscussionElementCountAggregateOutputType | null
    _min: DmDiscussionElementMinAggregateOutputType | null
    _max: DmDiscussionElementMaxAggregateOutputType | null
  }

  export type DmDiscussionElementMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    eventId: string | null
    author: string | null
    creationDate: Date | null
    modificationDate: Date | null
    directMessageId: string | null
  }

  export type DmDiscussionElementMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    eventId: string | null
    author: string | null
    creationDate: Date | null
    modificationDate: Date | null
    directMessageId: string | null
  }

  export type DmDiscussionElementCountAggregateOutputType = {
    id: number
    messageId: number
    eventId: number
    author: number
    creationDate: number
    modificationDate: number
    directMessageId: number
    _all: number
  }


  export type DmDiscussionElementMinAggregateInputType = {
    id?: true
    messageId?: true
    eventId?: true
    author?: true
    creationDate?: true
    modificationDate?: true
    directMessageId?: true
  }

  export type DmDiscussionElementMaxAggregateInputType = {
    id?: true
    messageId?: true
    eventId?: true
    author?: true
    creationDate?: true
    modificationDate?: true
    directMessageId?: true
  }

  export type DmDiscussionElementCountAggregateInputType = {
    id?: true
    messageId?: true
    eventId?: true
    author?: true
    creationDate?: true
    modificationDate?: true
    directMessageId?: true
    _all?: true
  }

  export type DmDiscussionElementAggregateArgs = {
    /**
     * Filter which DmDiscussionElement to aggregate.
     */
    where?: DmDiscussionElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionElements to fetch.
     */
    orderBy?: Enumerable<DmDiscussionElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DmDiscussionElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DmDiscussionElements
    **/
    _count?: true | DmDiscussionElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DmDiscussionElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DmDiscussionElementMaxAggregateInputType
  }

  export type GetDmDiscussionElementAggregateType<T extends DmDiscussionElementAggregateArgs> = {
        [P in keyof T & keyof AggregateDmDiscussionElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDmDiscussionElement[P]>
      : GetScalarType<T[P], AggregateDmDiscussionElement[P]>
  }




  export type DmDiscussionElementGroupByArgs = {
    where?: DmDiscussionElementWhereInput
    orderBy?: Enumerable<DmDiscussionElementOrderByWithAggregationInput>
    by: DmDiscussionElementScalarFieldEnum[]
    having?: DmDiscussionElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DmDiscussionElementCountAggregateInputType | true
    _min?: DmDiscussionElementMinAggregateInputType
    _max?: DmDiscussionElementMaxAggregateInputType
  }


  export type DmDiscussionElementGroupByOutputType = {
    id: string
    messageId: string | null
    eventId: string | null
    author: string
    creationDate: Date
    modificationDate: Date | null
    directMessageId: string
    _count: DmDiscussionElementCountAggregateOutputType | null
    _min: DmDiscussionElementMinAggregateOutputType | null
    _max: DmDiscussionElementMaxAggregateOutputType | null
  }

  type GetDmDiscussionElementGroupByPayload<T extends DmDiscussionElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DmDiscussionElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DmDiscussionElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DmDiscussionElementGroupByOutputType[P]>
            : GetScalarType<T[P], DmDiscussionElementGroupByOutputType[P]>
        }
      >
    >


  export type DmDiscussionElementSelect = {
    id?: boolean
    messageId?: boolean
    eventId?: boolean
    author?: boolean
    creationDate?: boolean
    modificationDate?: boolean
    directMessageId?: boolean
    message?: boolean | DmDiscussionElement$messageArgs
    event?: boolean | DmDiscussionElement$eventArgs
    relatedOf?: boolean | DmDiscussionElement$relatedOfArgs
    authorRelation?: boolean | UserArgs
    directMessage?: boolean | DirectMessageArgs
    _count?: boolean | DmDiscussionElementCountOutputTypeArgs
  }


  export type DmDiscussionElementInclude = {
    message?: boolean | DmDiscussionElement$messageArgs
    event?: boolean | DmDiscussionElement$eventArgs
    relatedOf?: boolean | DmDiscussionElement$relatedOfArgs
    authorRelation?: boolean | UserArgs
    directMessage?: boolean | DirectMessageArgs
    _count?: boolean | DmDiscussionElementCountOutputTypeArgs
  }

  export type DmDiscussionElementGetPayload<S extends boolean | null | undefined | DmDiscussionElementArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DmDiscussionElement :
    S extends undefined ? never :
    S extends { include: any } & (DmDiscussionElementArgs | DmDiscussionElementFindManyArgs)
    ? DmDiscussionElement  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'message' ? DmDiscussionMessageGetPayload<S['include'][P]> | null :
        P extends 'event' ? DmDiscussionEventGetPayload<S['include'][P]> | null :
        P extends 'relatedOf' ? Array < DmDiscussionMessageGetPayload<S['include'][P]>>  :
        P extends 'authorRelation' ? UserGetPayload<S['include'][P]> :
        P extends 'directMessage' ? DirectMessageGetPayload<S['include'][P]> :
        P extends '_count' ? DmDiscussionElementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DmDiscussionElementArgs | DmDiscussionElementFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'message' ? DmDiscussionMessageGetPayload<S['select'][P]> | null :
        P extends 'event' ? DmDiscussionEventGetPayload<S['select'][P]> | null :
        P extends 'relatedOf' ? Array < DmDiscussionMessageGetPayload<S['select'][P]>>  :
        P extends 'authorRelation' ? UserGetPayload<S['select'][P]> :
        P extends 'directMessage' ? DirectMessageGetPayload<S['select'][P]> :
        P extends '_count' ? DmDiscussionElementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DmDiscussionElement ? DmDiscussionElement[P] : never
  } 
      : DmDiscussionElement


  type DmDiscussionElementCountArgs = 
    Omit<DmDiscussionElementFindManyArgs, 'select' | 'include'> & {
      select?: DmDiscussionElementCountAggregateInputType | true
    }

  export interface DmDiscussionElementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DmDiscussionElement that matches the filter.
     * @param {DmDiscussionElementFindUniqueArgs} args - Arguments to find a DmDiscussionElement
     * @example
     * // Get one DmDiscussionElement
     * const dmDiscussionElement = await prisma.dmDiscussionElement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DmDiscussionElementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DmDiscussionElementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DmDiscussionElement'> extends True ? Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T>> : Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T> | null, null>

    /**
     * Find one DmDiscussionElement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DmDiscussionElementFindUniqueOrThrowArgs} args - Arguments to find a DmDiscussionElement
     * @example
     * // Get one DmDiscussionElement
     * const dmDiscussionElement = await prisma.dmDiscussionElement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DmDiscussionElementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DmDiscussionElementFindUniqueOrThrowArgs>
    ): Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T>>

    /**
     * Find the first DmDiscussionElement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionElementFindFirstArgs} args - Arguments to find a DmDiscussionElement
     * @example
     * // Get one DmDiscussionElement
     * const dmDiscussionElement = await prisma.dmDiscussionElement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DmDiscussionElementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DmDiscussionElementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DmDiscussionElement'> extends True ? Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T>> : Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T> | null, null>

    /**
     * Find the first DmDiscussionElement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionElementFindFirstOrThrowArgs} args - Arguments to find a DmDiscussionElement
     * @example
     * // Get one DmDiscussionElement
     * const dmDiscussionElement = await prisma.dmDiscussionElement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DmDiscussionElementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DmDiscussionElementFindFirstOrThrowArgs>
    ): Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T>>

    /**
     * Find zero or more DmDiscussionElements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionElementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DmDiscussionElements
     * const dmDiscussionElements = await prisma.dmDiscussionElement.findMany()
     * 
     * // Get first 10 DmDiscussionElements
     * const dmDiscussionElements = await prisma.dmDiscussionElement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dmDiscussionElementWithIdOnly = await prisma.dmDiscussionElement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DmDiscussionElementFindManyArgs>(
      args?: SelectSubset<T, DmDiscussionElementFindManyArgs>
    ): Prisma.PrismaPromise<Array<DmDiscussionElementGetPayload<T>>>

    /**
     * Create a DmDiscussionElement.
     * @param {DmDiscussionElementCreateArgs} args - Arguments to create a DmDiscussionElement.
     * @example
     * // Create one DmDiscussionElement
     * const DmDiscussionElement = await prisma.dmDiscussionElement.create({
     *   data: {
     *     // ... data to create a DmDiscussionElement
     *   }
     * })
     * 
    **/
    create<T extends DmDiscussionElementCreateArgs>(
      args: SelectSubset<T, DmDiscussionElementCreateArgs>
    ): Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T>>

    /**
     * Create many DmDiscussionElements.
     *     @param {DmDiscussionElementCreateManyArgs} args - Arguments to create many DmDiscussionElements.
     *     @example
     *     // Create many DmDiscussionElements
     *     const dmDiscussionElement = await prisma.dmDiscussionElement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DmDiscussionElementCreateManyArgs>(
      args?: SelectSubset<T, DmDiscussionElementCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DmDiscussionElement.
     * @param {DmDiscussionElementDeleteArgs} args - Arguments to delete one DmDiscussionElement.
     * @example
     * // Delete one DmDiscussionElement
     * const DmDiscussionElement = await prisma.dmDiscussionElement.delete({
     *   where: {
     *     // ... filter to delete one DmDiscussionElement
     *   }
     * })
     * 
    **/
    delete<T extends DmDiscussionElementDeleteArgs>(
      args: SelectSubset<T, DmDiscussionElementDeleteArgs>
    ): Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T>>

    /**
     * Update one DmDiscussionElement.
     * @param {DmDiscussionElementUpdateArgs} args - Arguments to update one DmDiscussionElement.
     * @example
     * // Update one DmDiscussionElement
     * const dmDiscussionElement = await prisma.dmDiscussionElement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DmDiscussionElementUpdateArgs>(
      args: SelectSubset<T, DmDiscussionElementUpdateArgs>
    ): Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T>>

    /**
     * Delete zero or more DmDiscussionElements.
     * @param {DmDiscussionElementDeleteManyArgs} args - Arguments to filter DmDiscussionElements to delete.
     * @example
     * // Delete a few DmDiscussionElements
     * const { count } = await prisma.dmDiscussionElement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DmDiscussionElementDeleteManyArgs>(
      args?: SelectSubset<T, DmDiscussionElementDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DmDiscussionElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DmDiscussionElements
     * const dmDiscussionElement = await prisma.dmDiscussionElement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DmDiscussionElementUpdateManyArgs>(
      args: SelectSubset<T, DmDiscussionElementUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DmDiscussionElement.
     * @param {DmDiscussionElementUpsertArgs} args - Arguments to update or create a DmDiscussionElement.
     * @example
     * // Update or create a DmDiscussionElement
     * const dmDiscussionElement = await prisma.dmDiscussionElement.upsert({
     *   create: {
     *     // ... data to create a DmDiscussionElement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DmDiscussionElement we want to update
     *   }
     * })
    **/
    upsert<T extends DmDiscussionElementUpsertArgs>(
      args: SelectSubset<T, DmDiscussionElementUpsertArgs>
    ): Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T>>

    /**
     * Count the number of DmDiscussionElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionElementCountArgs} args - Arguments to filter DmDiscussionElements to count.
     * @example
     * // Count the number of DmDiscussionElements
     * const count = await prisma.dmDiscussionElement.count({
     *   where: {
     *     // ... the filter for the DmDiscussionElements we want to count
     *   }
     * })
    **/
    count<T extends DmDiscussionElementCountArgs>(
      args?: Subset<T, DmDiscussionElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DmDiscussionElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DmDiscussionElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DmDiscussionElementAggregateArgs>(args: Subset<T, DmDiscussionElementAggregateArgs>): Prisma.PrismaPromise<GetDmDiscussionElementAggregateType<T>>

    /**
     * Group by DmDiscussionElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DmDiscussionElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DmDiscussionElementGroupByArgs['orderBy'] }
        : { orderBy?: DmDiscussionElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DmDiscussionElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDmDiscussionElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DmDiscussionElement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DmDiscussionElementClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    message<T extends DmDiscussionElement$messageArgs= {}>(args?: Subset<T, DmDiscussionElement$messageArgs>): Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T> | Null>;

    event<T extends DmDiscussionElement$eventArgs= {}>(args?: Subset<T, DmDiscussionElement$eventArgs>): Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T> | Null>;

    relatedOf<T extends DmDiscussionElement$relatedOfArgs= {}>(args?: Subset<T, DmDiscussionElement$relatedOfArgs>): Prisma.PrismaPromise<Array<DmDiscussionMessageGetPayload<T>>| Null>;

    authorRelation<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    directMessage<T extends DirectMessageArgs= {}>(args?: Subset<T, DirectMessageArgs>): Prisma__DirectMessageClient<DirectMessageGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DmDiscussionElement base type for findUnique actions
   */
  export type DmDiscussionElementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    /**
     * Filter, which DmDiscussionElement to fetch.
     */
    where: DmDiscussionElementWhereUniqueInput
  }

  /**
   * DmDiscussionElement findUnique
   */
  export interface DmDiscussionElementFindUniqueArgs extends DmDiscussionElementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DmDiscussionElement findUniqueOrThrow
   */
  export type DmDiscussionElementFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    /**
     * Filter, which DmDiscussionElement to fetch.
     */
    where: DmDiscussionElementWhereUniqueInput
  }


  /**
   * DmDiscussionElement base type for findFirst actions
   */
  export type DmDiscussionElementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    /**
     * Filter, which DmDiscussionElement to fetch.
     */
    where?: DmDiscussionElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionElements to fetch.
     */
    orderBy?: Enumerable<DmDiscussionElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DmDiscussionElements.
     */
    cursor?: DmDiscussionElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DmDiscussionElements.
     */
    distinct?: Enumerable<DmDiscussionElementScalarFieldEnum>
  }

  /**
   * DmDiscussionElement findFirst
   */
  export interface DmDiscussionElementFindFirstArgs extends DmDiscussionElementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DmDiscussionElement findFirstOrThrow
   */
  export type DmDiscussionElementFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    /**
     * Filter, which DmDiscussionElement to fetch.
     */
    where?: DmDiscussionElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionElements to fetch.
     */
    orderBy?: Enumerable<DmDiscussionElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DmDiscussionElements.
     */
    cursor?: DmDiscussionElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DmDiscussionElements.
     */
    distinct?: Enumerable<DmDiscussionElementScalarFieldEnum>
  }


  /**
   * DmDiscussionElement findMany
   */
  export type DmDiscussionElementFindManyArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    /**
     * Filter, which DmDiscussionElements to fetch.
     */
    where?: DmDiscussionElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionElements to fetch.
     */
    orderBy?: Enumerable<DmDiscussionElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DmDiscussionElements.
     */
    cursor?: DmDiscussionElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionElements.
     */
    skip?: number
    distinct?: Enumerable<DmDiscussionElementScalarFieldEnum>
  }


  /**
   * DmDiscussionElement create
   */
  export type DmDiscussionElementCreateArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    /**
     * The data needed to create a DmDiscussionElement.
     */
    data: XOR<DmDiscussionElementCreateInput, DmDiscussionElementUncheckedCreateInput>
  }


  /**
   * DmDiscussionElement createMany
   */
  export type DmDiscussionElementCreateManyArgs = {
    /**
     * The data used to create many DmDiscussionElements.
     */
    data: Enumerable<DmDiscussionElementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DmDiscussionElement update
   */
  export type DmDiscussionElementUpdateArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    /**
     * The data needed to update a DmDiscussionElement.
     */
    data: XOR<DmDiscussionElementUpdateInput, DmDiscussionElementUncheckedUpdateInput>
    /**
     * Choose, which DmDiscussionElement to update.
     */
    where: DmDiscussionElementWhereUniqueInput
  }


  /**
   * DmDiscussionElement updateMany
   */
  export type DmDiscussionElementUpdateManyArgs = {
    /**
     * The data used to update DmDiscussionElements.
     */
    data: XOR<DmDiscussionElementUpdateManyMutationInput, DmDiscussionElementUncheckedUpdateManyInput>
    /**
     * Filter which DmDiscussionElements to update
     */
    where?: DmDiscussionElementWhereInput
  }


  /**
   * DmDiscussionElement upsert
   */
  export type DmDiscussionElementUpsertArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    /**
     * The filter to search for the DmDiscussionElement to update in case it exists.
     */
    where: DmDiscussionElementWhereUniqueInput
    /**
     * In case the DmDiscussionElement found by the `where` argument doesn't exist, create a new DmDiscussionElement with this data.
     */
    create: XOR<DmDiscussionElementCreateInput, DmDiscussionElementUncheckedCreateInput>
    /**
     * In case the DmDiscussionElement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DmDiscussionElementUpdateInput, DmDiscussionElementUncheckedUpdateInput>
  }


  /**
   * DmDiscussionElement delete
   */
  export type DmDiscussionElementDeleteArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    /**
     * Filter which DmDiscussionElement to delete.
     */
    where: DmDiscussionElementWhereUniqueInput
  }


  /**
   * DmDiscussionElement deleteMany
   */
  export type DmDiscussionElementDeleteManyArgs = {
    /**
     * Filter which DmDiscussionElements to delete
     */
    where?: DmDiscussionElementWhereInput
  }


  /**
   * DmDiscussionElement.message
   */
  export type DmDiscussionElement$messageArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    where?: DmDiscussionMessageWhereInput
  }


  /**
   * DmDiscussionElement.event
   */
  export type DmDiscussionElement$eventArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    where?: DmDiscussionEventWhereInput
  }


  /**
   * DmDiscussionElement.relatedOf
   */
  export type DmDiscussionElement$relatedOfArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    where?: DmDiscussionMessageWhereInput
    orderBy?: Enumerable<DmDiscussionMessageOrderByWithRelationInput>
    cursor?: DmDiscussionMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DmDiscussionMessageScalarFieldEnum>
  }


  /**
   * DmDiscussionElement without action
   */
  export type DmDiscussionElementArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
  }



  /**
   * Model DmDiscussionMessage
   */


  export type AggregateDmDiscussionMessage = {
    _count: DmDiscussionMessageCountAggregateOutputType | null
    _min: DmDiscussionMessageMinAggregateOutputType | null
    _max: DmDiscussionMessageMaxAggregateOutputType | null
  }

  export type DmDiscussionMessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    relatedTo: string | null
  }

  export type DmDiscussionMessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    relatedTo: string | null
  }

  export type DmDiscussionMessageCountAggregateOutputType = {
    id: number
    content: number
    relatedTo: number
    _all: number
  }


  export type DmDiscussionMessageMinAggregateInputType = {
    id?: true
    content?: true
    relatedTo?: true
  }

  export type DmDiscussionMessageMaxAggregateInputType = {
    id?: true
    content?: true
    relatedTo?: true
  }

  export type DmDiscussionMessageCountAggregateInputType = {
    id?: true
    content?: true
    relatedTo?: true
    _all?: true
  }

  export type DmDiscussionMessageAggregateArgs = {
    /**
     * Filter which DmDiscussionMessage to aggregate.
     */
    where?: DmDiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionMessages to fetch.
     */
    orderBy?: Enumerable<DmDiscussionMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DmDiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DmDiscussionMessages
    **/
    _count?: true | DmDiscussionMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DmDiscussionMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DmDiscussionMessageMaxAggregateInputType
  }

  export type GetDmDiscussionMessageAggregateType<T extends DmDiscussionMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDmDiscussionMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDmDiscussionMessage[P]>
      : GetScalarType<T[P], AggregateDmDiscussionMessage[P]>
  }




  export type DmDiscussionMessageGroupByArgs = {
    where?: DmDiscussionMessageWhereInput
    orderBy?: Enumerable<DmDiscussionMessageOrderByWithAggregationInput>
    by: DmDiscussionMessageScalarFieldEnum[]
    having?: DmDiscussionMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DmDiscussionMessageCountAggregateInputType | true
    _min?: DmDiscussionMessageMinAggregateInputType
    _max?: DmDiscussionMessageMaxAggregateInputType
  }


  export type DmDiscussionMessageGroupByOutputType = {
    id: string
    content: string
    relatedTo: string | null
    _count: DmDiscussionMessageCountAggregateOutputType | null
    _min: DmDiscussionMessageMinAggregateOutputType | null
    _max: DmDiscussionMessageMaxAggregateOutputType | null
  }

  type GetDmDiscussionMessageGroupByPayload<T extends DmDiscussionMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DmDiscussionMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DmDiscussionMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DmDiscussionMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DmDiscussionMessageGroupByOutputType[P]>
        }
      >
    >


  export type DmDiscussionMessageSelect = {
    id?: boolean
    content?: boolean
    relatedTo?: boolean
    relatedUsers?: boolean | DmDiscussionMessage$relatedUsersArgs
    related?: boolean | DmDiscussionMessage$relatedArgs
    discussionElement?: boolean | DmDiscussionMessage$discussionElementArgs
    _count?: boolean | DmDiscussionMessageCountOutputTypeArgs
  }


  export type DmDiscussionMessageInclude = {
    relatedUsers?: boolean | DmDiscussionMessage$relatedUsersArgs
    related?: boolean | DmDiscussionMessage$relatedArgs
    discussionElement?: boolean | DmDiscussionMessage$discussionElementArgs
    _count?: boolean | DmDiscussionMessageCountOutputTypeArgs
  }

  export type DmDiscussionMessageGetPayload<S extends boolean | null | undefined | DmDiscussionMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DmDiscussionMessage :
    S extends undefined ? never :
    S extends { include: any } & (DmDiscussionMessageArgs | DmDiscussionMessageFindManyArgs)
    ? DmDiscussionMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'relatedUsers' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'related' ? DmDiscussionElementGetPayload<S['include'][P]> | null :
        P extends 'discussionElement' ? DmDiscussionElementGetPayload<S['include'][P]> | null :
        P extends '_count' ? DmDiscussionMessageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DmDiscussionMessageArgs | DmDiscussionMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'relatedUsers' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'related' ? DmDiscussionElementGetPayload<S['select'][P]> | null :
        P extends 'discussionElement' ? DmDiscussionElementGetPayload<S['select'][P]> | null :
        P extends '_count' ? DmDiscussionMessageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DmDiscussionMessage ? DmDiscussionMessage[P] : never
  } 
      : DmDiscussionMessage


  type DmDiscussionMessageCountArgs = 
    Omit<DmDiscussionMessageFindManyArgs, 'select' | 'include'> & {
      select?: DmDiscussionMessageCountAggregateInputType | true
    }

  export interface DmDiscussionMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DmDiscussionMessage that matches the filter.
     * @param {DmDiscussionMessageFindUniqueArgs} args - Arguments to find a DmDiscussionMessage
     * @example
     * // Get one DmDiscussionMessage
     * const dmDiscussionMessage = await prisma.dmDiscussionMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DmDiscussionMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DmDiscussionMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DmDiscussionMessage'> extends True ? Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T>> : Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T> | null, null>

    /**
     * Find one DmDiscussionMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DmDiscussionMessageFindUniqueOrThrowArgs} args - Arguments to find a DmDiscussionMessage
     * @example
     * // Get one DmDiscussionMessage
     * const dmDiscussionMessage = await prisma.dmDiscussionMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DmDiscussionMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DmDiscussionMessageFindUniqueOrThrowArgs>
    ): Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T>>

    /**
     * Find the first DmDiscussionMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionMessageFindFirstArgs} args - Arguments to find a DmDiscussionMessage
     * @example
     * // Get one DmDiscussionMessage
     * const dmDiscussionMessage = await prisma.dmDiscussionMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DmDiscussionMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DmDiscussionMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DmDiscussionMessage'> extends True ? Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T>> : Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T> | null, null>

    /**
     * Find the first DmDiscussionMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionMessageFindFirstOrThrowArgs} args - Arguments to find a DmDiscussionMessage
     * @example
     * // Get one DmDiscussionMessage
     * const dmDiscussionMessage = await prisma.dmDiscussionMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DmDiscussionMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DmDiscussionMessageFindFirstOrThrowArgs>
    ): Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T>>

    /**
     * Find zero or more DmDiscussionMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DmDiscussionMessages
     * const dmDiscussionMessages = await prisma.dmDiscussionMessage.findMany()
     * 
     * // Get first 10 DmDiscussionMessages
     * const dmDiscussionMessages = await prisma.dmDiscussionMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dmDiscussionMessageWithIdOnly = await prisma.dmDiscussionMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DmDiscussionMessageFindManyArgs>(
      args?: SelectSubset<T, DmDiscussionMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<DmDiscussionMessageGetPayload<T>>>

    /**
     * Create a DmDiscussionMessage.
     * @param {DmDiscussionMessageCreateArgs} args - Arguments to create a DmDiscussionMessage.
     * @example
     * // Create one DmDiscussionMessage
     * const DmDiscussionMessage = await prisma.dmDiscussionMessage.create({
     *   data: {
     *     // ... data to create a DmDiscussionMessage
     *   }
     * })
     * 
    **/
    create<T extends DmDiscussionMessageCreateArgs>(
      args: SelectSubset<T, DmDiscussionMessageCreateArgs>
    ): Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T>>

    /**
     * Create many DmDiscussionMessages.
     *     @param {DmDiscussionMessageCreateManyArgs} args - Arguments to create many DmDiscussionMessages.
     *     @example
     *     // Create many DmDiscussionMessages
     *     const dmDiscussionMessage = await prisma.dmDiscussionMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DmDiscussionMessageCreateManyArgs>(
      args?: SelectSubset<T, DmDiscussionMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DmDiscussionMessage.
     * @param {DmDiscussionMessageDeleteArgs} args - Arguments to delete one DmDiscussionMessage.
     * @example
     * // Delete one DmDiscussionMessage
     * const DmDiscussionMessage = await prisma.dmDiscussionMessage.delete({
     *   where: {
     *     // ... filter to delete one DmDiscussionMessage
     *   }
     * })
     * 
    **/
    delete<T extends DmDiscussionMessageDeleteArgs>(
      args: SelectSubset<T, DmDiscussionMessageDeleteArgs>
    ): Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T>>

    /**
     * Update one DmDiscussionMessage.
     * @param {DmDiscussionMessageUpdateArgs} args - Arguments to update one DmDiscussionMessage.
     * @example
     * // Update one DmDiscussionMessage
     * const dmDiscussionMessage = await prisma.dmDiscussionMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DmDiscussionMessageUpdateArgs>(
      args: SelectSubset<T, DmDiscussionMessageUpdateArgs>
    ): Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T>>

    /**
     * Delete zero or more DmDiscussionMessages.
     * @param {DmDiscussionMessageDeleteManyArgs} args - Arguments to filter DmDiscussionMessages to delete.
     * @example
     * // Delete a few DmDiscussionMessages
     * const { count } = await prisma.dmDiscussionMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DmDiscussionMessageDeleteManyArgs>(
      args?: SelectSubset<T, DmDiscussionMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DmDiscussionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DmDiscussionMessages
     * const dmDiscussionMessage = await prisma.dmDiscussionMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DmDiscussionMessageUpdateManyArgs>(
      args: SelectSubset<T, DmDiscussionMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DmDiscussionMessage.
     * @param {DmDiscussionMessageUpsertArgs} args - Arguments to update or create a DmDiscussionMessage.
     * @example
     * // Update or create a DmDiscussionMessage
     * const dmDiscussionMessage = await prisma.dmDiscussionMessage.upsert({
     *   create: {
     *     // ... data to create a DmDiscussionMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DmDiscussionMessage we want to update
     *   }
     * })
    **/
    upsert<T extends DmDiscussionMessageUpsertArgs>(
      args: SelectSubset<T, DmDiscussionMessageUpsertArgs>
    ): Prisma__DmDiscussionMessageClient<DmDiscussionMessageGetPayload<T>>

    /**
     * Count the number of DmDiscussionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionMessageCountArgs} args - Arguments to filter DmDiscussionMessages to count.
     * @example
     * // Count the number of DmDiscussionMessages
     * const count = await prisma.dmDiscussionMessage.count({
     *   where: {
     *     // ... the filter for the DmDiscussionMessages we want to count
     *   }
     * })
    **/
    count<T extends DmDiscussionMessageCountArgs>(
      args?: Subset<T, DmDiscussionMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DmDiscussionMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DmDiscussionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DmDiscussionMessageAggregateArgs>(args: Subset<T, DmDiscussionMessageAggregateArgs>): Prisma.PrismaPromise<GetDmDiscussionMessageAggregateType<T>>

    /**
     * Group by DmDiscussionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DmDiscussionMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DmDiscussionMessageGroupByArgs['orderBy'] }
        : { orderBy?: DmDiscussionMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DmDiscussionMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDmDiscussionMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DmDiscussionMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DmDiscussionMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    relatedUsers<T extends DmDiscussionMessage$relatedUsersArgs= {}>(args?: Subset<T, DmDiscussionMessage$relatedUsersArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    related<T extends DmDiscussionMessage$relatedArgs= {}>(args?: Subset<T, DmDiscussionMessage$relatedArgs>): Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T> | Null>;

    discussionElement<T extends DmDiscussionMessage$discussionElementArgs= {}>(args?: Subset<T, DmDiscussionMessage$discussionElementArgs>): Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DmDiscussionMessage base type for findUnique actions
   */
  export type DmDiscussionMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    /**
     * Filter, which DmDiscussionMessage to fetch.
     */
    where: DmDiscussionMessageWhereUniqueInput
  }

  /**
   * DmDiscussionMessage findUnique
   */
  export interface DmDiscussionMessageFindUniqueArgs extends DmDiscussionMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DmDiscussionMessage findUniqueOrThrow
   */
  export type DmDiscussionMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    /**
     * Filter, which DmDiscussionMessage to fetch.
     */
    where: DmDiscussionMessageWhereUniqueInput
  }


  /**
   * DmDiscussionMessage base type for findFirst actions
   */
  export type DmDiscussionMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    /**
     * Filter, which DmDiscussionMessage to fetch.
     */
    where?: DmDiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionMessages to fetch.
     */
    orderBy?: Enumerable<DmDiscussionMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DmDiscussionMessages.
     */
    cursor?: DmDiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DmDiscussionMessages.
     */
    distinct?: Enumerable<DmDiscussionMessageScalarFieldEnum>
  }

  /**
   * DmDiscussionMessage findFirst
   */
  export interface DmDiscussionMessageFindFirstArgs extends DmDiscussionMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DmDiscussionMessage findFirstOrThrow
   */
  export type DmDiscussionMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    /**
     * Filter, which DmDiscussionMessage to fetch.
     */
    where?: DmDiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionMessages to fetch.
     */
    orderBy?: Enumerable<DmDiscussionMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DmDiscussionMessages.
     */
    cursor?: DmDiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DmDiscussionMessages.
     */
    distinct?: Enumerable<DmDiscussionMessageScalarFieldEnum>
  }


  /**
   * DmDiscussionMessage findMany
   */
  export type DmDiscussionMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    /**
     * Filter, which DmDiscussionMessages to fetch.
     */
    where?: DmDiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionMessages to fetch.
     */
    orderBy?: Enumerable<DmDiscussionMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DmDiscussionMessages.
     */
    cursor?: DmDiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionMessages.
     */
    skip?: number
    distinct?: Enumerable<DmDiscussionMessageScalarFieldEnum>
  }


  /**
   * DmDiscussionMessage create
   */
  export type DmDiscussionMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    /**
     * The data needed to create a DmDiscussionMessage.
     */
    data: XOR<DmDiscussionMessageCreateInput, DmDiscussionMessageUncheckedCreateInput>
  }


  /**
   * DmDiscussionMessage createMany
   */
  export type DmDiscussionMessageCreateManyArgs = {
    /**
     * The data used to create many DmDiscussionMessages.
     */
    data: Enumerable<DmDiscussionMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DmDiscussionMessage update
   */
  export type DmDiscussionMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    /**
     * The data needed to update a DmDiscussionMessage.
     */
    data: XOR<DmDiscussionMessageUpdateInput, DmDiscussionMessageUncheckedUpdateInput>
    /**
     * Choose, which DmDiscussionMessage to update.
     */
    where: DmDiscussionMessageWhereUniqueInput
  }


  /**
   * DmDiscussionMessage updateMany
   */
  export type DmDiscussionMessageUpdateManyArgs = {
    /**
     * The data used to update DmDiscussionMessages.
     */
    data: XOR<DmDiscussionMessageUpdateManyMutationInput, DmDiscussionMessageUncheckedUpdateManyInput>
    /**
     * Filter which DmDiscussionMessages to update
     */
    where?: DmDiscussionMessageWhereInput
  }


  /**
   * DmDiscussionMessage upsert
   */
  export type DmDiscussionMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    /**
     * The filter to search for the DmDiscussionMessage to update in case it exists.
     */
    where: DmDiscussionMessageWhereUniqueInput
    /**
     * In case the DmDiscussionMessage found by the `where` argument doesn't exist, create a new DmDiscussionMessage with this data.
     */
    create: XOR<DmDiscussionMessageCreateInput, DmDiscussionMessageUncheckedCreateInput>
    /**
     * In case the DmDiscussionMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DmDiscussionMessageUpdateInput, DmDiscussionMessageUncheckedUpdateInput>
  }


  /**
   * DmDiscussionMessage delete
   */
  export type DmDiscussionMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
    /**
     * Filter which DmDiscussionMessage to delete.
     */
    where: DmDiscussionMessageWhereUniqueInput
  }


  /**
   * DmDiscussionMessage deleteMany
   */
  export type DmDiscussionMessageDeleteManyArgs = {
    /**
     * Filter which DmDiscussionMessages to delete
     */
    where?: DmDiscussionMessageWhereInput
  }


  /**
   * DmDiscussionMessage.relatedUsers
   */
  export type DmDiscussionMessage$relatedUsersArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * DmDiscussionMessage.related
   */
  export type DmDiscussionMessage$relatedArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    where?: DmDiscussionElementWhereInput
  }


  /**
   * DmDiscussionMessage.discussionElement
   */
  export type DmDiscussionMessage$discussionElementArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    where?: DmDiscussionElementWhereInput
  }


  /**
   * DmDiscussionMessage without action
   */
  export type DmDiscussionMessageArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionMessage
     */
    select?: DmDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionMessageInclude | null
  }



  /**
   * Model DmDiscussionEvent
   */


  export type AggregateDmDiscussionEvent = {
    _count: DmDiscussionEventCountAggregateOutputType | null
    _min: DmDiscussionEventMinAggregateOutputType | null
    _max: DmDiscussionEventMaxAggregateOutputType | null
  }

  export type DmDiscussionEventMinAggregateOutputType = {
    id: string | null
    classicDmDiscussionEventId: string | null
    chanInvitationDmDiscussionEventId: string | null
  }

  export type DmDiscussionEventMaxAggregateOutputType = {
    id: string | null
    classicDmDiscussionEventId: string | null
    chanInvitationDmDiscussionEventId: string | null
  }

  export type DmDiscussionEventCountAggregateOutputType = {
    id: number
    classicDmDiscussionEventId: number
    chanInvitationDmDiscussionEventId: number
    _all: number
  }


  export type DmDiscussionEventMinAggregateInputType = {
    id?: true
    classicDmDiscussionEventId?: true
    chanInvitationDmDiscussionEventId?: true
  }

  export type DmDiscussionEventMaxAggregateInputType = {
    id?: true
    classicDmDiscussionEventId?: true
    chanInvitationDmDiscussionEventId?: true
  }

  export type DmDiscussionEventCountAggregateInputType = {
    id?: true
    classicDmDiscussionEventId?: true
    chanInvitationDmDiscussionEventId?: true
    _all?: true
  }

  export type DmDiscussionEventAggregateArgs = {
    /**
     * Filter which DmDiscussionEvent to aggregate.
     */
    where?: DmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<DmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DmDiscussionEvents
    **/
    _count?: true | DmDiscussionEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DmDiscussionEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DmDiscussionEventMaxAggregateInputType
  }

  export type GetDmDiscussionEventAggregateType<T extends DmDiscussionEventAggregateArgs> = {
        [P in keyof T & keyof AggregateDmDiscussionEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDmDiscussionEvent[P]>
      : GetScalarType<T[P], AggregateDmDiscussionEvent[P]>
  }




  export type DmDiscussionEventGroupByArgs = {
    where?: DmDiscussionEventWhereInput
    orderBy?: Enumerable<DmDiscussionEventOrderByWithAggregationInput>
    by: DmDiscussionEventScalarFieldEnum[]
    having?: DmDiscussionEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DmDiscussionEventCountAggregateInputType | true
    _min?: DmDiscussionEventMinAggregateInputType
    _max?: DmDiscussionEventMaxAggregateInputType
  }


  export type DmDiscussionEventGroupByOutputType = {
    id: string
    classicDmDiscussionEventId: string | null
    chanInvitationDmDiscussionEventId: string | null
    _count: DmDiscussionEventCountAggregateOutputType | null
    _min: DmDiscussionEventMinAggregateOutputType | null
    _max: DmDiscussionEventMaxAggregateOutputType | null
  }

  type GetDmDiscussionEventGroupByPayload<T extends DmDiscussionEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DmDiscussionEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DmDiscussionEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DmDiscussionEventGroupByOutputType[P]>
            : GetScalarType<T[P], DmDiscussionEventGroupByOutputType[P]>
        }
      >
    >


  export type DmDiscussionEventSelect = {
    id?: boolean
    classicDmDiscussionEventId?: boolean
    chanInvitationDmDiscussionEventId?: boolean
    classicDmDiscussionEvent?: boolean | DmDiscussionEvent$classicDmDiscussionEventArgs
    chanInvitationDmDiscussionEvent?: boolean | DmDiscussionEvent$chanInvitationDmDiscussionEventArgs
    discussionElement?: boolean | DmDiscussionEvent$discussionElementArgs
  }


  export type DmDiscussionEventInclude = {
    classicDmDiscussionEvent?: boolean | DmDiscussionEvent$classicDmDiscussionEventArgs
    chanInvitationDmDiscussionEvent?: boolean | DmDiscussionEvent$chanInvitationDmDiscussionEventArgs
    discussionElement?: boolean | DmDiscussionEvent$discussionElementArgs
  }

  export type DmDiscussionEventGetPayload<S extends boolean | null | undefined | DmDiscussionEventArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DmDiscussionEvent :
    S extends undefined ? never :
    S extends { include: any } & (DmDiscussionEventArgs | DmDiscussionEventFindManyArgs)
    ? DmDiscussionEvent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'classicDmDiscussionEvent' ? ClassicDmDiscussionEventGetPayload<S['include'][P]> | null :
        P extends 'chanInvitationDmDiscussionEvent' ? ChanInvitationDmDiscussionEventGetPayload<S['include'][P]> | null :
        P extends 'discussionElement' ? DmDiscussionElementGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (DmDiscussionEventArgs | DmDiscussionEventFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'classicDmDiscussionEvent' ? ClassicDmDiscussionEventGetPayload<S['select'][P]> | null :
        P extends 'chanInvitationDmDiscussionEvent' ? ChanInvitationDmDiscussionEventGetPayload<S['select'][P]> | null :
        P extends 'discussionElement' ? DmDiscussionElementGetPayload<S['select'][P]> | null :  P extends keyof DmDiscussionEvent ? DmDiscussionEvent[P] : never
  } 
      : DmDiscussionEvent


  type DmDiscussionEventCountArgs = 
    Omit<DmDiscussionEventFindManyArgs, 'select' | 'include'> & {
      select?: DmDiscussionEventCountAggregateInputType | true
    }

  export interface DmDiscussionEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DmDiscussionEvent that matches the filter.
     * @param {DmDiscussionEventFindUniqueArgs} args - Arguments to find a DmDiscussionEvent
     * @example
     * // Get one DmDiscussionEvent
     * const dmDiscussionEvent = await prisma.dmDiscussionEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DmDiscussionEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DmDiscussionEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DmDiscussionEvent'> extends True ? Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T>> : Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T> | null, null>

    /**
     * Find one DmDiscussionEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DmDiscussionEventFindUniqueOrThrowArgs} args - Arguments to find a DmDiscussionEvent
     * @example
     * // Get one DmDiscussionEvent
     * const dmDiscussionEvent = await prisma.dmDiscussionEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DmDiscussionEventFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DmDiscussionEventFindUniqueOrThrowArgs>
    ): Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T>>

    /**
     * Find the first DmDiscussionEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionEventFindFirstArgs} args - Arguments to find a DmDiscussionEvent
     * @example
     * // Get one DmDiscussionEvent
     * const dmDiscussionEvent = await prisma.dmDiscussionEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DmDiscussionEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DmDiscussionEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DmDiscussionEvent'> extends True ? Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T>> : Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T> | null, null>

    /**
     * Find the first DmDiscussionEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionEventFindFirstOrThrowArgs} args - Arguments to find a DmDiscussionEvent
     * @example
     * // Get one DmDiscussionEvent
     * const dmDiscussionEvent = await prisma.dmDiscussionEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DmDiscussionEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DmDiscussionEventFindFirstOrThrowArgs>
    ): Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T>>

    /**
     * Find zero or more DmDiscussionEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DmDiscussionEvents
     * const dmDiscussionEvents = await prisma.dmDiscussionEvent.findMany()
     * 
     * // Get first 10 DmDiscussionEvents
     * const dmDiscussionEvents = await prisma.dmDiscussionEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dmDiscussionEventWithIdOnly = await prisma.dmDiscussionEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DmDiscussionEventFindManyArgs>(
      args?: SelectSubset<T, DmDiscussionEventFindManyArgs>
    ): Prisma.PrismaPromise<Array<DmDiscussionEventGetPayload<T>>>

    /**
     * Create a DmDiscussionEvent.
     * @param {DmDiscussionEventCreateArgs} args - Arguments to create a DmDiscussionEvent.
     * @example
     * // Create one DmDiscussionEvent
     * const DmDiscussionEvent = await prisma.dmDiscussionEvent.create({
     *   data: {
     *     // ... data to create a DmDiscussionEvent
     *   }
     * })
     * 
    **/
    create<T extends DmDiscussionEventCreateArgs>(
      args: SelectSubset<T, DmDiscussionEventCreateArgs>
    ): Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T>>

    /**
     * Create many DmDiscussionEvents.
     *     @param {DmDiscussionEventCreateManyArgs} args - Arguments to create many DmDiscussionEvents.
     *     @example
     *     // Create many DmDiscussionEvents
     *     const dmDiscussionEvent = await prisma.dmDiscussionEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DmDiscussionEventCreateManyArgs>(
      args?: SelectSubset<T, DmDiscussionEventCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DmDiscussionEvent.
     * @param {DmDiscussionEventDeleteArgs} args - Arguments to delete one DmDiscussionEvent.
     * @example
     * // Delete one DmDiscussionEvent
     * const DmDiscussionEvent = await prisma.dmDiscussionEvent.delete({
     *   where: {
     *     // ... filter to delete one DmDiscussionEvent
     *   }
     * })
     * 
    **/
    delete<T extends DmDiscussionEventDeleteArgs>(
      args: SelectSubset<T, DmDiscussionEventDeleteArgs>
    ): Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T>>

    /**
     * Update one DmDiscussionEvent.
     * @param {DmDiscussionEventUpdateArgs} args - Arguments to update one DmDiscussionEvent.
     * @example
     * // Update one DmDiscussionEvent
     * const dmDiscussionEvent = await prisma.dmDiscussionEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DmDiscussionEventUpdateArgs>(
      args: SelectSubset<T, DmDiscussionEventUpdateArgs>
    ): Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T>>

    /**
     * Delete zero or more DmDiscussionEvents.
     * @param {DmDiscussionEventDeleteManyArgs} args - Arguments to filter DmDiscussionEvents to delete.
     * @example
     * // Delete a few DmDiscussionEvents
     * const { count } = await prisma.dmDiscussionEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DmDiscussionEventDeleteManyArgs>(
      args?: SelectSubset<T, DmDiscussionEventDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DmDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DmDiscussionEvents
     * const dmDiscussionEvent = await prisma.dmDiscussionEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DmDiscussionEventUpdateManyArgs>(
      args: SelectSubset<T, DmDiscussionEventUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DmDiscussionEvent.
     * @param {DmDiscussionEventUpsertArgs} args - Arguments to update or create a DmDiscussionEvent.
     * @example
     * // Update or create a DmDiscussionEvent
     * const dmDiscussionEvent = await prisma.dmDiscussionEvent.upsert({
     *   create: {
     *     // ... data to create a DmDiscussionEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DmDiscussionEvent we want to update
     *   }
     * })
    **/
    upsert<T extends DmDiscussionEventUpsertArgs>(
      args: SelectSubset<T, DmDiscussionEventUpsertArgs>
    ): Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T>>

    /**
     * Count the number of DmDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionEventCountArgs} args - Arguments to filter DmDiscussionEvents to count.
     * @example
     * // Count the number of DmDiscussionEvents
     * const count = await prisma.dmDiscussionEvent.count({
     *   where: {
     *     // ... the filter for the DmDiscussionEvents we want to count
     *   }
     * })
    **/
    count<T extends DmDiscussionEventCountArgs>(
      args?: Subset<T, DmDiscussionEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DmDiscussionEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DmDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DmDiscussionEventAggregateArgs>(args: Subset<T, DmDiscussionEventAggregateArgs>): Prisma.PrismaPromise<GetDmDiscussionEventAggregateType<T>>

    /**
     * Group by DmDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DmDiscussionEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DmDiscussionEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DmDiscussionEventGroupByArgs['orderBy'] }
        : { orderBy?: DmDiscussionEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DmDiscussionEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDmDiscussionEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DmDiscussionEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DmDiscussionEventClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    classicDmDiscussionEvent<T extends DmDiscussionEvent$classicDmDiscussionEventArgs= {}>(args?: Subset<T, DmDiscussionEvent$classicDmDiscussionEventArgs>): Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T> | Null>;

    chanInvitationDmDiscussionEvent<T extends DmDiscussionEvent$chanInvitationDmDiscussionEventArgs= {}>(args?: Subset<T, DmDiscussionEvent$chanInvitationDmDiscussionEventArgs>): Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T> | Null>;

    discussionElement<T extends DmDiscussionEvent$discussionElementArgs= {}>(args?: Subset<T, DmDiscussionEvent$discussionElementArgs>): Prisma__DmDiscussionElementClient<DmDiscussionElementGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DmDiscussionEvent base type for findUnique actions
   */
  export type DmDiscussionEventFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    /**
     * Filter, which DmDiscussionEvent to fetch.
     */
    where: DmDiscussionEventWhereUniqueInput
  }

  /**
   * DmDiscussionEvent findUnique
   */
  export interface DmDiscussionEventFindUniqueArgs extends DmDiscussionEventFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DmDiscussionEvent findUniqueOrThrow
   */
  export type DmDiscussionEventFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    /**
     * Filter, which DmDiscussionEvent to fetch.
     */
    where: DmDiscussionEventWhereUniqueInput
  }


  /**
   * DmDiscussionEvent base type for findFirst actions
   */
  export type DmDiscussionEventFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    /**
     * Filter, which DmDiscussionEvent to fetch.
     */
    where?: DmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<DmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DmDiscussionEvents.
     */
    cursor?: DmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DmDiscussionEvents.
     */
    distinct?: Enumerable<DmDiscussionEventScalarFieldEnum>
  }

  /**
   * DmDiscussionEvent findFirst
   */
  export interface DmDiscussionEventFindFirstArgs extends DmDiscussionEventFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DmDiscussionEvent findFirstOrThrow
   */
  export type DmDiscussionEventFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    /**
     * Filter, which DmDiscussionEvent to fetch.
     */
    where?: DmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<DmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DmDiscussionEvents.
     */
    cursor?: DmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DmDiscussionEvents.
     */
    distinct?: Enumerable<DmDiscussionEventScalarFieldEnum>
  }


  /**
   * DmDiscussionEvent findMany
   */
  export type DmDiscussionEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    /**
     * Filter, which DmDiscussionEvents to fetch.
     */
    where?: DmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<DmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DmDiscussionEvents.
     */
    cursor?: DmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DmDiscussionEvents.
     */
    skip?: number
    distinct?: Enumerable<DmDiscussionEventScalarFieldEnum>
  }


  /**
   * DmDiscussionEvent create
   */
  export type DmDiscussionEventCreateArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    /**
     * The data needed to create a DmDiscussionEvent.
     */
    data: XOR<DmDiscussionEventCreateInput, DmDiscussionEventUncheckedCreateInput>
  }


  /**
   * DmDiscussionEvent createMany
   */
  export type DmDiscussionEventCreateManyArgs = {
    /**
     * The data used to create many DmDiscussionEvents.
     */
    data: Enumerable<DmDiscussionEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DmDiscussionEvent update
   */
  export type DmDiscussionEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    /**
     * The data needed to update a DmDiscussionEvent.
     */
    data: XOR<DmDiscussionEventUpdateInput, DmDiscussionEventUncheckedUpdateInput>
    /**
     * Choose, which DmDiscussionEvent to update.
     */
    where: DmDiscussionEventWhereUniqueInput
  }


  /**
   * DmDiscussionEvent updateMany
   */
  export type DmDiscussionEventUpdateManyArgs = {
    /**
     * The data used to update DmDiscussionEvents.
     */
    data: XOR<DmDiscussionEventUpdateManyMutationInput, DmDiscussionEventUncheckedUpdateManyInput>
    /**
     * Filter which DmDiscussionEvents to update
     */
    where?: DmDiscussionEventWhereInput
  }


  /**
   * DmDiscussionEvent upsert
   */
  export type DmDiscussionEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    /**
     * The filter to search for the DmDiscussionEvent to update in case it exists.
     */
    where: DmDiscussionEventWhereUniqueInput
    /**
     * In case the DmDiscussionEvent found by the `where` argument doesn't exist, create a new DmDiscussionEvent with this data.
     */
    create: XOR<DmDiscussionEventCreateInput, DmDiscussionEventUncheckedCreateInput>
    /**
     * In case the DmDiscussionEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DmDiscussionEventUpdateInput, DmDiscussionEventUncheckedUpdateInput>
  }


  /**
   * DmDiscussionEvent delete
   */
  export type DmDiscussionEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    /**
     * Filter which DmDiscussionEvent to delete.
     */
    where: DmDiscussionEventWhereUniqueInput
  }


  /**
   * DmDiscussionEvent deleteMany
   */
  export type DmDiscussionEventDeleteManyArgs = {
    /**
     * Filter which DmDiscussionEvents to delete
     */
    where?: DmDiscussionEventWhereInput
  }


  /**
   * DmDiscussionEvent.classicDmDiscussionEvent
   */
  export type DmDiscussionEvent$classicDmDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    where?: ClassicDmDiscussionEventWhereInput
  }


  /**
   * DmDiscussionEvent.chanInvitationDmDiscussionEvent
   */
  export type DmDiscussionEvent$chanInvitationDmDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    where?: ChanInvitationDmDiscussionEventWhereInput
  }


  /**
   * DmDiscussionEvent.discussionElement
   */
  export type DmDiscussionEvent$discussionElementArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionElement
     */
    select?: DmDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionElementInclude | null
    where?: DmDiscussionElementWhereInput
  }


  /**
   * DmDiscussionEvent without action
   */
  export type DmDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
  }



  /**
   * Model ChanInvitationDmDiscussionEvent
   */


  export type AggregateChanInvitationDmDiscussionEvent = {
    _count: ChanInvitationDmDiscussionEventCountAggregateOutputType | null
    _min: ChanInvitationDmDiscussionEventMinAggregateOutputType | null
    _max: ChanInvitationDmDiscussionEventMaxAggregateOutputType | null
  }

  export type ChanInvitationDmDiscussionEventMinAggregateOutputType = {
    id: string | null
    chanInvitationId: string | null
  }

  export type ChanInvitationDmDiscussionEventMaxAggregateOutputType = {
    id: string | null
    chanInvitationId: string | null
  }

  export type ChanInvitationDmDiscussionEventCountAggregateOutputType = {
    id: number
    chanInvitationId: number
    _all: number
  }


  export type ChanInvitationDmDiscussionEventMinAggregateInputType = {
    id?: true
    chanInvitationId?: true
  }

  export type ChanInvitationDmDiscussionEventMaxAggregateInputType = {
    id?: true
    chanInvitationId?: true
  }

  export type ChanInvitationDmDiscussionEventCountAggregateInputType = {
    id?: true
    chanInvitationId?: true
    _all?: true
  }

  export type ChanInvitationDmDiscussionEventAggregateArgs = {
    /**
     * Filter which ChanInvitationDmDiscussionEvent to aggregate.
     */
    where?: ChanInvitationDmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanInvitationDmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChanInvitationDmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChanInvitationDmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanInvitationDmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanInvitationDmDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChanInvitationDmDiscussionEvents
    **/
    _count?: true | ChanInvitationDmDiscussionEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChanInvitationDmDiscussionEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChanInvitationDmDiscussionEventMaxAggregateInputType
  }

  export type GetChanInvitationDmDiscussionEventAggregateType<T extends ChanInvitationDmDiscussionEventAggregateArgs> = {
        [P in keyof T & keyof AggregateChanInvitationDmDiscussionEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChanInvitationDmDiscussionEvent[P]>
      : GetScalarType<T[P], AggregateChanInvitationDmDiscussionEvent[P]>
  }




  export type ChanInvitationDmDiscussionEventGroupByArgs = {
    where?: ChanInvitationDmDiscussionEventWhereInput
    orderBy?: Enumerable<ChanInvitationDmDiscussionEventOrderByWithAggregationInput>
    by: ChanInvitationDmDiscussionEventScalarFieldEnum[]
    having?: ChanInvitationDmDiscussionEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChanInvitationDmDiscussionEventCountAggregateInputType | true
    _min?: ChanInvitationDmDiscussionEventMinAggregateInputType
    _max?: ChanInvitationDmDiscussionEventMaxAggregateInputType
  }


  export type ChanInvitationDmDiscussionEventGroupByOutputType = {
    id: string
    chanInvitationId: string
    _count: ChanInvitationDmDiscussionEventCountAggregateOutputType | null
    _min: ChanInvitationDmDiscussionEventMinAggregateOutputType | null
    _max: ChanInvitationDmDiscussionEventMaxAggregateOutputType | null
  }

  type GetChanInvitationDmDiscussionEventGroupByPayload<T extends ChanInvitationDmDiscussionEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChanInvitationDmDiscussionEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChanInvitationDmDiscussionEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChanInvitationDmDiscussionEventGroupByOutputType[P]>
            : GetScalarType<T[P], ChanInvitationDmDiscussionEventGroupByOutputType[P]>
        }
      >
    >


  export type ChanInvitationDmDiscussionEventSelect = {
    id?: boolean
    chanInvitationId?: boolean
    chanInvitation?: boolean | ChanInvitationArgs
    dmDiscussionEvent?: boolean | ChanInvitationDmDiscussionEvent$dmDiscussionEventArgs
  }


  export type ChanInvitationDmDiscussionEventInclude = {
    chanInvitation?: boolean | ChanInvitationArgs
    dmDiscussionEvent?: boolean | ChanInvitationDmDiscussionEvent$dmDiscussionEventArgs
  }

  export type ChanInvitationDmDiscussionEventGetPayload<S extends boolean | null | undefined | ChanInvitationDmDiscussionEventArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChanInvitationDmDiscussionEvent :
    S extends undefined ? never :
    S extends { include: any } & (ChanInvitationDmDiscussionEventArgs | ChanInvitationDmDiscussionEventFindManyArgs)
    ? ChanInvitationDmDiscussionEvent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'chanInvitation' ? ChanInvitationGetPayload<S['include'][P]> :
        P extends 'dmDiscussionEvent' ? DmDiscussionEventGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ChanInvitationDmDiscussionEventArgs | ChanInvitationDmDiscussionEventFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'chanInvitation' ? ChanInvitationGetPayload<S['select'][P]> :
        P extends 'dmDiscussionEvent' ? DmDiscussionEventGetPayload<S['select'][P]> | null :  P extends keyof ChanInvitationDmDiscussionEvent ? ChanInvitationDmDiscussionEvent[P] : never
  } 
      : ChanInvitationDmDiscussionEvent


  type ChanInvitationDmDiscussionEventCountArgs = 
    Omit<ChanInvitationDmDiscussionEventFindManyArgs, 'select' | 'include'> & {
      select?: ChanInvitationDmDiscussionEventCountAggregateInputType | true
    }

  export interface ChanInvitationDmDiscussionEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChanInvitationDmDiscussionEvent that matches the filter.
     * @param {ChanInvitationDmDiscussionEventFindUniqueArgs} args - Arguments to find a ChanInvitationDmDiscussionEvent
     * @example
     * // Get one ChanInvitationDmDiscussionEvent
     * const chanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChanInvitationDmDiscussionEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChanInvitationDmDiscussionEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChanInvitationDmDiscussionEvent'> extends True ? Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T>> : Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T> | null, null>

    /**
     * Find one ChanInvitationDmDiscussionEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChanInvitationDmDiscussionEventFindUniqueOrThrowArgs} args - Arguments to find a ChanInvitationDmDiscussionEvent
     * @example
     * // Get one ChanInvitationDmDiscussionEvent
     * const chanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChanInvitationDmDiscussionEventFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChanInvitationDmDiscussionEventFindUniqueOrThrowArgs>
    ): Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T>>

    /**
     * Find the first ChanInvitationDmDiscussionEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationDmDiscussionEventFindFirstArgs} args - Arguments to find a ChanInvitationDmDiscussionEvent
     * @example
     * // Get one ChanInvitationDmDiscussionEvent
     * const chanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChanInvitationDmDiscussionEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChanInvitationDmDiscussionEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChanInvitationDmDiscussionEvent'> extends True ? Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T>> : Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T> | null, null>

    /**
     * Find the first ChanInvitationDmDiscussionEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationDmDiscussionEventFindFirstOrThrowArgs} args - Arguments to find a ChanInvitationDmDiscussionEvent
     * @example
     * // Get one ChanInvitationDmDiscussionEvent
     * const chanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChanInvitationDmDiscussionEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChanInvitationDmDiscussionEventFindFirstOrThrowArgs>
    ): Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T>>

    /**
     * Find zero or more ChanInvitationDmDiscussionEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationDmDiscussionEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChanInvitationDmDiscussionEvents
     * const chanInvitationDmDiscussionEvents = await prisma.chanInvitationDmDiscussionEvent.findMany()
     * 
     * // Get first 10 ChanInvitationDmDiscussionEvents
     * const chanInvitationDmDiscussionEvents = await prisma.chanInvitationDmDiscussionEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chanInvitationDmDiscussionEventWithIdOnly = await prisma.chanInvitationDmDiscussionEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChanInvitationDmDiscussionEventFindManyArgs>(
      args?: SelectSubset<T, ChanInvitationDmDiscussionEventFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChanInvitationDmDiscussionEventGetPayload<T>>>

    /**
     * Create a ChanInvitationDmDiscussionEvent.
     * @param {ChanInvitationDmDiscussionEventCreateArgs} args - Arguments to create a ChanInvitationDmDiscussionEvent.
     * @example
     * // Create one ChanInvitationDmDiscussionEvent
     * const ChanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.create({
     *   data: {
     *     // ... data to create a ChanInvitationDmDiscussionEvent
     *   }
     * })
     * 
    **/
    create<T extends ChanInvitationDmDiscussionEventCreateArgs>(
      args: SelectSubset<T, ChanInvitationDmDiscussionEventCreateArgs>
    ): Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T>>

    /**
     * Create many ChanInvitationDmDiscussionEvents.
     *     @param {ChanInvitationDmDiscussionEventCreateManyArgs} args - Arguments to create many ChanInvitationDmDiscussionEvents.
     *     @example
     *     // Create many ChanInvitationDmDiscussionEvents
     *     const chanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChanInvitationDmDiscussionEventCreateManyArgs>(
      args?: SelectSubset<T, ChanInvitationDmDiscussionEventCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChanInvitationDmDiscussionEvent.
     * @param {ChanInvitationDmDiscussionEventDeleteArgs} args - Arguments to delete one ChanInvitationDmDiscussionEvent.
     * @example
     * // Delete one ChanInvitationDmDiscussionEvent
     * const ChanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.delete({
     *   where: {
     *     // ... filter to delete one ChanInvitationDmDiscussionEvent
     *   }
     * })
     * 
    **/
    delete<T extends ChanInvitationDmDiscussionEventDeleteArgs>(
      args: SelectSubset<T, ChanInvitationDmDiscussionEventDeleteArgs>
    ): Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T>>

    /**
     * Update one ChanInvitationDmDiscussionEvent.
     * @param {ChanInvitationDmDiscussionEventUpdateArgs} args - Arguments to update one ChanInvitationDmDiscussionEvent.
     * @example
     * // Update one ChanInvitationDmDiscussionEvent
     * const chanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChanInvitationDmDiscussionEventUpdateArgs>(
      args: SelectSubset<T, ChanInvitationDmDiscussionEventUpdateArgs>
    ): Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T>>

    /**
     * Delete zero or more ChanInvitationDmDiscussionEvents.
     * @param {ChanInvitationDmDiscussionEventDeleteManyArgs} args - Arguments to filter ChanInvitationDmDiscussionEvents to delete.
     * @example
     * // Delete a few ChanInvitationDmDiscussionEvents
     * const { count } = await prisma.chanInvitationDmDiscussionEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChanInvitationDmDiscussionEventDeleteManyArgs>(
      args?: SelectSubset<T, ChanInvitationDmDiscussionEventDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChanInvitationDmDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationDmDiscussionEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChanInvitationDmDiscussionEvents
     * const chanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChanInvitationDmDiscussionEventUpdateManyArgs>(
      args: SelectSubset<T, ChanInvitationDmDiscussionEventUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChanInvitationDmDiscussionEvent.
     * @param {ChanInvitationDmDiscussionEventUpsertArgs} args - Arguments to update or create a ChanInvitationDmDiscussionEvent.
     * @example
     * // Update or create a ChanInvitationDmDiscussionEvent
     * const chanInvitationDmDiscussionEvent = await prisma.chanInvitationDmDiscussionEvent.upsert({
     *   create: {
     *     // ... data to create a ChanInvitationDmDiscussionEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChanInvitationDmDiscussionEvent we want to update
     *   }
     * })
    **/
    upsert<T extends ChanInvitationDmDiscussionEventUpsertArgs>(
      args: SelectSubset<T, ChanInvitationDmDiscussionEventUpsertArgs>
    ): Prisma__ChanInvitationDmDiscussionEventClient<ChanInvitationDmDiscussionEventGetPayload<T>>

    /**
     * Count the number of ChanInvitationDmDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationDmDiscussionEventCountArgs} args - Arguments to filter ChanInvitationDmDiscussionEvents to count.
     * @example
     * // Count the number of ChanInvitationDmDiscussionEvents
     * const count = await prisma.chanInvitationDmDiscussionEvent.count({
     *   where: {
     *     // ... the filter for the ChanInvitationDmDiscussionEvents we want to count
     *   }
     * })
    **/
    count<T extends ChanInvitationDmDiscussionEventCountArgs>(
      args?: Subset<T, ChanInvitationDmDiscussionEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChanInvitationDmDiscussionEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChanInvitationDmDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationDmDiscussionEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChanInvitationDmDiscussionEventAggregateArgs>(args: Subset<T, ChanInvitationDmDiscussionEventAggregateArgs>): Prisma.PrismaPromise<GetChanInvitationDmDiscussionEventAggregateType<T>>

    /**
     * Group by ChanInvitationDmDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanInvitationDmDiscussionEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChanInvitationDmDiscussionEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChanInvitationDmDiscussionEventGroupByArgs['orderBy'] }
        : { orderBy?: ChanInvitationDmDiscussionEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChanInvitationDmDiscussionEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChanInvitationDmDiscussionEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChanInvitationDmDiscussionEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChanInvitationDmDiscussionEventClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chanInvitation<T extends ChanInvitationArgs= {}>(args?: Subset<T, ChanInvitationArgs>): Prisma__ChanInvitationClient<ChanInvitationGetPayload<T> | Null>;

    dmDiscussionEvent<T extends ChanInvitationDmDiscussionEvent$dmDiscussionEventArgs= {}>(args?: Subset<T, ChanInvitationDmDiscussionEvent$dmDiscussionEventArgs>): Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChanInvitationDmDiscussionEvent base type for findUnique actions
   */
  export type ChanInvitationDmDiscussionEventFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    /**
     * Filter, which ChanInvitationDmDiscussionEvent to fetch.
     */
    where: ChanInvitationDmDiscussionEventWhereUniqueInput
  }

  /**
   * ChanInvitationDmDiscussionEvent findUnique
   */
  export interface ChanInvitationDmDiscussionEventFindUniqueArgs extends ChanInvitationDmDiscussionEventFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanInvitationDmDiscussionEvent findUniqueOrThrow
   */
  export type ChanInvitationDmDiscussionEventFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    /**
     * Filter, which ChanInvitationDmDiscussionEvent to fetch.
     */
    where: ChanInvitationDmDiscussionEventWhereUniqueInput
  }


  /**
   * ChanInvitationDmDiscussionEvent base type for findFirst actions
   */
  export type ChanInvitationDmDiscussionEventFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    /**
     * Filter, which ChanInvitationDmDiscussionEvent to fetch.
     */
    where?: ChanInvitationDmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanInvitationDmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChanInvitationDmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanInvitationDmDiscussionEvents.
     */
    cursor?: ChanInvitationDmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanInvitationDmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanInvitationDmDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanInvitationDmDiscussionEvents.
     */
    distinct?: Enumerable<ChanInvitationDmDiscussionEventScalarFieldEnum>
  }

  /**
   * ChanInvitationDmDiscussionEvent findFirst
   */
  export interface ChanInvitationDmDiscussionEventFindFirstArgs extends ChanInvitationDmDiscussionEventFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanInvitationDmDiscussionEvent findFirstOrThrow
   */
  export type ChanInvitationDmDiscussionEventFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    /**
     * Filter, which ChanInvitationDmDiscussionEvent to fetch.
     */
    where?: ChanInvitationDmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanInvitationDmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChanInvitationDmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanInvitationDmDiscussionEvents.
     */
    cursor?: ChanInvitationDmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanInvitationDmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanInvitationDmDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanInvitationDmDiscussionEvents.
     */
    distinct?: Enumerable<ChanInvitationDmDiscussionEventScalarFieldEnum>
  }


  /**
   * ChanInvitationDmDiscussionEvent findMany
   */
  export type ChanInvitationDmDiscussionEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    /**
     * Filter, which ChanInvitationDmDiscussionEvents to fetch.
     */
    where?: ChanInvitationDmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanInvitationDmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChanInvitationDmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChanInvitationDmDiscussionEvents.
     */
    cursor?: ChanInvitationDmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanInvitationDmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanInvitationDmDiscussionEvents.
     */
    skip?: number
    distinct?: Enumerable<ChanInvitationDmDiscussionEventScalarFieldEnum>
  }


  /**
   * ChanInvitationDmDiscussionEvent create
   */
  export type ChanInvitationDmDiscussionEventCreateArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    /**
     * The data needed to create a ChanInvitationDmDiscussionEvent.
     */
    data: XOR<ChanInvitationDmDiscussionEventCreateInput, ChanInvitationDmDiscussionEventUncheckedCreateInput>
  }


  /**
   * ChanInvitationDmDiscussionEvent createMany
   */
  export type ChanInvitationDmDiscussionEventCreateManyArgs = {
    /**
     * The data used to create many ChanInvitationDmDiscussionEvents.
     */
    data: Enumerable<ChanInvitationDmDiscussionEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChanInvitationDmDiscussionEvent update
   */
  export type ChanInvitationDmDiscussionEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    /**
     * The data needed to update a ChanInvitationDmDiscussionEvent.
     */
    data: XOR<ChanInvitationDmDiscussionEventUpdateInput, ChanInvitationDmDiscussionEventUncheckedUpdateInput>
    /**
     * Choose, which ChanInvitationDmDiscussionEvent to update.
     */
    where: ChanInvitationDmDiscussionEventWhereUniqueInput
  }


  /**
   * ChanInvitationDmDiscussionEvent updateMany
   */
  export type ChanInvitationDmDiscussionEventUpdateManyArgs = {
    /**
     * The data used to update ChanInvitationDmDiscussionEvents.
     */
    data: XOR<ChanInvitationDmDiscussionEventUpdateManyMutationInput, ChanInvitationDmDiscussionEventUncheckedUpdateManyInput>
    /**
     * Filter which ChanInvitationDmDiscussionEvents to update
     */
    where?: ChanInvitationDmDiscussionEventWhereInput
  }


  /**
   * ChanInvitationDmDiscussionEvent upsert
   */
  export type ChanInvitationDmDiscussionEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    /**
     * The filter to search for the ChanInvitationDmDiscussionEvent to update in case it exists.
     */
    where: ChanInvitationDmDiscussionEventWhereUniqueInput
    /**
     * In case the ChanInvitationDmDiscussionEvent found by the `where` argument doesn't exist, create a new ChanInvitationDmDiscussionEvent with this data.
     */
    create: XOR<ChanInvitationDmDiscussionEventCreateInput, ChanInvitationDmDiscussionEventUncheckedCreateInput>
    /**
     * In case the ChanInvitationDmDiscussionEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChanInvitationDmDiscussionEventUpdateInput, ChanInvitationDmDiscussionEventUncheckedUpdateInput>
  }


  /**
   * ChanInvitationDmDiscussionEvent delete
   */
  export type ChanInvitationDmDiscussionEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
    /**
     * Filter which ChanInvitationDmDiscussionEvent to delete.
     */
    where: ChanInvitationDmDiscussionEventWhereUniqueInput
  }


  /**
   * ChanInvitationDmDiscussionEvent deleteMany
   */
  export type ChanInvitationDmDiscussionEventDeleteManyArgs = {
    /**
     * Filter which ChanInvitationDmDiscussionEvents to delete
     */
    where?: ChanInvitationDmDiscussionEventWhereInput
  }


  /**
   * ChanInvitationDmDiscussionEvent.dmDiscussionEvent
   */
  export type ChanInvitationDmDiscussionEvent$dmDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    where?: DmDiscussionEventWhereInput
  }


  /**
   * ChanInvitationDmDiscussionEvent without action
   */
  export type ChanInvitationDmDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitationDmDiscussionEvent
     */
    select?: ChanInvitationDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationDmDiscussionEventInclude | null
  }



  /**
   * Model ClassicDmDiscussionEvent
   */


  export type AggregateClassicDmDiscussionEvent = {
    _count: ClassicDmDiscussionEventCountAggregateOutputType | null
    _min: ClassicDmDiscussionEventMinAggregateOutputType | null
    _max: ClassicDmDiscussionEventMaxAggregateOutputType | null
  }

  export type ClassicDmDiscussionEventMinAggregateOutputType = {
    id: string | null
    eventType: ClassicDmEventType | null
  }

  export type ClassicDmDiscussionEventMaxAggregateOutputType = {
    id: string | null
    eventType: ClassicDmEventType | null
  }

  export type ClassicDmDiscussionEventCountAggregateOutputType = {
    id: number
    eventType: number
    _all: number
  }


  export type ClassicDmDiscussionEventMinAggregateInputType = {
    id?: true
    eventType?: true
  }

  export type ClassicDmDiscussionEventMaxAggregateInputType = {
    id?: true
    eventType?: true
  }

  export type ClassicDmDiscussionEventCountAggregateInputType = {
    id?: true
    eventType?: true
    _all?: true
  }

  export type ClassicDmDiscussionEventAggregateArgs = {
    /**
     * Filter which ClassicDmDiscussionEvent to aggregate.
     */
    where?: ClassicDmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassicDmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ClassicDmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassicDmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassicDmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassicDmDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassicDmDiscussionEvents
    **/
    _count?: true | ClassicDmDiscussionEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassicDmDiscussionEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassicDmDiscussionEventMaxAggregateInputType
  }

  export type GetClassicDmDiscussionEventAggregateType<T extends ClassicDmDiscussionEventAggregateArgs> = {
        [P in keyof T & keyof AggregateClassicDmDiscussionEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassicDmDiscussionEvent[P]>
      : GetScalarType<T[P], AggregateClassicDmDiscussionEvent[P]>
  }




  export type ClassicDmDiscussionEventGroupByArgs = {
    where?: ClassicDmDiscussionEventWhereInput
    orderBy?: Enumerable<ClassicDmDiscussionEventOrderByWithAggregationInput>
    by: ClassicDmDiscussionEventScalarFieldEnum[]
    having?: ClassicDmDiscussionEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassicDmDiscussionEventCountAggregateInputType | true
    _min?: ClassicDmDiscussionEventMinAggregateInputType
    _max?: ClassicDmDiscussionEventMaxAggregateInputType
  }


  export type ClassicDmDiscussionEventGroupByOutputType = {
    id: string
    eventType: ClassicDmEventType
    _count: ClassicDmDiscussionEventCountAggregateOutputType | null
    _min: ClassicDmDiscussionEventMinAggregateOutputType | null
    _max: ClassicDmDiscussionEventMaxAggregateOutputType | null
  }

  type GetClassicDmDiscussionEventGroupByPayload<T extends ClassicDmDiscussionEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ClassicDmDiscussionEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassicDmDiscussionEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassicDmDiscussionEventGroupByOutputType[P]>
            : GetScalarType<T[P], ClassicDmDiscussionEventGroupByOutputType[P]>
        }
      >
    >


  export type ClassicDmDiscussionEventSelect = {
    id?: boolean
    eventType?: boolean
    dmDiscussionEvent?: boolean | ClassicDmDiscussionEvent$dmDiscussionEventArgs
  }


  export type ClassicDmDiscussionEventInclude = {
    dmDiscussionEvent?: boolean | ClassicDmDiscussionEvent$dmDiscussionEventArgs
  }

  export type ClassicDmDiscussionEventGetPayload<S extends boolean | null | undefined | ClassicDmDiscussionEventArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClassicDmDiscussionEvent :
    S extends undefined ? never :
    S extends { include: any } & (ClassicDmDiscussionEventArgs | ClassicDmDiscussionEventFindManyArgs)
    ? ClassicDmDiscussionEvent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'dmDiscussionEvent' ? DmDiscussionEventGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ClassicDmDiscussionEventArgs | ClassicDmDiscussionEventFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'dmDiscussionEvent' ? DmDiscussionEventGetPayload<S['select'][P]> | null :  P extends keyof ClassicDmDiscussionEvent ? ClassicDmDiscussionEvent[P] : never
  } 
      : ClassicDmDiscussionEvent


  type ClassicDmDiscussionEventCountArgs = 
    Omit<ClassicDmDiscussionEventFindManyArgs, 'select' | 'include'> & {
      select?: ClassicDmDiscussionEventCountAggregateInputType | true
    }

  export interface ClassicDmDiscussionEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ClassicDmDiscussionEvent that matches the filter.
     * @param {ClassicDmDiscussionEventFindUniqueArgs} args - Arguments to find a ClassicDmDiscussionEvent
     * @example
     * // Get one ClassicDmDiscussionEvent
     * const classicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClassicDmDiscussionEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClassicDmDiscussionEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ClassicDmDiscussionEvent'> extends True ? Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T>> : Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T> | null, null>

    /**
     * Find one ClassicDmDiscussionEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClassicDmDiscussionEventFindUniqueOrThrowArgs} args - Arguments to find a ClassicDmDiscussionEvent
     * @example
     * // Get one ClassicDmDiscussionEvent
     * const classicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClassicDmDiscussionEventFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClassicDmDiscussionEventFindUniqueOrThrowArgs>
    ): Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T>>

    /**
     * Find the first ClassicDmDiscussionEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicDmDiscussionEventFindFirstArgs} args - Arguments to find a ClassicDmDiscussionEvent
     * @example
     * // Get one ClassicDmDiscussionEvent
     * const classicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClassicDmDiscussionEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClassicDmDiscussionEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ClassicDmDiscussionEvent'> extends True ? Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T>> : Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T> | null, null>

    /**
     * Find the first ClassicDmDiscussionEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicDmDiscussionEventFindFirstOrThrowArgs} args - Arguments to find a ClassicDmDiscussionEvent
     * @example
     * // Get one ClassicDmDiscussionEvent
     * const classicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClassicDmDiscussionEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClassicDmDiscussionEventFindFirstOrThrowArgs>
    ): Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T>>

    /**
     * Find zero or more ClassicDmDiscussionEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicDmDiscussionEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassicDmDiscussionEvents
     * const classicDmDiscussionEvents = await prisma.classicDmDiscussionEvent.findMany()
     * 
     * // Get first 10 ClassicDmDiscussionEvents
     * const classicDmDiscussionEvents = await prisma.classicDmDiscussionEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classicDmDiscussionEventWithIdOnly = await prisma.classicDmDiscussionEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClassicDmDiscussionEventFindManyArgs>(
      args?: SelectSubset<T, ClassicDmDiscussionEventFindManyArgs>
    ): Prisma.PrismaPromise<Array<ClassicDmDiscussionEventGetPayload<T>>>

    /**
     * Create a ClassicDmDiscussionEvent.
     * @param {ClassicDmDiscussionEventCreateArgs} args - Arguments to create a ClassicDmDiscussionEvent.
     * @example
     * // Create one ClassicDmDiscussionEvent
     * const ClassicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.create({
     *   data: {
     *     // ... data to create a ClassicDmDiscussionEvent
     *   }
     * })
     * 
    **/
    create<T extends ClassicDmDiscussionEventCreateArgs>(
      args: SelectSubset<T, ClassicDmDiscussionEventCreateArgs>
    ): Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T>>

    /**
     * Create many ClassicDmDiscussionEvents.
     *     @param {ClassicDmDiscussionEventCreateManyArgs} args - Arguments to create many ClassicDmDiscussionEvents.
     *     @example
     *     // Create many ClassicDmDiscussionEvents
     *     const classicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClassicDmDiscussionEventCreateManyArgs>(
      args?: SelectSubset<T, ClassicDmDiscussionEventCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassicDmDiscussionEvent.
     * @param {ClassicDmDiscussionEventDeleteArgs} args - Arguments to delete one ClassicDmDiscussionEvent.
     * @example
     * // Delete one ClassicDmDiscussionEvent
     * const ClassicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.delete({
     *   where: {
     *     // ... filter to delete one ClassicDmDiscussionEvent
     *   }
     * })
     * 
    **/
    delete<T extends ClassicDmDiscussionEventDeleteArgs>(
      args: SelectSubset<T, ClassicDmDiscussionEventDeleteArgs>
    ): Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T>>

    /**
     * Update one ClassicDmDiscussionEvent.
     * @param {ClassicDmDiscussionEventUpdateArgs} args - Arguments to update one ClassicDmDiscussionEvent.
     * @example
     * // Update one ClassicDmDiscussionEvent
     * const classicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClassicDmDiscussionEventUpdateArgs>(
      args: SelectSubset<T, ClassicDmDiscussionEventUpdateArgs>
    ): Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T>>

    /**
     * Delete zero or more ClassicDmDiscussionEvents.
     * @param {ClassicDmDiscussionEventDeleteManyArgs} args - Arguments to filter ClassicDmDiscussionEvents to delete.
     * @example
     * // Delete a few ClassicDmDiscussionEvents
     * const { count } = await prisma.classicDmDiscussionEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClassicDmDiscussionEventDeleteManyArgs>(
      args?: SelectSubset<T, ClassicDmDiscussionEventDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassicDmDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicDmDiscussionEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassicDmDiscussionEvents
     * const classicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClassicDmDiscussionEventUpdateManyArgs>(
      args: SelectSubset<T, ClassicDmDiscussionEventUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassicDmDiscussionEvent.
     * @param {ClassicDmDiscussionEventUpsertArgs} args - Arguments to update or create a ClassicDmDiscussionEvent.
     * @example
     * // Update or create a ClassicDmDiscussionEvent
     * const classicDmDiscussionEvent = await prisma.classicDmDiscussionEvent.upsert({
     *   create: {
     *     // ... data to create a ClassicDmDiscussionEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassicDmDiscussionEvent we want to update
     *   }
     * })
    **/
    upsert<T extends ClassicDmDiscussionEventUpsertArgs>(
      args: SelectSubset<T, ClassicDmDiscussionEventUpsertArgs>
    ): Prisma__ClassicDmDiscussionEventClient<ClassicDmDiscussionEventGetPayload<T>>

    /**
     * Count the number of ClassicDmDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicDmDiscussionEventCountArgs} args - Arguments to filter ClassicDmDiscussionEvents to count.
     * @example
     * // Count the number of ClassicDmDiscussionEvents
     * const count = await prisma.classicDmDiscussionEvent.count({
     *   where: {
     *     // ... the filter for the ClassicDmDiscussionEvents we want to count
     *   }
     * })
    **/
    count<T extends ClassicDmDiscussionEventCountArgs>(
      args?: Subset<T, ClassicDmDiscussionEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassicDmDiscussionEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassicDmDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicDmDiscussionEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassicDmDiscussionEventAggregateArgs>(args: Subset<T, ClassicDmDiscussionEventAggregateArgs>): Prisma.PrismaPromise<GetClassicDmDiscussionEventAggregateType<T>>

    /**
     * Group by ClassicDmDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicDmDiscussionEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassicDmDiscussionEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassicDmDiscussionEventGroupByArgs['orderBy'] }
        : { orderBy?: ClassicDmDiscussionEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassicDmDiscussionEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassicDmDiscussionEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassicDmDiscussionEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClassicDmDiscussionEventClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    dmDiscussionEvent<T extends ClassicDmDiscussionEvent$dmDiscussionEventArgs= {}>(args?: Subset<T, ClassicDmDiscussionEvent$dmDiscussionEventArgs>): Prisma__DmDiscussionEventClient<DmDiscussionEventGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ClassicDmDiscussionEvent base type for findUnique actions
   */
  export type ClassicDmDiscussionEventFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    /**
     * Filter, which ClassicDmDiscussionEvent to fetch.
     */
    where: ClassicDmDiscussionEventWhereUniqueInput
  }

  /**
   * ClassicDmDiscussionEvent findUnique
   */
  export interface ClassicDmDiscussionEventFindUniqueArgs extends ClassicDmDiscussionEventFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClassicDmDiscussionEvent findUniqueOrThrow
   */
  export type ClassicDmDiscussionEventFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    /**
     * Filter, which ClassicDmDiscussionEvent to fetch.
     */
    where: ClassicDmDiscussionEventWhereUniqueInput
  }


  /**
   * ClassicDmDiscussionEvent base type for findFirst actions
   */
  export type ClassicDmDiscussionEventFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    /**
     * Filter, which ClassicDmDiscussionEvent to fetch.
     */
    where?: ClassicDmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassicDmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ClassicDmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassicDmDiscussionEvents.
     */
    cursor?: ClassicDmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassicDmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassicDmDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassicDmDiscussionEvents.
     */
    distinct?: Enumerable<ClassicDmDiscussionEventScalarFieldEnum>
  }

  /**
   * ClassicDmDiscussionEvent findFirst
   */
  export interface ClassicDmDiscussionEventFindFirstArgs extends ClassicDmDiscussionEventFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClassicDmDiscussionEvent findFirstOrThrow
   */
  export type ClassicDmDiscussionEventFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    /**
     * Filter, which ClassicDmDiscussionEvent to fetch.
     */
    where?: ClassicDmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassicDmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ClassicDmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassicDmDiscussionEvents.
     */
    cursor?: ClassicDmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassicDmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassicDmDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassicDmDiscussionEvents.
     */
    distinct?: Enumerable<ClassicDmDiscussionEventScalarFieldEnum>
  }


  /**
   * ClassicDmDiscussionEvent findMany
   */
  export type ClassicDmDiscussionEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    /**
     * Filter, which ClassicDmDiscussionEvents to fetch.
     */
    where?: ClassicDmDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassicDmDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ClassicDmDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassicDmDiscussionEvents.
     */
    cursor?: ClassicDmDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassicDmDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassicDmDiscussionEvents.
     */
    skip?: number
    distinct?: Enumerable<ClassicDmDiscussionEventScalarFieldEnum>
  }


  /**
   * ClassicDmDiscussionEvent create
   */
  export type ClassicDmDiscussionEventCreateArgs = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    /**
     * The data needed to create a ClassicDmDiscussionEvent.
     */
    data: XOR<ClassicDmDiscussionEventCreateInput, ClassicDmDiscussionEventUncheckedCreateInput>
  }


  /**
   * ClassicDmDiscussionEvent createMany
   */
  export type ClassicDmDiscussionEventCreateManyArgs = {
    /**
     * The data used to create many ClassicDmDiscussionEvents.
     */
    data: Enumerable<ClassicDmDiscussionEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ClassicDmDiscussionEvent update
   */
  export type ClassicDmDiscussionEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    /**
     * The data needed to update a ClassicDmDiscussionEvent.
     */
    data: XOR<ClassicDmDiscussionEventUpdateInput, ClassicDmDiscussionEventUncheckedUpdateInput>
    /**
     * Choose, which ClassicDmDiscussionEvent to update.
     */
    where: ClassicDmDiscussionEventWhereUniqueInput
  }


  /**
   * ClassicDmDiscussionEvent updateMany
   */
  export type ClassicDmDiscussionEventUpdateManyArgs = {
    /**
     * The data used to update ClassicDmDiscussionEvents.
     */
    data: XOR<ClassicDmDiscussionEventUpdateManyMutationInput, ClassicDmDiscussionEventUncheckedUpdateManyInput>
    /**
     * Filter which ClassicDmDiscussionEvents to update
     */
    where?: ClassicDmDiscussionEventWhereInput
  }


  /**
   * ClassicDmDiscussionEvent upsert
   */
  export type ClassicDmDiscussionEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    /**
     * The filter to search for the ClassicDmDiscussionEvent to update in case it exists.
     */
    where: ClassicDmDiscussionEventWhereUniqueInput
    /**
     * In case the ClassicDmDiscussionEvent found by the `where` argument doesn't exist, create a new ClassicDmDiscussionEvent with this data.
     */
    create: XOR<ClassicDmDiscussionEventCreateInput, ClassicDmDiscussionEventUncheckedCreateInput>
    /**
     * In case the ClassicDmDiscussionEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassicDmDiscussionEventUpdateInput, ClassicDmDiscussionEventUncheckedUpdateInput>
  }


  /**
   * ClassicDmDiscussionEvent delete
   */
  export type ClassicDmDiscussionEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
    /**
     * Filter which ClassicDmDiscussionEvent to delete.
     */
    where: ClassicDmDiscussionEventWhereUniqueInput
  }


  /**
   * ClassicDmDiscussionEvent deleteMany
   */
  export type ClassicDmDiscussionEventDeleteManyArgs = {
    /**
     * Filter which ClassicDmDiscussionEvents to delete
     */
    where?: ClassicDmDiscussionEventWhereInput
  }


  /**
   * ClassicDmDiscussionEvent.dmDiscussionEvent
   */
  export type ClassicDmDiscussionEvent$dmDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the DmDiscussionEvent
     */
    select?: DmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DmDiscussionEventInclude | null
    where?: DmDiscussionEventWhereInput
  }


  /**
   * ClassicDmDiscussionEvent without action
   */
  export type ClassicDmDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ClassicDmDiscussionEvent
     */
    select?: ClassicDmDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicDmDiscussionEventInclude | null
  }



  /**
   * Model Chan
   */


  export type AggregateChan = {
    _count: ChanCountAggregateOutputType | null
    _min: ChanMinAggregateOutputType | null
    _max: ChanMaxAggregateOutputType | null
  }

  export type ChanMinAggregateOutputType = {
    id: string | null
    type: ChanType | null
    title: string | null
    password: string | null
    creationDate: Date | null
    modificationDate: Date | null
    ownerName: string | null
  }

  export type ChanMaxAggregateOutputType = {
    id: string | null
    type: ChanType | null
    title: string | null
    password: string | null
    creationDate: Date | null
    modificationDate: Date | null
    ownerName: string | null
  }

  export type ChanCountAggregateOutputType = {
    id: number
    type: number
    title: number
    password: number
    creationDate: number
    modificationDate: number
    ownerName: number
    _all: number
  }


  export type ChanMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    password?: true
    creationDate?: true
    modificationDate?: true
    ownerName?: true
  }

  export type ChanMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    password?: true
    creationDate?: true
    modificationDate?: true
    ownerName?: true
  }

  export type ChanCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    password?: true
    creationDate?: true
    modificationDate?: true
    ownerName?: true
    _all?: true
  }

  export type ChanAggregateArgs = {
    /**
     * Filter which Chan to aggregate.
     */
    where?: ChanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chans to fetch.
     */
    orderBy?: Enumerable<ChanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chans
    **/
    _count?: true | ChanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChanMaxAggregateInputType
  }

  export type GetChanAggregateType<T extends ChanAggregateArgs> = {
        [P in keyof T & keyof AggregateChan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChan[P]>
      : GetScalarType<T[P], AggregateChan[P]>
  }




  export type ChanGroupByArgs = {
    where?: ChanWhereInput
    orderBy?: Enumerable<ChanOrderByWithAggregationInput>
    by: ChanScalarFieldEnum[]
    having?: ChanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChanCountAggregateInputType | true
    _min?: ChanMinAggregateInputType
    _max?: ChanMaxAggregateInputType
  }


  export type ChanGroupByOutputType = {
    id: string
    type: ChanType
    title: string | null
    password: string | null
    creationDate: Date
    modificationDate: Date | null
    ownerName: string
    _count: ChanCountAggregateOutputType | null
    _min: ChanMinAggregateOutputType | null
    _max: ChanMaxAggregateOutputType | null
  }

  type GetChanGroupByPayload<T extends ChanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChanGroupByOutputType[P]>
            : GetScalarType<T[P], ChanGroupByOutputType[P]>
        }
      >
    >


  export type ChanSelect = {
    id?: boolean
    type?: boolean
    title?: boolean
    password?: boolean
    creationDate?: boolean
    modificationDate?: boolean
    ownerName?: boolean
    users?: boolean | Chan$usersArgs
    roles?: boolean | Chan$rolesArgs
    owner?: boolean | UserArgs
    mutedUsers?: boolean | Chan$mutedUsersArgs
    invitations?: boolean | Chan$invitationsArgs
    elements?: boolean | Chan$elementsArgs
    _count?: boolean | ChanCountOutputTypeArgs
  }


  export type ChanInclude = {
    users?: boolean | Chan$usersArgs
    roles?: boolean | Chan$rolesArgs
    owner?: boolean | UserArgs
    mutedUsers?: boolean | Chan$mutedUsersArgs
    invitations?: boolean | Chan$invitationsArgs
    elements?: boolean | Chan$elementsArgs
    _count?: boolean | ChanCountOutputTypeArgs
  }

  export type ChanGetPayload<S extends boolean | null | undefined | ChanArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Chan :
    S extends undefined ? never :
    S extends { include: any } & (ChanArgs | ChanFindManyArgs)
    ? Chan  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'roles' ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'owner' ? UserGetPayload<S['include'][P]> :
        P extends 'mutedUsers' ? Array < MutedUserChanGetPayload<S['include'][P]>>  :
        P extends 'invitations' ? Array < ChanInvitationGetPayload<S['include'][P]>>  :
        P extends 'elements' ? Array < ChanDiscussionElementGetPayload<S['include'][P]>>  :
        P extends '_count' ? ChanCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChanArgs | ChanFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'roles' ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'owner' ? UserGetPayload<S['select'][P]> :
        P extends 'mutedUsers' ? Array < MutedUserChanGetPayload<S['select'][P]>>  :
        P extends 'invitations' ? Array < ChanInvitationGetPayload<S['select'][P]>>  :
        P extends 'elements' ? Array < ChanDiscussionElementGetPayload<S['select'][P]>>  :
        P extends '_count' ? ChanCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Chan ? Chan[P] : never
  } 
      : Chan


  type ChanCountArgs = 
    Omit<ChanFindManyArgs, 'select' | 'include'> & {
      select?: ChanCountAggregateInputType | true
    }

  export interface ChanDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Chan that matches the filter.
     * @param {ChanFindUniqueArgs} args - Arguments to find a Chan
     * @example
     * // Get one Chan
     * const chan = await prisma.chan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Chan'> extends True ? Prisma__ChanClient<ChanGetPayload<T>> : Prisma__ChanClient<ChanGetPayload<T> | null, null>

    /**
     * Find one Chan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChanFindUniqueOrThrowArgs} args - Arguments to find a Chan
     * @example
     * // Get one Chan
     * const chan = await prisma.chan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChanFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChanFindUniqueOrThrowArgs>
    ): Prisma__ChanClient<ChanGetPayload<T>>

    /**
     * Find the first Chan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanFindFirstArgs} args - Arguments to find a Chan
     * @example
     * // Get one Chan
     * const chan = await prisma.chan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Chan'> extends True ? Prisma__ChanClient<ChanGetPayload<T>> : Prisma__ChanClient<ChanGetPayload<T> | null, null>

    /**
     * Find the first Chan that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanFindFirstOrThrowArgs} args - Arguments to find a Chan
     * @example
     * // Get one Chan
     * const chan = await prisma.chan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChanFindFirstOrThrowArgs>
    ): Prisma__ChanClient<ChanGetPayload<T>>

    /**
     * Find zero or more Chans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chans
     * const chans = await prisma.chan.findMany()
     * 
     * // Get first 10 Chans
     * const chans = await prisma.chan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chanWithIdOnly = await prisma.chan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChanFindManyArgs>(
      args?: SelectSubset<T, ChanFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChanGetPayload<T>>>

    /**
     * Create a Chan.
     * @param {ChanCreateArgs} args - Arguments to create a Chan.
     * @example
     * // Create one Chan
     * const Chan = await prisma.chan.create({
     *   data: {
     *     // ... data to create a Chan
     *   }
     * })
     * 
    **/
    create<T extends ChanCreateArgs>(
      args: SelectSubset<T, ChanCreateArgs>
    ): Prisma__ChanClient<ChanGetPayload<T>>

    /**
     * Create many Chans.
     *     @param {ChanCreateManyArgs} args - Arguments to create many Chans.
     *     @example
     *     // Create many Chans
     *     const chan = await prisma.chan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChanCreateManyArgs>(
      args?: SelectSubset<T, ChanCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chan.
     * @param {ChanDeleteArgs} args - Arguments to delete one Chan.
     * @example
     * // Delete one Chan
     * const Chan = await prisma.chan.delete({
     *   where: {
     *     // ... filter to delete one Chan
     *   }
     * })
     * 
    **/
    delete<T extends ChanDeleteArgs>(
      args: SelectSubset<T, ChanDeleteArgs>
    ): Prisma__ChanClient<ChanGetPayload<T>>

    /**
     * Update one Chan.
     * @param {ChanUpdateArgs} args - Arguments to update one Chan.
     * @example
     * // Update one Chan
     * const chan = await prisma.chan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChanUpdateArgs>(
      args: SelectSubset<T, ChanUpdateArgs>
    ): Prisma__ChanClient<ChanGetPayload<T>>

    /**
     * Delete zero or more Chans.
     * @param {ChanDeleteManyArgs} args - Arguments to filter Chans to delete.
     * @example
     * // Delete a few Chans
     * const { count } = await prisma.chan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChanDeleteManyArgs>(
      args?: SelectSubset<T, ChanDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chans
     * const chan = await prisma.chan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChanUpdateManyArgs>(
      args: SelectSubset<T, ChanUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chan.
     * @param {ChanUpsertArgs} args - Arguments to update or create a Chan.
     * @example
     * // Update or create a Chan
     * const chan = await prisma.chan.upsert({
     *   create: {
     *     // ... data to create a Chan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chan we want to update
     *   }
     * })
    **/
    upsert<T extends ChanUpsertArgs>(
      args: SelectSubset<T, ChanUpsertArgs>
    ): Prisma__ChanClient<ChanGetPayload<T>>

    /**
     * Count the number of Chans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanCountArgs} args - Arguments to filter Chans to count.
     * @example
     * // Count the number of Chans
     * const count = await prisma.chan.count({
     *   where: {
     *     // ... the filter for the Chans we want to count
     *   }
     * })
    **/
    count<T extends ChanCountArgs>(
      args?: Subset<T, ChanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChanAggregateArgs>(args: Subset<T, ChanAggregateArgs>): Prisma.PrismaPromise<GetChanAggregateType<T>>

    /**
     * Group by Chan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChanGroupByArgs['orderBy'] }
        : { orderBy?: ChanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Chan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChanClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends Chan$usersArgs= {}>(args?: Subset<T, Chan$usersArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    roles<T extends Chan$rolesArgs= {}>(args?: Subset<T, Chan$rolesArgs>): Prisma.PrismaPromise<Array<RoleGetPayload<T>>| Null>;

    owner<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    mutedUsers<T extends Chan$mutedUsersArgs= {}>(args?: Subset<T, Chan$mutedUsersArgs>): Prisma.PrismaPromise<Array<MutedUserChanGetPayload<T>>| Null>;

    invitations<T extends Chan$invitationsArgs= {}>(args?: Subset<T, Chan$invitationsArgs>): Prisma.PrismaPromise<Array<ChanInvitationGetPayload<T>>| Null>;

    elements<T extends Chan$elementsArgs= {}>(args?: Subset<T, Chan$elementsArgs>): Prisma.PrismaPromise<Array<ChanDiscussionElementGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Chan base type for findUnique actions
   */
  export type ChanFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    /**
     * Filter, which Chan to fetch.
     */
    where: ChanWhereUniqueInput
  }

  /**
   * Chan findUnique
   */
  export interface ChanFindUniqueArgs extends ChanFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chan findUniqueOrThrow
   */
  export type ChanFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    /**
     * Filter, which Chan to fetch.
     */
    where: ChanWhereUniqueInput
  }


  /**
   * Chan base type for findFirst actions
   */
  export type ChanFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    /**
     * Filter, which Chan to fetch.
     */
    where?: ChanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chans to fetch.
     */
    orderBy?: Enumerable<ChanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chans.
     */
    cursor?: ChanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chans.
     */
    distinct?: Enumerable<ChanScalarFieldEnum>
  }

  /**
   * Chan findFirst
   */
  export interface ChanFindFirstArgs extends ChanFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chan findFirstOrThrow
   */
  export type ChanFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    /**
     * Filter, which Chan to fetch.
     */
    where?: ChanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chans to fetch.
     */
    orderBy?: Enumerable<ChanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chans.
     */
    cursor?: ChanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chans.
     */
    distinct?: Enumerable<ChanScalarFieldEnum>
  }


  /**
   * Chan findMany
   */
  export type ChanFindManyArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    /**
     * Filter, which Chans to fetch.
     */
    where?: ChanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chans to fetch.
     */
    orderBy?: Enumerable<ChanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chans.
     */
    cursor?: ChanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chans.
     */
    skip?: number
    distinct?: Enumerable<ChanScalarFieldEnum>
  }


  /**
   * Chan create
   */
  export type ChanCreateArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    /**
     * The data needed to create a Chan.
     */
    data: XOR<ChanCreateInput, ChanUncheckedCreateInput>
  }


  /**
   * Chan createMany
   */
  export type ChanCreateManyArgs = {
    /**
     * The data used to create many Chans.
     */
    data: Enumerable<ChanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Chan update
   */
  export type ChanUpdateArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    /**
     * The data needed to update a Chan.
     */
    data: XOR<ChanUpdateInput, ChanUncheckedUpdateInput>
    /**
     * Choose, which Chan to update.
     */
    where: ChanWhereUniqueInput
  }


  /**
   * Chan updateMany
   */
  export type ChanUpdateManyArgs = {
    /**
     * The data used to update Chans.
     */
    data: XOR<ChanUpdateManyMutationInput, ChanUncheckedUpdateManyInput>
    /**
     * Filter which Chans to update
     */
    where?: ChanWhereInput
  }


  /**
   * Chan upsert
   */
  export type ChanUpsertArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    /**
     * The filter to search for the Chan to update in case it exists.
     */
    where: ChanWhereUniqueInput
    /**
     * In case the Chan found by the `where` argument doesn't exist, create a new Chan with this data.
     */
    create: XOR<ChanCreateInput, ChanUncheckedCreateInput>
    /**
     * In case the Chan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChanUpdateInput, ChanUncheckedUpdateInput>
  }


  /**
   * Chan delete
   */
  export type ChanDeleteArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
    /**
     * Filter which Chan to delete.
     */
    where: ChanWhereUniqueInput
  }


  /**
   * Chan deleteMany
   */
  export type ChanDeleteManyArgs = {
    /**
     * Filter which Chans to delete
     */
    where?: ChanWhereInput
  }


  /**
   * Chan.users
   */
  export type Chan$usersArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Chan.roles
   */
  export type Chan$rolesArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Chan.mutedUsers
   */
  export type Chan$mutedUsersArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    where?: MutedUserChanWhereInput
    orderBy?: Enumerable<MutedUserChanOrderByWithRelationInput>
    cursor?: MutedUserChanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MutedUserChanScalarFieldEnum>
  }


  /**
   * Chan.invitations
   */
  export type Chan$invitationsArgs = {
    /**
     * Select specific fields to fetch from the ChanInvitation
     */
    select?: ChanInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInvitationInclude | null
    where?: ChanInvitationWhereInput
    orderBy?: Enumerable<ChanInvitationOrderByWithRelationInput>
    cursor?: ChanInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanInvitationScalarFieldEnum>
  }


  /**
   * Chan.elements
   */
  export type Chan$elementsArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    where?: ChanDiscussionElementWhereInput
    orderBy?: Enumerable<ChanDiscussionElementOrderByWithRelationInput>
    cursor?: ChanDiscussionElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanDiscussionElementScalarFieldEnum>
  }


  /**
   * Chan without action
   */
  export type ChanArgs = {
    /**
     * Select specific fields to fetch from the Chan
     */
    select?: ChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanInclude | null
  }



  /**
   * Model MutedUserChan
   */


  export type AggregateMutedUserChan = {
    _count: MutedUserChanCountAggregateOutputType | null
    _min: MutedUserChanMinAggregateOutputType | null
    _max: MutedUserChanMaxAggregateOutputType | null
  }

  export type MutedUserChanMinAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    untilDate: Date | null
    mutedUserName: string | null
    chanId: string | null
  }

  export type MutedUserChanMaxAggregateOutputType = {
    id: string | null
    creationDate: Date | null
    untilDate: Date | null
    mutedUserName: string | null
    chanId: string | null
  }

  export type MutedUserChanCountAggregateOutputType = {
    id: number
    creationDate: number
    untilDate: number
    mutedUserName: number
    chanId: number
    _all: number
  }


  export type MutedUserChanMinAggregateInputType = {
    id?: true
    creationDate?: true
    untilDate?: true
    mutedUserName?: true
    chanId?: true
  }

  export type MutedUserChanMaxAggregateInputType = {
    id?: true
    creationDate?: true
    untilDate?: true
    mutedUserName?: true
    chanId?: true
  }

  export type MutedUserChanCountAggregateInputType = {
    id?: true
    creationDate?: true
    untilDate?: true
    mutedUserName?: true
    chanId?: true
    _all?: true
  }

  export type MutedUserChanAggregateArgs = {
    /**
     * Filter which MutedUserChan to aggregate.
     */
    where?: MutedUserChanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MutedUserChans to fetch.
     */
    orderBy?: Enumerable<MutedUserChanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MutedUserChanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MutedUserChans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MutedUserChans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MutedUserChans
    **/
    _count?: true | MutedUserChanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MutedUserChanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MutedUserChanMaxAggregateInputType
  }

  export type GetMutedUserChanAggregateType<T extends MutedUserChanAggregateArgs> = {
        [P in keyof T & keyof AggregateMutedUserChan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMutedUserChan[P]>
      : GetScalarType<T[P], AggregateMutedUserChan[P]>
  }




  export type MutedUserChanGroupByArgs = {
    where?: MutedUserChanWhereInput
    orderBy?: Enumerable<MutedUserChanOrderByWithAggregationInput>
    by: MutedUserChanScalarFieldEnum[]
    having?: MutedUserChanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MutedUserChanCountAggregateInputType | true
    _min?: MutedUserChanMinAggregateInputType
    _max?: MutedUserChanMaxAggregateInputType
  }


  export type MutedUserChanGroupByOutputType = {
    id: string
    creationDate: Date
    untilDate: Date | null
    mutedUserName: string
    chanId: string
    _count: MutedUserChanCountAggregateOutputType | null
    _min: MutedUserChanMinAggregateOutputType | null
    _max: MutedUserChanMaxAggregateOutputType | null
  }

  type GetMutedUserChanGroupByPayload<T extends MutedUserChanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MutedUserChanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MutedUserChanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MutedUserChanGroupByOutputType[P]>
            : GetScalarType<T[P], MutedUserChanGroupByOutputType[P]>
        }
      >
    >


  export type MutedUserChanSelect = {
    id?: boolean
    creationDate?: boolean
    untilDate?: boolean
    mutedUserName?: boolean
    chanId?: boolean
    mutedUser?: boolean | UserArgs
    chan?: boolean | ChanArgs
  }


  export type MutedUserChanInclude = {
    mutedUser?: boolean | UserArgs
    chan?: boolean | ChanArgs
  }

  export type MutedUserChanGetPayload<S extends boolean | null | undefined | MutedUserChanArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MutedUserChan :
    S extends undefined ? never :
    S extends { include: any } & (MutedUserChanArgs | MutedUserChanFindManyArgs)
    ? MutedUserChan  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'mutedUser' ? UserGetPayload<S['include'][P]> :
        P extends 'chan' ? ChanGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MutedUserChanArgs | MutedUserChanFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'mutedUser' ? UserGetPayload<S['select'][P]> :
        P extends 'chan' ? ChanGetPayload<S['select'][P]> :  P extends keyof MutedUserChan ? MutedUserChan[P] : never
  } 
      : MutedUserChan


  type MutedUserChanCountArgs = 
    Omit<MutedUserChanFindManyArgs, 'select' | 'include'> & {
      select?: MutedUserChanCountAggregateInputType | true
    }

  export interface MutedUserChanDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MutedUserChan that matches the filter.
     * @param {MutedUserChanFindUniqueArgs} args - Arguments to find a MutedUserChan
     * @example
     * // Get one MutedUserChan
     * const mutedUserChan = await prisma.mutedUserChan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MutedUserChanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MutedUserChanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MutedUserChan'> extends True ? Prisma__MutedUserChanClient<MutedUserChanGetPayload<T>> : Prisma__MutedUserChanClient<MutedUserChanGetPayload<T> | null, null>

    /**
     * Find one MutedUserChan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MutedUserChanFindUniqueOrThrowArgs} args - Arguments to find a MutedUserChan
     * @example
     * // Get one MutedUserChan
     * const mutedUserChan = await prisma.mutedUserChan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MutedUserChanFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MutedUserChanFindUniqueOrThrowArgs>
    ): Prisma__MutedUserChanClient<MutedUserChanGetPayload<T>>

    /**
     * Find the first MutedUserChan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutedUserChanFindFirstArgs} args - Arguments to find a MutedUserChan
     * @example
     * // Get one MutedUserChan
     * const mutedUserChan = await prisma.mutedUserChan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MutedUserChanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MutedUserChanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MutedUserChan'> extends True ? Prisma__MutedUserChanClient<MutedUserChanGetPayload<T>> : Prisma__MutedUserChanClient<MutedUserChanGetPayload<T> | null, null>

    /**
     * Find the first MutedUserChan that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutedUserChanFindFirstOrThrowArgs} args - Arguments to find a MutedUserChan
     * @example
     * // Get one MutedUserChan
     * const mutedUserChan = await prisma.mutedUserChan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MutedUserChanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MutedUserChanFindFirstOrThrowArgs>
    ): Prisma__MutedUserChanClient<MutedUserChanGetPayload<T>>

    /**
     * Find zero or more MutedUserChans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutedUserChanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MutedUserChans
     * const mutedUserChans = await prisma.mutedUserChan.findMany()
     * 
     * // Get first 10 MutedUserChans
     * const mutedUserChans = await prisma.mutedUserChan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mutedUserChanWithIdOnly = await prisma.mutedUserChan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MutedUserChanFindManyArgs>(
      args?: SelectSubset<T, MutedUserChanFindManyArgs>
    ): Prisma.PrismaPromise<Array<MutedUserChanGetPayload<T>>>

    /**
     * Create a MutedUserChan.
     * @param {MutedUserChanCreateArgs} args - Arguments to create a MutedUserChan.
     * @example
     * // Create one MutedUserChan
     * const MutedUserChan = await prisma.mutedUserChan.create({
     *   data: {
     *     // ... data to create a MutedUserChan
     *   }
     * })
     * 
    **/
    create<T extends MutedUserChanCreateArgs>(
      args: SelectSubset<T, MutedUserChanCreateArgs>
    ): Prisma__MutedUserChanClient<MutedUserChanGetPayload<T>>

    /**
     * Create many MutedUserChans.
     *     @param {MutedUserChanCreateManyArgs} args - Arguments to create many MutedUserChans.
     *     @example
     *     // Create many MutedUserChans
     *     const mutedUserChan = await prisma.mutedUserChan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MutedUserChanCreateManyArgs>(
      args?: SelectSubset<T, MutedUserChanCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MutedUserChan.
     * @param {MutedUserChanDeleteArgs} args - Arguments to delete one MutedUserChan.
     * @example
     * // Delete one MutedUserChan
     * const MutedUserChan = await prisma.mutedUserChan.delete({
     *   where: {
     *     // ... filter to delete one MutedUserChan
     *   }
     * })
     * 
    **/
    delete<T extends MutedUserChanDeleteArgs>(
      args: SelectSubset<T, MutedUserChanDeleteArgs>
    ): Prisma__MutedUserChanClient<MutedUserChanGetPayload<T>>

    /**
     * Update one MutedUserChan.
     * @param {MutedUserChanUpdateArgs} args - Arguments to update one MutedUserChan.
     * @example
     * // Update one MutedUserChan
     * const mutedUserChan = await prisma.mutedUserChan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MutedUserChanUpdateArgs>(
      args: SelectSubset<T, MutedUserChanUpdateArgs>
    ): Prisma__MutedUserChanClient<MutedUserChanGetPayload<T>>

    /**
     * Delete zero or more MutedUserChans.
     * @param {MutedUserChanDeleteManyArgs} args - Arguments to filter MutedUserChans to delete.
     * @example
     * // Delete a few MutedUserChans
     * const { count } = await prisma.mutedUserChan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MutedUserChanDeleteManyArgs>(
      args?: SelectSubset<T, MutedUserChanDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MutedUserChans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutedUserChanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MutedUserChans
     * const mutedUserChan = await prisma.mutedUserChan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MutedUserChanUpdateManyArgs>(
      args: SelectSubset<T, MutedUserChanUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MutedUserChan.
     * @param {MutedUserChanUpsertArgs} args - Arguments to update or create a MutedUserChan.
     * @example
     * // Update or create a MutedUserChan
     * const mutedUserChan = await prisma.mutedUserChan.upsert({
     *   create: {
     *     // ... data to create a MutedUserChan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MutedUserChan we want to update
     *   }
     * })
    **/
    upsert<T extends MutedUserChanUpsertArgs>(
      args: SelectSubset<T, MutedUserChanUpsertArgs>
    ): Prisma__MutedUserChanClient<MutedUserChanGetPayload<T>>

    /**
     * Count the number of MutedUserChans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutedUserChanCountArgs} args - Arguments to filter MutedUserChans to count.
     * @example
     * // Count the number of MutedUserChans
     * const count = await prisma.mutedUserChan.count({
     *   where: {
     *     // ... the filter for the MutedUserChans we want to count
     *   }
     * })
    **/
    count<T extends MutedUserChanCountArgs>(
      args?: Subset<T, MutedUserChanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MutedUserChanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MutedUserChan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutedUserChanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MutedUserChanAggregateArgs>(args: Subset<T, MutedUserChanAggregateArgs>): Prisma.PrismaPromise<GetMutedUserChanAggregateType<T>>

    /**
     * Group by MutedUserChan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutedUserChanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MutedUserChanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MutedUserChanGroupByArgs['orderBy'] }
        : { orderBy?: MutedUserChanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MutedUserChanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMutedUserChanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MutedUserChan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MutedUserChanClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    mutedUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    chan<T extends ChanArgs= {}>(args?: Subset<T, ChanArgs>): Prisma__ChanClient<ChanGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MutedUserChan base type for findUnique actions
   */
  export type MutedUserChanFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    /**
     * Filter, which MutedUserChan to fetch.
     */
    where: MutedUserChanWhereUniqueInput
  }

  /**
   * MutedUserChan findUnique
   */
  export interface MutedUserChanFindUniqueArgs extends MutedUserChanFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MutedUserChan findUniqueOrThrow
   */
  export type MutedUserChanFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    /**
     * Filter, which MutedUserChan to fetch.
     */
    where: MutedUserChanWhereUniqueInput
  }


  /**
   * MutedUserChan base type for findFirst actions
   */
  export type MutedUserChanFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    /**
     * Filter, which MutedUserChan to fetch.
     */
    where?: MutedUserChanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MutedUserChans to fetch.
     */
    orderBy?: Enumerable<MutedUserChanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MutedUserChans.
     */
    cursor?: MutedUserChanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MutedUserChans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MutedUserChans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MutedUserChans.
     */
    distinct?: Enumerable<MutedUserChanScalarFieldEnum>
  }

  /**
   * MutedUserChan findFirst
   */
  export interface MutedUserChanFindFirstArgs extends MutedUserChanFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MutedUserChan findFirstOrThrow
   */
  export type MutedUserChanFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    /**
     * Filter, which MutedUserChan to fetch.
     */
    where?: MutedUserChanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MutedUserChans to fetch.
     */
    orderBy?: Enumerable<MutedUserChanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MutedUserChans.
     */
    cursor?: MutedUserChanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MutedUserChans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MutedUserChans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MutedUserChans.
     */
    distinct?: Enumerable<MutedUserChanScalarFieldEnum>
  }


  /**
   * MutedUserChan findMany
   */
  export type MutedUserChanFindManyArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    /**
     * Filter, which MutedUserChans to fetch.
     */
    where?: MutedUserChanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MutedUserChans to fetch.
     */
    orderBy?: Enumerable<MutedUserChanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MutedUserChans.
     */
    cursor?: MutedUserChanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MutedUserChans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MutedUserChans.
     */
    skip?: number
    distinct?: Enumerable<MutedUserChanScalarFieldEnum>
  }


  /**
   * MutedUserChan create
   */
  export type MutedUserChanCreateArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    /**
     * The data needed to create a MutedUserChan.
     */
    data: XOR<MutedUserChanCreateInput, MutedUserChanUncheckedCreateInput>
  }


  /**
   * MutedUserChan createMany
   */
  export type MutedUserChanCreateManyArgs = {
    /**
     * The data used to create many MutedUserChans.
     */
    data: Enumerable<MutedUserChanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MutedUserChan update
   */
  export type MutedUserChanUpdateArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    /**
     * The data needed to update a MutedUserChan.
     */
    data: XOR<MutedUserChanUpdateInput, MutedUserChanUncheckedUpdateInput>
    /**
     * Choose, which MutedUserChan to update.
     */
    where: MutedUserChanWhereUniqueInput
  }


  /**
   * MutedUserChan updateMany
   */
  export type MutedUserChanUpdateManyArgs = {
    /**
     * The data used to update MutedUserChans.
     */
    data: XOR<MutedUserChanUpdateManyMutationInput, MutedUserChanUncheckedUpdateManyInput>
    /**
     * Filter which MutedUserChans to update
     */
    where?: MutedUserChanWhereInput
  }


  /**
   * MutedUserChan upsert
   */
  export type MutedUserChanUpsertArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    /**
     * The filter to search for the MutedUserChan to update in case it exists.
     */
    where: MutedUserChanWhereUniqueInput
    /**
     * In case the MutedUserChan found by the `where` argument doesn't exist, create a new MutedUserChan with this data.
     */
    create: XOR<MutedUserChanCreateInput, MutedUserChanUncheckedCreateInput>
    /**
     * In case the MutedUserChan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MutedUserChanUpdateInput, MutedUserChanUncheckedUpdateInput>
  }


  /**
   * MutedUserChan delete
   */
  export type MutedUserChanDeleteArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
    /**
     * Filter which MutedUserChan to delete.
     */
    where: MutedUserChanWhereUniqueInput
  }


  /**
   * MutedUserChan deleteMany
   */
  export type MutedUserChanDeleteManyArgs = {
    /**
     * Filter which MutedUserChans to delete
     */
    where?: MutedUserChanWhereInput
  }


  /**
   * MutedUserChan without action
   */
  export type MutedUserChanArgs = {
    /**
     * Select specific fields to fetch from the MutedUserChan
     */
    select?: MutedUserChanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MutedUserChanInclude | null
  }



  /**
   * Model ChanDiscussionElement
   */


  export type AggregateChanDiscussionElement = {
    _count: ChanDiscussionElementCountAggregateOutputType | null
    _min: ChanDiscussionElementMinAggregateOutputType | null
    _max: ChanDiscussionElementMaxAggregateOutputType | null
  }

  export type ChanDiscussionElementMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    eventId: string | null
    authorName: string | null
    creationDate: Date | null
    modificationDate: Date | null
    chanId: string | null
  }

  export type ChanDiscussionElementMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    eventId: string | null
    authorName: string | null
    creationDate: Date | null
    modificationDate: Date | null
    chanId: string | null
  }

  export type ChanDiscussionElementCountAggregateOutputType = {
    id: number
    messageId: number
    eventId: number
    authorName: number
    creationDate: number
    modificationDate: number
    chanId: number
    _all: number
  }


  export type ChanDiscussionElementMinAggregateInputType = {
    id?: true
    messageId?: true
    eventId?: true
    authorName?: true
    creationDate?: true
    modificationDate?: true
    chanId?: true
  }

  export type ChanDiscussionElementMaxAggregateInputType = {
    id?: true
    messageId?: true
    eventId?: true
    authorName?: true
    creationDate?: true
    modificationDate?: true
    chanId?: true
  }

  export type ChanDiscussionElementCountAggregateInputType = {
    id?: true
    messageId?: true
    eventId?: true
    authorName?: true
    creationDate?: true
    modificationDate?: true
    chanId?: true
    _all?: true
  }

  export type ChanDiscussionElementAggregateArgs = {
    /**
     * Filter which ChanDiscussionElement to aggregate.
     */
    where?: ChanDiscussionElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionElements to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChanDiscussionElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChanDiscussionElements
    **/
    _count?: true | ChanDiscussionElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChanDiscussionElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChanDiscussionElementMaxAggregateInputType
  }

  export type GetChanDiscussionElementAggregateType<T extends ChanDiscussionElementAggregateArgs> = {
        [P in keyof T & keyof AggregateChanDiscussionElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChanDiscussionElement[P]>
      : GetScalarType<T[P], AggregateChanDiscussionElement[P]>
  }




  export type ChanDiscussionElementGroupByArgs = {
    where?: ChanDiscussionElementWhereInput
    orderBy?: Enumerable<ChanDiscussionElementOrderByWithAggregationInput>
    by: ChanDiscussionElementScalarFieldEnum[]
    having?: ChanDiscussionElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChanDiscussionElementCountAggregateInputType | true
    _min?: ChanDiscussionElementMinAggregateInputType
    _max?: ChanDiscussionElementMaxAggregateInputType
  }


  export type ChanDiscussionElementGroupByOutputType = {
    id: string
    messageId: string | null
    eventId: string | null
    authorName: string
    creationDate: Date
    modificationDate: Date | null
    chanId: string
    _count: ChanDiscussionElementCountAggregateOutputType | null
    _min: ChanDiscussionElementMinAggregateOutputType | null
    _max: ChanDiscussionElementMaxAggregateOutputType | null
  }

  type GetChanDiscussionElementGroupByPayload<T extends ChanDiscussionElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChanDiscussionElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChanDiscussionElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChanDiscussionElementGroupByOutputType[P]>
            : GetScalarType<T[P], ChanDiscussionElementGroupByOutputType[P]>
        }
      >
    >


  export type ChanDiscussionElementSelect = {
    id?: boolean
    messageId?: boolean
    eventId?: boolean
    authorName?: boolean
    creationDate?: boolean
    modificationDate?: boolean
    chanId?: boolean
    message?: boolean | ChanDiscussionElement$messageArgs
    event?: boolean | ChanDiscussionElement$eventArgs
    relatedOf?: boolean | ChanDiscussionElement$relatedOfArgs
    author?: boolean | UserArgs
    chan?: boolean | ChanArgs
    _count?: boolean | ChanDiscussionElementCountOutputTypeArgs
  }


  export type ChanDiscussionElementInclude = {
    message?: boolean | ChanDiscussionElement$messageArgs
    event?: boolean | ChanDiscussionElement$eventArgs
    relatedOf?: boolean | ChanDiscussionElement$relatedOfArgs
    author?: boolean | UserArgs
    chan?: boolean | ChanArgs
    _count?: boolean | ChanDiscussionElementCountOutputTypeArgs
  }

  export type ChanDiscussionElementGetPayload<S extends boolean | null | undefined | ChanDiscussionElementArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChanDiscussionElement :
    S extends undefined ? never :
    S extends { include: any } & (ChanDiscussionElementArgs | ChanDiscussionElementFindManyArgs)
    ? ChanDiscussionElement  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'message' ? ChanDiscussionMessageGetPayload<S['include'][P]> | null :
        P extends 'event' ? ChanDiscussionEventGetPayload<S['include'][P]> | null :
        P extends 'relatedOf' ? Array < ChanDiscussionMessageGetPayload<S['include'][P]>>  :
        P extends 'author' ? UserGetPayload<S['include'][P]> :
        P extends 'chan' ? ChanGetPayload<S['include'][P]> :
        P extends '_count' ? ChanDiscussionElementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChanDiscussionElementArgs | ChanDiscussionElementFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'message' ? ChanDiscussionMessageGetPayload<S['select'][P]> | null :
        P extends 'event' ? ChanDiscussionEventGetPayload<S['select'][P]> | null :
        P extends 'relatedOf' ? Array < ChanDiscussionMessageGetPayload<S['select'][P]>>  :
        P extends 'author' ? UserGetPayload<S['select'][P]> :
        P extends 'chan' ? ChanGetPayload<S['select'][P]> :
        P extends '_count' ? ChanDiscussionElementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ChanDiscussionElement ? ChanDiscussionElement[P] : never
  } 
      : ChanDiscussionElement


  type ChanDiscussionElementCountArgs = 
    Omit<ChanDiscussionElementFindManyArgs, 'select' | 'include'> & {
      select?: ChanDiscussionElementCountAggregateInputType | true
    }

  export interface ChanDiscussionElementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChanDiscussionElement that matches the filter.
     * @param {ChanDiscussionElementFindUniqueArgs} args - Arguments to find a ChanDiscussionElement
     * @example
     * // Get one ChanDiscussionElement
     * const chanDiscussionElement = await prisma.chanDiscussionElement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChanDiscussionElementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChanDiscussionElementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChanDiscussionElement'> extends True ? Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T>> : Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T> | null, null>

    /**
     * Find one ChanDiscussionElement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChanDiscussionElementFindUniqueOrThrowArgs} args - Arguments to find a ChanDiscussionElement
     * @example
     * // Get one ChanDiscussionElement
     * const chanDiscussionElement = await prisma.chanDiscussionElement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChanDiscussionElementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChanDiscussionElementFindUniqueOrThrowArgs>
    ): Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T>>

    /**
     * Find the first ChanDiscussionElement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionElementFindFirstArgs} args - Arguments to find a ChanDiscussionElement
     * @example
     * // Get one ChanDiscussionElement
     * const chanDiscussionElement = await prisma.chanDiscussionElement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChanDiscussionElementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChanDiscussionElementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChanDiscussionElement'> extends True ? Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T>> : Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T> | null, null>

    /**
     * Find the first ChanDiscussionElement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionElementFindFirstOrThrowArgs} args - Arguments to find a ChanDiscussionElement
     * @example
     * // Get one ChanDiscussionElement
     * const chanDiscussionElement = await prisma.chanDiscussionElement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChanDiscussionElementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChanDiscussionElementFindFirstOrThrowArgs>
    ): Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T>>

    /**
     * Find zero or more ChanDiscussionElements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionElementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChanDiscussionElements
     * const chanDiscussionElements = await prisma.chanDiscussionElement.findMany()
     * 
     * // Get first 10 ChanDiscussionElements
     * const chanDiscussionElements = await prisma.chanDiscussionElement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chanDiscussionElementWithIdOnly = await prisma.chanDiscussionElement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChanDiscussionElementFindManyArgs>(
      args?: SelectSubset<T, ChanDiscussionElementFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChanDiscussionElementGetPayload<T>>>

    /**
     * Create a ChanDiscussionElement.
     * @param {ChanDiscussionElementCreateArgs} args - Arguments to create a ChanDiscussionElement.
     * @example
     * // Create one ChanDiscussionElement
     * const ChanDiscussionElement = await prisma.chanDiscussionElement.create({
     *   data: {
     *     // ... data to create a ChanDiscussionElement
     *   }
     * })
     * 
    **/
    create<T extends ChanDiscussionElementCreateArgs>(
      args: SelectSubset<T, ChanDiscussionElementCreateArgs>
    ): Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T>>

    /**
     * Create many ChanDiscussionElements.
     *     @param {ChanDiscussionElementCreateManyArgs} args - Arguments to create many ChanDiscussionElements.
     *     @example
     *     // Create many ChanDiscussionElements
     *     const chanDiscussionElement = await prisma.chanDiscussionElement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChanDiscussionElementCreateManyArgs>(
      args?: SelectSubset<T, ChanDiscussionElementCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChanDiscussionElement.
     * @param {ChanDiscussionElementDeleteArgs} args - Arguments to delete one ChanDiscussionElement.
     * @example
     * // Delete one ChanDiscussionElement
     * const ChanDiscussionElement = await prisma.chanDiscussionElement.delete({
     *   where: {
     *     // ... filter to delete one ChanDiscussionElement
     *   }
     * })
     * 
    **/
    delete<T extends ChanDiscussionElementDeleteArgs>(
      args: SelectSubset<T, ChanDiscussionElementDeleteArgs>
    ): Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T>>

    /**
     * Update one ChanDiscussionElement.
     * @param {ChanDiscussionElementUpdateArgs} args - Arguments to update one ChanDiscussionElement.
     * @example
     * // Update one ChanDiscussionElement
     * const chanDiscussionElement = await prisma.chanDiscussionElement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChanDiscussionElementUpdateArgs>(
      args: SelectSubset<T, ChanDiscussionElementUpdateArgs>
    ): Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T>>

    /**
     * Delete zero or more ChanDiscussionElements.
     * @param {ChanDiscussionElementDeleteManyArgs} args - Arguments to filter ChanDiscussionElements to delete.
     * @example
     * // Delete a few ChanDiscussionElements
     * const { count } = await prisma.chanDiscussionElement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChanDiscussionElementDeleteManyArgs>(
      args?: SelectSubset<T, ChanDiscussionElementDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChanDiscussionElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChanDiscussionElements
     * const chanDiscussionElement = await prisma.chanDiscussionElement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChanDiscussionElementUpdateManyArgs>(
      args: SelectSubset<T, ChanDiscussionElementUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChanDiscussionElement.
     * @param {ChanDiscussionElementUpsertArgs} args - Arguments to update or create a ChanDiscussionElement.
     * @example
     * // Update or create a ChanDiscussionElement
     * const chanDiscussionElement = await prisma.chanDiscussionElement.upsert({
     *   create: {
     *     // ... data to create a ChanDiscussionElement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChanDiscussionElement we want to update
     *   }
     * })
    **/
    upsert<T extends ChanDiscussionElementUpsertArgs>(
      args: SelectSubset<T, ChanDiscussionElementUpsertArgs>
    ): Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T>>

    /**
     * Count the number of ChanDiscussionElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionElementCountArgs} args - Arguments to filter ChanDiscussionElements to count.
     * @example
     * // Count the number of ChanDiscussionElements
     * const count = await prisma.chanDiscussionElement.count({
     *   where: {
     *     // ... the filter for the ChanDiscussionElements we want to count
     *   }
     * })
    **/
    count<T extends ChanDiscussionElementCountArgs>(
      args?: Subset<T, ChanDiscussionElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChanDiscussionElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChanDiscussionElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChanDiscussionElementAggregateArgs>(args: Subset<T, ChanDiscussionElementAggregateArgs>): Prisma.PrismaPromise<GetChanDiscussionElementAggregateType<T>>

    /**
     * Group by ChanDiscussionElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChanDiscussionElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChanDiscussionElementGroupByArgs['orderBy'] }
        : { orderBy?: ChanDiscussionElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChanDiscussionElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChanDiscussionElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChanDiscussionElement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChanDiscussionElementClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    message<T extends ChanDiscussionElement$messageArgs= {}>(args?: Subset<T, ChanDiscussionElement$messageArgs>): Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T> | Null>;

    event<T extends ChanDiscussionElement$eventArgs= {}>(args?: Subset<T, ChanDiscussionElement$eventArgs>): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T> | Null>;

    relatedOf<T extends ChanDiscussionElement$relatedOfArgs= {}>(args?: Subset<T, ChanDiscussionElement$relatedOfArgs>): Prisma.PrismaPromise<Array<ChanDiscussionMessageGetPayload<T>>| Null>;

    author<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    chan<T extends ChanArgs= {}>(args?: Subset<T, ChanArgs>): Prisma__ChanClient<ChanGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChanDiscussionElement base type for findUnique actions
   */
  export type ChanDiscussionElementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    /**
     * Filter, which ChanDiscussionElement to fetch.
     */
    where: ChanDiscussionElementWhereUniqueInput
  }

  /**
   * ChanDiscussionElement findUnique
   */
  export interface ChanDiscussionElementFindUniqueArgs extends ChanDiscussionElementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanDiscussionElement findUniqueOrThrow
   */
  export type ChanDiscussionElementFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    /**
     * Filter, which ChanDiscussionElement to fetch.
     */
    where: ChanDiscussionElementWhereUniqueInput
  }


  /**
   * ChanDiscussionElement base type for findFirst actions
   */
  export type ChanDiscussionElementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    /**
     * Filter, which ChanDiscussionElement to fetch.
     */
    where?: ChanDiscussionElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionElements to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanDiscussionElements.
     */
    cursor?: ChanDiscussionElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanDiscussionElements.
     */
    distinct?: Enumerable<ChanDiscussionElementScalarFieldEnum>
  }

  /**
   * ChanDiscussionElement findFirst
   */
  export interface ChanDiscussionElementFindFirstArgs extends ChanDiscussionElementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanDiscussionElement findFirstOrThrow
   */
  export type ChanDiscussionElementFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    /**
     * Filter, which ChanDiscussionElement to fetch.
     */
    where?: ChanDiscussionElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionElements to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanDiscussionElements.
     */
    cursor?: ChanDiscussionElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanDiscussionElements.
     */
    distinct?: Enumerable<ChanDiscussionElementScalarFieldEnum>
  }


  /**
   * ChanDiscussionElement findMany
   */
  export type ChanDiscussionElementFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    /**
     * Filter, which ChanDiscussionElements to fetch.
     */
    where?: ChanDiscussionElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionElements to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChanDiscussionElements.
     */
    cursor?: ChanDiscussionElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionElements.
     */
    skip?: number
    distinct?: Enumerable<ChanDiscussionElementScalarFieldEnum>
  }


  /**
   * ChanDiscussionElement create
   */
  export type ChanDiscussionElementCreateArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    /**
     * The data needed to create a ChanDiscussionElement.
     */
    data: XOR<ChanDiscussionElementCreateInput, ChanDiscussionElementUncheckedCreateInput>
  }


  /**
   * ChanDiscussionElement createMany
   */
  export type ChanDiscussionElementCreateManyArgs = {
    /**
     * The data used to create many ChanDiscussionElements.
     */
    data: Enumerable<ChanDiscussionElementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChanDiscussionElement update
   */
  export type ChanDiscussionElementUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    /**
     * The data needed to update a ChanDiscussionElement.
     */
    data: XOR<ChanDiscussionElementUpdateInput, ChanDiscussionElementUncheckedUpdateInput>
    /**
     * Choose, which ChanDiscussionElement to update.
     */
    where: ChanDiscussionElementWhereUniqueInput
  }


  /**
   * ChanDiscussionElement updateMany
   */
  export type ChanDiscussionElementUpdateManyArgs = {
    /**
     * The data used to update ChanDiscussionElements.
     */
    data: XOR<ChanDiscussionElementUpdateManyMutationInput, ChanDiscussionElementUncheckedUpdateManyInput>
    /**
     * Filter which ChanDiscussionElements to update
     */
    where?: ChanDiscussionElementWhereInput
  }


  /**
   * ChanDiscussionElement upsert
   */
  export type ChanDiscussionElementUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    /**
     * The filter to search for the ChanDiscussionElement to update in case it exists.
     */
    where: ChanDiscussionElementWhereUniqueInput
    /**
     * In case the ChanDiscussionElement found by the `where` argument doesn't exist, create a new ChanDiscussionElement with this data.
     */
    create: XOR<ChanDiscussionElementCreateInput, ChanDiscussionElementUncheckedCreateInput>
    /**
     * In case the ChanDiscussionElement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChanDiscussionElementUpdateInput, ChanDiscussionElementUncheckedUpdateInput>
  }


  /**
   * ChanDiscussionElement delete
   */
  export type ChanDiscussionElementDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    /**
     * Filter which ChanDiscussionElement to delete.
     */
    where: ChanDiscussionElementWhereUniqueInput
  }


  /**
   * ChanDiscussionElement deleteMany
   */
  export type ChanDiscussionElementDeleteManyArgs = {
    /**
     * Filter which ChanDiscussionElements to delete
     */
    where?: ChanDiscussionElementWhereInput
  }


  /**
   * ChanDiscussionElement.message
   */
  export type ChanDiscussionElement$messageArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    where?: ChanDiscussionMessageWhereInput
  }


  /**
   * ChanDiscussionElement.event
   */
  export type ChanDiscussionElement$eventArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    where?: ChanDiscussionEventWhereInput
  }


  /**
   * ChanDiscussionElement.relatedOf
   */
  export type ChanDiscussionElement$relatedOfArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    where?: ChanDiscussionMessageWhereInput
    orderBy?: Enumerable<ChanDiscussionMessageOrderByWithRelationInput>
    cursor?: ChanDiscussionMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChanDiscussionMessageScalarFieldEnum>
  }


  /**
   * ChanDiscussionElement without action
   */
  export type ChanDiscussionElementArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
  }



  /**
   * Model ChanDiscussionMessage
   */


  export type AggregateChanDiscussionMessage = {
    _count: ChanDiscussionMessageCountAggregateOutputType | null
    _min: ChanDiscussionMessageMinAggregateOutputType | null
    _max: ChanDiscussionMessageMaxAggregateOutputType | null
  }

  export type ChanDiscussionMessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    relatedTo: string | null
  }

  export type ChanDiscussionMessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    relatedTo: string | null
  }

  export type ChanDiscussionMessageCountAggregateOutputType = {
    id: number
    content: number
    relatedTo: number
    _all: number
  }


  export type ChanDiscussionMessageMinAggregateInputType = {
    id?: true
    content?: true
    relatedTo?: true
  }

  export type ChanDiscussionMessageMaxAggregateInputType = {
    id?: true
    content?: true
    relatedTo?: true
  }

  export type ChanDiscussionMessageCountAggregateInputType = {
    id?: true
    content?: true
    relatedTo?: true
    _all?: true
  }

  export type ChanDiscussionMessageAggregateArgs = {
    /**
     * Filter which ChanDiscussionMessage to aggregate.
     */
    where?: ChanDiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionMessages to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChanDiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChanDiscussionMessages
    **/
    _count?: true | ChanDiscussionMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChanDiscussionMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChanDiscussionMessageMaxAggregateInputType
  }

  export type GetChanDiscussionMessageAggregateType<T extends ChanDiscussionMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChanDiscussionMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChanDiscussionMessage[P]>
      : GetScalarType<T[P], AggregateChanDiscussionMessage[P]>
  }




  export type ChanDiscussionMessageGroupByArgs = {
    where?: ChanDiscussionMessageWhereInput
    orderBy?: Enumerable<ChanDiscussionMessageOrderByWithAggregationInput>
    by: ChanDiscussionMessageScalarFieldEnum[]
    having?: ChanDiscussionMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChanDiscussionMessageCountAggregateInputType | true
    _min?: ChanDiscussionMessageMinAggregateInputType
    _max?: ChanDiscussionMessageMaxAggregateInputType
  }


  export type ChanDiscussionMessageGroupByOutputType = {
    id: string
    content: string
    relatedTo: string | null
    _count: ChanDiscussionMessageCountAggregateOutputType | null
    _min: ChanDiscussionMessageMinAggregateOutputType | null
    _max: ChanDiscussionMessageMaxAggregateOutputType | null
  }

  type GetChanDiscussionMessageGroupByPayload<T extends ChanDiscussionMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChanDiscussionMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChanDiscussionMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChanDiscussionMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChanDiscussionMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChanDiscussionMessageSelect = {
    id?: boolean
    content?: boolean
    relatedTo?: boolean
    relatedUsers?: boolean | ChanDiscussionMessage$relatedUsersArgs
    relatedRoles?: boolean | ChanDiscussionMessage$relatedRolesArgs
    related?: boolean | ChanDiscussionMessage$relatedArgs
    discussionElement?: boolean | ChanDiscussionMessage$discussionElementArgs
    _count?: boolean | ChanDiscussionMessageCountOutputTypeArgs
  }


  export type ChanDiscussionMessageInclude = {
    relatedUsers?: boolean | ChanDiscussionMessage$relatedUsersArgs
    relatedRoles?: boolean | ChanDiscussionMessage$relatedRolesArgs
    related?: boolean | ChanDiscussionMessage$relatedArgs
    discussionElement?: boolean | ChanDiscussionMessage$discussionElementArgs
    _count?: boolean | ChanDiscussionMessageCountOutputTypeArgs
  }

  export type ChanDiscussionMessageGetPayload<S extends boolean | null | undefined | ChanDiscussionMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChanDiscussionMessage :
    S extends undefined ? never :
    S extends { include: any } & (ChanDiscussionMessageArgs | ChanDiscussionMessageFindManyArgs)
    ? ChanDiscussionMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'relatedUsers' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'relatedRoles' ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'related' ? ChanDiscussionElementGetPayload<S['include'][P]> | null :
        P extends 'discussionElement' ? ChanDiscussionElementGetPayload<S['include'][P]> | null :
        P extends '_count' ? ChanDiscussionMessageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChanDiscussionMessageArgs | ChanDiscussionMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'relatedUsers' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'relatedRoles' ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'related' ? ChanDiscussionElementGetPayload<S['select'][P]> | null :
        P extends 'discussionElement' ? ChanDiscussionElementGetPayload<S['select'][P]> | null :
        P extends '_count' ? ChanDiscussionMessageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ChanDiscussionMessage ? ChanDiscussionMessage[P] : never
  } 
      : ChanDiscussionMessage


  type ChanDiscussionMessageCountArgs = 
    Omit<ChanDiscussionMessageFindManyArgs, 'select' | 'include'> & {
      select?: ChanDiscussionMessageCountAggregateInputType | true
    }

  export interface ChanDiscussionMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChanDiscussionMessage that matches the filter.
     * @param {ChanDiscussionMessageFindUniqueArgs} args - Arguments to find a ChanDiscussionMessage
     * @example
     * // Get one ChanDiscussionMessage
     * const chanDiscussionMessage = await prisma.chanDiscussionMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChanDiscussionMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChanDiscussionMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChanDiscussionMessage'> extends True ? Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T>> : Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T> | null, null>

    /**
     * Find one ChanDiscussionMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChanDiscussionMessageFindUniqueOrThrowArgs} args - Arguments to find a ChanDiscussionMessage
     * @example
     * // Get one ChanDiscussionMessage
     * const chanDiscussionMessage = await prisma.chanDiscussionMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChanDiscussionMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChanDiscussionMessageFindUniqueOrThrowArgs>
    ): Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T>>

    /**
     * Find the first ChanDiscussionMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionMessageFindFirstArgs} args - Arguments to find a ChanDiscussionMessage
     * @example
     * // Get one ChanDiscussionMessage
     * const chanDiscussionMessage = await prisma.chanDiscussionMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChanDiscussionMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChanDiscussionMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChanDiscussionMessage'> extends True ? Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T>> : Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T> | null, null>

    /**
     * Find the first ChanDiscussionMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionMessageFindFirstOrThrowArgs} args - Arguments to find a ChanDiscussionMessage
     * @example
     * // Get one ChanDiscussionMessage
     * const chanDiscussionMessage = await prisma.chanDiscussionMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChanDiscussionMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChanDiscussionMessageFindFirstOrThrowArgs>
    ): Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T>>

    /**
     * Find zero or more ChanDiscussionMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChanDiscussionMessages
     * const chanDiscussionMessages = await prisma.chanDiscussionMessage.findMany()
     * 
     * // Get first 10 ChanDiscussionMessages
     * const chanDiscussionMessages = await prisma.chanDiscussionMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chanDiscussionMessageWithIdOnly = await prisma.chanDiscussionMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChanDiscussionMessageFindManyArgs>(
      args?: SelectSubset<T, ChanDiscussionMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChanDiscussionMessageGetPayload<T>>>

    /**
     * Create a ChanDiscussionMessage.
     * @param {ChanDiscussionMessageCreateArgs} args - Arguments to create a ChanDiscussionMessage.
     * @example
     * // Create one ChanDiscussionMessage
     * const ChanDiscussionMessage = await prisma.chanDiscussionMessage.create({
     *   data: {
     *     // ... data to create a ChanDiscussionMessage
     *   }
     * })
     * 
    **/
    create<T extends ChanDiscussionMessageCreateArgs>(
      args: SelectSubset<T, ChanDiscussionMessageCreateArgs>
    ): Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T>>

    /**
     * Create many ChanDiscussionMessages.
     *     @param {ChanDiscussionMessageCreateManyArgs} args - Arguments to create many ChanDiscussionMessages.
     *     @example
     *     // Create many ChanDiscussionMessages
     *     const chanDiscussionMessage = await prisma.chanDiscussionMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChanDiscussionMessageCreateManyArgs>(
      args?: SelectSubset<T, ChanDiscussionMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChanDiscussionMessage.
     * @param {ChanDiscussionMessageDeleteArgs} args - Arguments to delete one ChanDiscussionMessage.
     * @example
     * // Delete one ChanDiscussionMessage
     * const ChanDiscussionMessage = await prisma.chanDiscussionMessage.delete({
     *   where: {
     *     // ... filter to delete one ChanDiscussionMessage
     *   }
     * })
     * 
    **/
    delete<T extends ChanDiscussionMessageDeleteArgs>(
      args: SelectSubset<T, ChanDiscussionMessageDeleteArgs>
    ): Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T>>

    /**
     * Update one ChanDiscussionMessage.
     * @param {ChanDiscussionMessageUpdateArgs} args - Arguments to update one ChanDiscussionMessage.
     * @example
     * // Update one ChanDiscussionMessage
     * const chanDiscussionMessage = await prisma.chanDiscussionMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChanDiscussionMessageUpdateArgs>(
      args: SelectSubset<T, ChanDiscussionMessageUpdateArgs>
    ): Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T>>

    /**
     * Delete zero or more ChanDiscussionMessages.
     * @param {ChanDiscussionMessageDeleteManyArgs} args - Arguments to filter ChanDiscussionMessages to delete.
     * @example
     * // Delete a few ChanDiscussionMessages
     * const { count } = await prisma.chanDiscussionMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChanDiscussionMessageDeleteManyArgs>(
      args?: SelectSubset<T, ChanDiscussionMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChanDiscussionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChanDiscussionMessages
     * const chanDiscussionMessage = await prisma.chanDiscussionMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChanDiscussionMessageUpdateManyArgs>(
      args: SelectSubset<T, ChanDiscussionMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChanDiscussionMessage.
     * @param {ChanDiscussionMessageUpsertArgs} args - Arguments to update or create a ChanDiscussionMessage.
     * @example
     * // Update or create a ChanDiscussionMessage
     * const chanDiscussionMessage = await prisma.chanDiscussionMessage.upsert({
     *   create: {
     *     // ... data to create a ChanDiscussionMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChanDiscussionMessage we want to update
     *   }
     * })
    **/
    upsert<T extends ChanDiscussionMessageUpsertArgs>(
      args: SelectSubset<T, ChanDiscussionMessageUpsertArgs>
    ): Prisma__ChanDiscussionMessageClient<ChanDiscussionMessageGetPayload<T>>

    /**
     * Count the number of ChanDiscussionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionMessageCountArgs} args - Arguments to filter ChanDiscussionMessages to count.
     * @example
     * // Count the number of ChanDiscussionMessages
     * const count = await prisma.chanDiscussionMessage.count({
     *   where: {
     *     // ... the filter for the ChanDiscussionMessages we want to count
     *   }
     * })
    **/
    count<T extends ChanDiscussionMessageCountArgs>(
      args?: Subset<T, ChanDiscussionMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChanDiscussionMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChanDiscussionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChanDiscussionMessageAggregateArgs>(args: Subset<T, ChanDiscussionMessageAggregateArgs>): Prisma.PrismaPromise<GetChanDiscussionMessageAggregateType<T>>

    /**
     * Group by ChanDiscussionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChanDiscussionMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChanDiscussionMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChanDiscussionMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChanDiscussionMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChanDiscussionMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChanDiscussionMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChanDiscussionMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    relatedUsers<T extends ChanDiscussionMessage$relatedUsersArgs= {}>(args?: Subset<T, ChanDiscussionMessage$relatedUsersArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    relatedRoles<T extends ChanDiscussionMessage$relatedRolesArgs= {}>(args?: Subset<T, ChanDiscussionMessage$relatedRolesArgs>): Prisma.PrismaPromise<Array<RoleGetPayload<T>>| Null>;

    related<T extends ChanDiscussionMessage$relatedArgs= {}>(args?: Subset<T, ChanDiscussionMessage$relatedArgs>): Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T> | Null>;

    discussionElement<T extends ChanDiscussionMessage$discussionElementArgs= {}>(args?: Subset<T, ChanDiscussionMessage$discussionElementArgs>): Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChanDiscussionMessage base type for findUnique actions
   */
  export type ChanDiscussionMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    /**
     * Filter, which ChanDiscussionMessage to fetch.
     */
    where: ChanDiscussionMessageWhereUniqueInput
  }

  /**
   * ChanDiscussionMessage findUnique
   */
  export interface ChanDiscussionMessageFindUniqueArgs extends ChanDiscussionMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanDiscussionMessage findUniqueOrThrow
   */
  export type ChanDiscussionMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    /**
     * Filter, which ChanDiscussionMessage to fetch.
     */
    where: ChanDiscussionMessageWhereUniqueInput
  }


  /**
   * ChanDiscussionMessage base type for findFirst actions
   */
  export type ChanDiscussionMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    /**
     * Filter, which ChanDiscussionMessage to fetch.
     */
    where?: ChanDiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionMessages to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanDiscussionMessages.
     */
    cursor?: ChanDiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanDiscussionMessages.
     */
    distinct?: Enumerable<ChanDiscussionMessageScalarFieldEnum>
  }

  /**
   * ChanDiscussionMessage findFirst
   */
  export interface ChanDiscussionMessageFindFirstArgs extends ChanDiscussionMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanDiscussionMessage findFirstOrThrow
   */
  export type ChanDiscussionMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    /**
     * Filter, which ChanDiscussionMessage to fetch.
     */
    where?: ChanDiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionMessages to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanDiscussionMessages.
     */
    cursor?: ChanDiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanDiscussionMessages.
     */
    distinct?: Enumerable<ChanDiscussionMessageScalarFieldEnum>
  }


  /**
   * ChanDiscussionMessage findMany
   */
  export type ChanDiscussionMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    /**
     * Filter, which ChanDiscussionMessages to fetch.
     */
    where?: ChanDiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionMessages to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChanDiscussionMessages.
     */
    cursor?: ChanDiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionMessages.
     */
    skip?: number
    distinct?: Enumerable<ChanDiscussionMessageScalarFieldEnum>
  }


  /**
   * ChanDiscussionMessage create
   */
  export type ChanDiscussionMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    /**
     * The data needed to create a ChanDiscussionMessage.
     */
    data: XOR<ChanDiscussionMessageCreateInput, ChanDiscussionMessageUncheckedCreateInput>
  }


  /**
   * ChanDiscussionMessage createMany
   */
  export type ChanDiscussionMessageCreateManyArgs = {
    /**
     * The data used to create many ChanDiscussionMessages.
     */
    data: Enumerable<ChanDiscussionMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChanDiscussionMessage update
   */
  export type ChanDiscussionMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    /**
     * The data needed to update a ChanDiscussionMessage.
     */
    data: XOR<ChanDiscussionMessageUpdateInput, ChanDiscussionMessageUncheckedUpdateInput>
    /**
     * Choose, which ChanDiscussionMessage to update.
     */
    where: ChanDiscussionMessageWhereUniqueInput
  }


  /**
   * ChanDiscussionMessage updateMany
   */
  export type ChanDiscussionMessageUpdateManyArgs = {
    /**
     * The data used to update ChanDiscussionMessages.
     */
    data: XOR<ChanDiscussionMessageUpdateManyMutationInput, ChanDiscussionMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChanDiscussionMessages to update
     */
    where?: ChanDiscussionMessageWhereInput
  }


  /**
   * ChanDiscussionMessage upsert
   */
  export type ChanDiscussionMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    /**
     * The filter to search for the ChanDiscussionMessage to update in case it exists.
     */
    where: ChanDiscussionMessageWhereUniqueInput
    /**
     * In case the ChanDiscussionMessage found by the `where` argument doesn't exist, create a new ChanDiscussionMessage with this data.
     */
    create: XOR<ChanDiscussionMessageCreateInput, ChanDiscussionMessageUncheckedCreateInput>
    /**
     * In case the ChanDiscussionMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChanDiscussionMessageUpdateInput, ChanDiscussionMessageUncheckedUpdateInput>
  }


  /**
   * ChanDiscussionMessage delete
   */
  export type ChanDiscussionMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
    /**
     * Filter which ChanDiscussionMessage to delete.
     */
    where: ChanDiscussionMessageWhereUniqueInput
  }


  /**
   * ChanDiscussionMessage deleteMany
   */
  export type ChanDiscussionMessageDeleteManyArgs = {
    /**
     * Filter which ChanDiscussionMessages to delete
     */
    where?: ChanDiscussionMessageWhereInput
  }


  /**
   * ChanDiscussionMessage.relatedUsers
   */
  export type ChanDiscussionMessage$relatedUsersArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * ChanDiscussionMessage.relatedRoles
   */
  export type ChanDiscussionMessage$relatedRolesArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * ChanDiscussionMessage.related
   */
  export type ChanDiscussionMessage$relatedArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    where?: ChanDiscussionElementWhereInput
  }


  /**
   * ChanDiscussionMessage.discussionElement
   */
  export type ChanDiscussionMessage$discussionElementArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    where?: ChanDiscussionElementWhereInput
  }


  /**
   * ChanDiscussionMessage without action
   */
  export type ChanDiscussionMessageArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionMessage
     */
    select?: ChanDiscussionMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionMessageInclude | null
  }



  /**
   * Model ChanDiscussionEvent
   */


  export type AggregateChanDiscussionEvent = {
    _count: ChanDiscussionEventCountAggregateOutputType | null
    _min: ChanDiscussionEventMinAggregateOutputType | null
    _max: ChanDiscussionEventMaxAggregateOutputType | null
  }

  export type ChanDiscussionEventMinAggregateOutputType = {
    id: string | null
    concernedUserName: string | null
    classicChanDiscussionEventId: string | null
    changedTitleChanDiscussionEventId: string | null
    deletedMessageChanDiscussionEventId: string | null
  }

  export type ChanDiscussionEventMaxAggregateOutputType = {
    id: string | null
    concernedUserName: string | null
    classicChanDiscussionEventId: string | null
    changedTitleChanDiscussionEventId: string | null
    deletedMessageChanDiscussionEventId: string | null
  }

  export type ChanDiscussionEventCountAggregateOutputType = {
    id: number
    concernedUserName: number
    classicChanDiscussionEventId: number
    changedTitleChanDiscussionEventId: number
    deletedMessageChanDiscussionEventId: number
    _all: number
  }


  export type ChanDiscussionEventMinAggregateInputType = {
    id?: true
    concernedUserName?: true
    classicChanDiscussionEventId?: true
    changedTitleChanDiscussionEventId?: true
    deletedMessageChanDiscussionEventId?: true
  }

  export type ChanDiscussionEventMaxAggregateInputType = {
    id?: true
    concernedUserName?: true
    classicChanDiscussionEventId?: true
    changedTitleChanDiscussionEventId?: true
    deletedMessageChanDiscussionEventId?: true
  }

  export type ChanDiscussionEventCountAggregateInputType = {
    id?: true
    concernedUserName?: true
    classicChanDiscussionEventId?: true
    changedTitleChanDiscussionEventId?: true
    deletedMessageChanDiscussionEventId?: true
    _all?: true
  }

  export type ChanDiscussionEventAggregateArgs = {
    /**
     * Filter which ChanDiscussionEvent to aggregate.
     */
    where?: ChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChanDiscussionEvents
    **/
    _count?: true | ChanDiscussionEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChanDiscussionEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChanDiscussionEventMaxAggregateInputType
  }

  export type GetChanDiscussionEventAggregateType<T extends ChanDiscussionEventAggregateArgs> = {
        [P in keyof T & keyof AggregateChanDiscussionEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChanDiscussionEvent[P]>
      : GetScalarType<T[P], AggregateChanDiscussionEvent[P]>
  }




  export type ChanDiscussionEventGroupByArgs = {
    where?: ChanDiscussionEventWhereInput
    orderBy?: Enumerable<ChanDiscussionEventOrderByWithAggregationInput>
    by: ChanDiscussionEventScalarFieldEnum[]
    having?: ChanDiscussionEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChanDiscussionEventCountAggregateInputType | true
    _min?: ChanDiscussionEventMinAggregateInputType
    _max?: ChanDiscussionEventMaxAggregateInputType
  }


  export type ChanDiscussionEventGroupByOutputType = {
    id: string
    concernedUserName: string | null
    classicChanDiscussionEventId: string | null
    changedTitleChanDiscussionEventId: string | null
    deletedMessageChanDiscussionEventId: string | null
    _count: ChanDiscussionEventCountAggregateOutputType | null
    _min: ChanDiscussionEventMinAggregateOutputType | null
    _max: ChanDiscussionEventMaxAggregateOutputType | null
  }

  type GetChanDiscussionEventGroupByPayload<T extends ChanDiscussionEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChanDiscussionEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChanDiscussionEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChanDiscussionEventGroupByOutputType[P]>
            : GetScalarType<T[P], ChanDiscussionEventGroupByOutputType[P]>
        }
      >
    >


  export type ChanDiscussionEventSelect = {
    id?: boolean
    concernedUserName?: boolean
    classicChanDiscussionEventId?: boolean
    changedTitleChanDiscussionEventId?: boolean
    deletedMessageChanDiscussionEventId?: boolean
    concernedUser?: boolean | ChanDiscussionEvent$concernedUserArgs
    classicChanDiscussionEvent?: boolean | ChanDiscussionEvent$classicChanDiscussionEventArgs
    changedTitleChanDiscussionEvent?: boolean | ChanDiscussionEvent$changedTitleChanDiscussionEventArgs
    deletedMessageChanDiscussionEvent?: boolean | ChanDiscussionEvent$deletedMessageChanDiscussionEventArgs
    discussionElement?: boolean | ChanDiscussionEvent$discussionElementArgs
  }


  export type ChanDiscussionEventInclude = {
    concernedUser?: boolean | ChanDiscussionEvent$concernedUserArgs
    classicChanDiscussionEvent?: boolean | ChanDiscussionEvent$classicChanDiscussionEventArgs
    changedTitleChanDiscussionEvent?: boolean | ChanDiscussionEvent$changedTitleChanDiscussionEventArgs
    deletedMessageChanDiscussionEvent?: boolean | ChanDiscussionEvent$deletedMessageChanDiscussionEventArgs
    discussionElement?: boolean | ChanDiscussionEvent$discussionElementArgs
  }

  export type ChanDiscussionEventGetPayload<S extends boolean | null | undefined | ChanDiscussionEventArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChanDiscussionEvent :
    S extends undefined ? never :
    S extends { include: any } & (ChanDiscussionEventArgs | ChanDiscussionEventFindManyArgs)
    ? ChanDiscussionEvent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'concernedUser' ? UserGetPayload<S['include'][P]> | null :
        P extends 'classicChanDiscussionEvent' ? ClassicChanDiscussionEventGetPayload<S['include'][P]> | null :
        P extends 'changedTitleChanDiscussionEvent' ? ChangedTitleChanDiscussionEventGetPayload<S['include'][P]> | null :
        P extends 'deletedMessageChanDiscussionEvent' ? DeletedMessageChanDiscussionEventGetPayload<S['include'][P]> | null :
        P extends 'discussionElement' ? ChanDiscussionElementGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ChanDiscussionEventArgs | ChanDiscussionEventFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'concernedUser' ? UserGetPayload<S['select'][P]> | null :
        P extends 'classicChanDiscussionEvent' ? ClassicChanDiscussionEventGetPayload<S['select'][P]> | null :
        P extends 'changedTitleChanDiscussionEvent' ? ChangedTitleChanDiscussionEventGetPayload<S['select'][P]> | null :
        P extends 'deletedMessageChanDiscussionEvent' ? DeletedMessageChanDiscussionEventGetPayload<S['select'][P]> | null :
        P extends 'discussionElement' ? ChanDiscussionElementGetPayload<S['select'][P]> | null :  P extends keyof ChanDiscussionEvent ? ChanDiscussionEvent[P] : never
  } 
      : ChanDiscussionEvent


  type ChanDiscussionEventCountArgs = 
    Omit<ChanDiscussionEventFindManyArgs, 'select' | 'include'> & {
      select?: ChanDiscussionEventCountAggregateInputType | true
    }

  export interface ChanDiscussionEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChanDiscussionEvent that matches the filter.
     * @param {ChanDiscussionEventFindUniqueArgs} args - Arguments to find a ChanDiscussionEvent
     * @example
     * // Get one ChanDiscussionEvent
     * const chanDiscussionEvent = await prisma.chanDiscussionEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChanDiscussionEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChanDiscussionEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChanDiscussionEvent'> extends True ? Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T>> : Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T> | null, null>

    /**
     * Find one ChanDiscussionEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChanDiscussionEventFindUniqueOrThrowArgs} args - Arguments to find a ChanDiscussionEvent
     * @example
     * // Get one ChanDiscussionEvent
     * const chanDiscussionEvent = await prisma.chanDiscussionEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChanDiscussionEventFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChanDiscussionEventFindUniqueOrThrowArgs>
    ): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T>>

    /**
     * Find the first ChanDiscussionEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionEventFindFirstArgs} args - Arguments to find a ChanDiscussionEvent
     * @example
     * // Get one ChanDiscussionEvent
     * const chanDiscussionEvent = await prisma.chanDiscussionEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChanDiscussionEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChanDiscussionEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChanDiscussionEvent'> extends True ? Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T>> : Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T> | null, null>

    /**
     * Find the first ChanDiscussionEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionEventFindFirstOrThrowArgs} args - Arguments to find a ChanDiscussionEvent
     * @example
     * // Get one ChanDiscussionEvent
     * const chanDiscussionEvent = await prisma.chanDiscussionEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChanDiscussionEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChanDiscussionEventFindFirstOrThrowArgs>
    ): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T>>

    /**
     * Find zero or more ChanDiscussionEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChanDiscussionEvents
     * const chanDiscussionEvents = await prisma.chanDiscussionEvent.findMany()
     * 
     * // Get first 10 ChanDiscussionEvents
     * const chanDiscussionEvents = await prisma.chanDiscussionEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chanDiscussionEventWithIdOnly = await prisma.chanDiscussionEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChanDiscussionEventFindManyArgs>(
      args?: SelectSubset<T, ChanDiscussionEventFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChanDiscussionEventGetPayload<T>>>

    /**
     * Create a ChanDiscussionEvent.
     * @param {ChanDiscussionEventCreateArgs} args - Arguments to create a ChanDiscussionEvent.
     * @example
     * // Create one ChanDiscussionEvent
     * const ChanDiscussionEvent = await prisma.chanDiscussionEvent.create({
     *   data: {
     *     // ... data to create a ChanDiscussionEvent
     *   }
     * })
     * 
    **/
    create<T extends ChanDiscussionEventCreateArgs>(
      args: SelectSubset<T, ChanDiscussionEventCreateArgs>
    ): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T>>

    /**
     * Create many ChanDiscussionEvents.
     *     @param {ChanDiscussionEventCreateManyArgs} args - Arguments to create many ChanDiscussionEvents.
     *     @example
     *     // Create many ChanDiscussionEvents
     *     const chanDiscussionEvent = await prisma.chanDiscussionEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChanDiscussionEventCreateManyArgs>(
      args?: SelectSubset<T, ChanDiscussionEventCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChanDiscussionEvent.
     * @param {ChanDiscussionEventDeleteArgs} args - Arguments to delete one ChanDiscussionEvent.
     * @example
     * // Delete one ChanDiscussionEvent
     * const ChanDiscussionEvent = await prisma.chanDiscussionEvent.delete({
     *   where: {
     *     // ... filter to delete one ChanDiscussionEvent
     *   }
     * })
     * 
    **/
    delete<T extends ChanDiscussionEventDeleteArgs>(
      args: SelectSubset<T, ChanDiscussionEventDeleteArgs>
    ): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T>>

    /**
     * Update one ChanDiscussionEvent.
     * @param {ChanDiscussionEventUpdateArgs} args - Arguments to update one ChanDiscussionEvent.
     * @example
     * // Update one ChanDiscussionEvent
     * const chanDiscussionEvent = await prisma.chanDiscussionEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChanDiscussionEventUpdateArgs>(
      args: SelectSubset<T, ChanDiscussionEventUpdateArgs>
    ): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T>>

    /**
     * Delete zero or more ChanDiscussionEvents.
     * @param {ChanDiscussionEventDeleteManyArgs} args - Arguments to filter ChanDiscussionEvents to delete.
     * @example
     * // Delete a few ChanDiscussionEvents
     * const { count } = await prisma.chanDiscussionEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChanDiscussionEventDeleteManyArgs>(
      args?: SelectSubset<T, ChanDiscussionEventDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChanDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChanDiscussionEvents
     * const chanDiscussionEvent = await prisma.chanDiscussionEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChanDiscussionEventUpdateManyArgs>(
      args: SelectSubset<T, ChanDiscussionEventUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChanDiscussionEvent.
     * @param {ChanDiscussionEventUpsertArgs} args - Arguments to update or create a ChanDiscussionEvent.
     * @example
     * // Update or create a ChanDiscussionEvent
     * const chanDiscussionEvent = await prisma.chanDiscussionEvent.upsert({
     *   create: {
     *     // ... data to create a ChanDiscussionEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChanDiscussionEvent we want to update
     *   }
     * })
    **/
    upsert<T extends ChanDiscussionEventUpsertArgs>(
      args: SelectSubset<T, ChanDiscussionEventUpsertArgs>
    ): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T>>

    /**
     * Count the number of ChanDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionEventCountArgs} args - Arguments to filter ChanDiscussionEvents to count.
     * @example
     * // Count the number of ChanDiscussionEvents
     * const count = await prisma.chanDiscussionEvent.count({
     *   where: {
     *     // ... the filter for the ChanDiscussionEvents we want to count
     *   }
     * })
    **/
    count<T extends ChanDiscussionEventCountArgs>(
      args?: Subset<T, ChanDiscussionEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChanDiscussionEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChanDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChanDiscussionEventAggregateArgs>(args: Subset<T, ChanDiscussionEventAggregateArgs>): Prisma.PrismaPromise<GetChanDiscussionEventAggregateType<T>>

    /**
     * Group by ChanDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChanDiscussionEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChanDiscussionEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChanDiscussionEventGroupByArgs['orderBy'] }
        : { orderBy?: ChanDiscussionEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChanDiscussionEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChanDiscussionEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChanDiscussionEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChanDiscussionEventClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    concernedUser<T extends ChanDiscussionEvent$concernedUserArgs= {}>(args?: Subset<T, ChanDiscussionEvent$concernedUserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    classicChanDiscussionEvent<T extends ChanDiscussionEvent$classicChanDiscussionEventArgs= {}>(args?: Subset<T, ChanDiscussionEvent$classicChanDiscussionEventArgs>): Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T> | Null>;

    changedTitleChanDiscussionEvent<T extends ChanDiscussionEvent$changedTitleChanDiscussionEventArgs= {}>(args?: Subset<T, ChanDiscussionEvent$changedTitleChanDiscussionEventArgs>): Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T> | Null>;

    deletedMessageChanDiscussionEvent<T extends ChanDiscussionEvent$deletedMessageChanDiscussionEventArgs= {}>(args?: Subset<T, ChanDiscussionEvent$deletedMessageChanDiscussionEventArgs>): Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T> | Null>;

    discussionElement<T extends ChanDiscussionEvent$discussionElementArgs= {}>(args?: Subset<T, ChanDiscussionEvent$discussionElementArgs>): Prisma__ChanDiscussionElementClient<ChanDiscussionElementGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChanDiscussionEvent base type for findUnique actions
   */
  export type ChanDiscussionEventFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    /**
     * Filter, which ChanDiscussionEvent to fetch.
     */
    where: ChanDiscussionEventWhereUniqueInput
  }

  /**
   * ChanDiscussionEvent findUnique
   */
  export interface ChanDiscussionEventFindUniqueArgs extends ChanDiscussionEventFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanDiscussionEvent findUniqueOrThrow
   */
  export type ChanDiscussionEventFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    /**
     * Filter, which ChanDiscussionEvent to fetch.
     */
    where: ChanDiscussionEventWhereUniqueInput
  }


  /**
   * ChanDiscussionEvent base type for findFirst actions
   */
  export type ChanDiscussionEventFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    /**
     * Filter, which ChanDiscussionEvent to fetch.
     */
    where?: ChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanDiscussionEvents.
     */
    cursor?: ChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanDiscussionEvents.
     */
    distinct?: Enumerable<ChanDiscussionEventScalarFieldEnum>
  }

  /**
   * ChanDiscussionEvent findFirst
   */
  export interface ChanDiscussionEventFindFirstArgs extends ChanDiscussionEventFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChanDiscussionEvent findFirstOrThrow
   */
  export type ChanDiscussionEventFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    /**
     * Filter, which ChanDiscussionEvent to fetch.
     */
    where?: ChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChanDiscussionEvents.
     */
    cursor?: ChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChanDiscussionEvents.
     */
    distinct?: Enumerable<ChanDiscussionEventScalarFieldEnum>
  }


  /**
   * ChanDiscussionEvent findMany
   */
  export type ChanDiscussionEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    /**
     * Filter, which ChanDiscussionEvents to fetch.
     */
    where?: ChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChanDiscussionEvents.
     */
    cursor?: ChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChanDiscussionEvents.
     */
    skip?: number
    distinct?: Enumerable<ChanDiscussionEventScalarFieldEnum>
  }


  /**
   * ChanDiscussionEvent create
   */
  export type ChanDiscussionEventCreateArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    /**
     * The data needed to create a ChanDiscussionEvent.
     */
    data: XOR<ChanDiscussionEventCreateInput, ChanDiscussionEventUncheckedCreateInput>
  }


  /**
   * ChanDiscussionEvent createMany
   */
  export type ChanDiscussionEventCreateManyArgs = {
    /**
     * The data used to create many ChanDiscussionEvents.
     */
    data: Enumerable<ChanDiscussionEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChanDiscussionEvent update
   */
  export type ChanDiscussionEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    /**
     * The data needed to update a ChanDiscussionEvent.
     */
    data: XOR<ChanDiscussionEventUpdateInput, ChanDiscussionEventUncheckedUpdateInput>
    /**
     * Choose, which ChanDiscussionEvent to update.
     */
    where: ChanDiscussionEventWhereUniqueInput
  }


  /**
   * ChanDiscussionEvent updateMany
   */
  export type ChanDiscussionEventUpdateManyArgs = {
    /**
     * The data used to update ChanDiscussionEvents.
     */
    data: XOR<ChanDiscussionEventUpdateManyMutationInput, ChanDiscussionEventUncheckedUpdateManyInput>
    /**
     * Filter which ChanDiscussionEvents to update
     */
    where?: ChanDiscussionEventWhereInput
  }


  /**
   * ChanDiscussionEvent upsert
   */
  export type ChanDiscussionEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    /**
     * The filter to search for the ChanDiscussionEvent to update in case it exists.
     */
    where: ChanDiscussionEventWhereUniqueInput
    /**
     * In case the ChanDiscussionEvent found by the `where` argument doesn't exist, create a new ChanDiscussionEvent with this data.
     */
    create: XOR<ChanDiscussionEventCreateInput, ChanDiscussionEventUncheckedCreateInput>
    /**
     * In case the ChanDiscussionEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChanDiscussionEventUpdateInput, ChanDiscussionEventUncheckedUpdateInput>
  }


  /**
   * ChanDiscussionEvent delete
   */
  export type ChanDiscussionEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    /**
     * Filter which ChanDiscussionEvent to delete.
     */
    where: ChanDiscussionEventWhereUniqueInput
  }


  /**
   * ChanDiscussionEvent deleteMany
   */
  export type ChanDiscussionEventDeleteManyArgs = {
    /**
     * Filter which ChanDiscussionEvents to delete
     */
    where?: ChanDiscussionEventWhereInput
  }


  /**
   * ChanDiscussionEvent.concernedUser
   */
  export type ChanDiscussionEvent$concernedUserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
  }


  /**
   * ChanDiscussionEvent.classicChanDiscussionEvent
   */
  export type ChanDiscussionEvent$classicChanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    where?: ClassicChanDiscussionEventWhereInput
  }


  /**
   * ChanDiscussionEvent.changedTitleChanDiscussionEvent
   */
  export type ChanDiscussionEvent$changedTitleChanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    where?: ChangedTitleChanDiscussionEventWhereInput
  }


  /**
   * ChanDiscussionEvent.deletedMessageChanDiscussionEvent
   */
  export type ChanDiscussionEvent$deletedMessageChanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    where?: DeletedMessageChanDiscussionEventWhereInput
  }


  /**
   * ChanDiscussionEvent.discussionElement
   */
  export type ChanDiscussionEvent$discussionElementArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionElement
     */
    select?: ChanDiscussionElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionElementInclude | null
    where?: ChanDiscussionElementWhereInput
  }


  /**
   * ChanDiscussionEvent without action
   */
  export type ChanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
  }



  /**
   * Model ChangedTitleChanDiscussionEvent
   */


  export type AggregateChangedTitleChanDiscussionEvent = {
    _count: ChangedTitleChanDiscussionEventCountAggregateOutputType | null
    _min: ChangedTitleChanDiscussionEventMinAggregateOutputType | null
    _max: ChangedTitleChanDiscussionEventMaxAggregateOutputType | null
  }

  export type ChangedTitleChanDiscussionEventMinAggregateOutputType = {
    id: string | null
    oldTitle: string | null
    newTitle: string | null
  }

  export type ChangedTitleChanDiscussionEventMaxAggregateOutputType = {
    id: string | null
    oldTitle: string | null
    newTitle: string | null
  }

  export type ChangedTitleChanDiscussionEventCountAggregateOutputType = {
    id: number
    oldTitle: number
    newTitle: number
    _all: number
  }


  export type ChangedTitleChanDiscussionEventMinAggregateInputType = {
    id?: true
    oldTitle?: true
    newTitle?: true
  }

  export type ChangedTitleChanDiscussionEventMaxAggregateInputType = {
    id?: true
    oldTitle?: true
    newTitle?: true
  }

  export type ChangedTitleChanDiscussionEventCountAggregateInputType = {
    id?: true
    oldTitle?: true
    newTitle?: true
    _all?: true
  }

  export type ChangedTitleChanDiscussionEventAggregateArgs = {
    /**
     * Filter which ChangedTitleChanDiscussionEvent to aggregate.
     */
    where?: ChangedTitleChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangedTitleChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChangedTitleChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangedTitleChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangedTitleChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangedTitleChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangedTitleChanDiscussionEvents
    **/
    _count?: true | ChangedTitleChanDiscussionEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangedTitleChanDiscussionEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangedTitleChanDiscussionEventMaxAggregateInputType
  }

  export type GetChangedTitleChanDiscussionEventAggregateType<T extends ChangedTitleChanDiscussionEventAggregateArgs> = {
        [P in keyof T & keyof AggregateChangedTitleChanDiscussionEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangedTitleChanDiscussionEvent[P]>
      : GetScalarType<T[P], AggregateChangedTitleChanDiscussionEvent[P]>
  }




  export type ChangedTitleChanDiscussionEventGroupByArgs = {
    where?: ChangedTitleChanDiscussionEventWhereInput
    orderBy?: Enumerable<ChangedTitleChanDiscussionEventOrderByWithAggregationInput>
    by: ChangedTitleChanDiscussionEventScalarFieldEnum[]
    having?: ChangedTitleChanDiscussionEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangedTitleChanDiscussionEventCountAggregateInputType | true
    _min?: ChangedTitleChanDiscussionEventMinAggregateInputType
    _max?: ChangedTitleChanDiscussionEventMaxAggregateInputType
  }


  export type ChangedTitleChanDiscussionEventGroupByOutputType = {
    id: string
    oldTitle: string
    newTitle: string
    _count: ChangedTitleChanDiscussionEventCountAggregateOutputType | null
    _min: ChangedTitleChanDiscussionEventMinAggregateOutputType | null
    _max: ChangedTitleChanDiscussionEventMaxAggregateOutputType | null
  }

  type GetChangedTitleChanDiscussionEventGroupByPayload<T extends ChangedTitleChanDiscussionEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChangedTitleChanDiscussionEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangedTitleChanDiscussionEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangedTitleChanDiscussionEventGroupByOutputType[P]>
            : GetScalarType<T[P], ChangedTitleChanDiscussionEventGroupByOutputType[P]>
        }
      >
    >


  export type ChangedTitleChanDiscussionEventSelect = {
    id?: boolean
    oldTitle?: boolean
    newTitle?: boolean
    chanDiscussionEvent?: boolean | ChangedTitleChanDiscussionEvent$chanDiscussionEventArgs
  }


  export type ChangedTitleChanDiscussionEventInclude = {
    chanDiscussionEvent?: boolean | ChangedTitleChanDiscussionEvent$chanDiscussionEventArgs
  }

  export type ChangedTitleChanDiscussionEventGetPayload<S extends boolean | null | undefined | ChangedTitleChanDiscussionEventArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChangedTitleChanDiscussionEvent :
    S extends undefined ? never :
    S extends { include: any } & (ChangedTitleChanDiscussionEventArgs | ChangedTitleChanDiscussionEventFindManyArgs)
    ? ChangedTitleChanDiscussionEvent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'chanDiscussionEvent' ? ChanDiscussionEventGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ChangedTitleChanDiscussionEventArgs | ChangedTitleChanDiscussionEventFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'chanDiscussionEvent' ? ChanDiscussionEventGetPayload<S['select'][P]> | null :  P extends keyof ChangedTitleChanDiscussionEvent ? ChangedTitleChanDiscussionEvent[P] : never
  } 
      : ChangedTitleChanDiscussionEvent


  type ChangedTitleChanDiscussionEventCountArgs = 
    Omit<ChangedTitleChanDiscussionEventFindManyArgs, 'select' | 'include'> & {
      select?: ChangedTitleChanDiscussionEventCountAggregateInputType | true
    }

  export interface ChangedTitleChanDiscussionEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChangedTitleChanDiscussionEvent that matches the filter.
     * @param {ChangedTitleChanDiscussionEventFindUniqueArgs} args - Arguments to find a ChangedTitleChanDiscussionEvent
     * @example
     * // Get one ChangedTitleChanDiscussionEvent
     * const changedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChangedTitleChanDiscussionEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChangedTitleChanDiscussionEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChangedTitleChanDiscussionEvent'> extends True ? Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T>> : Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T> | null, null>

    /**
     * Find one ChangedTitleChanDiscussionEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChangedTitleChanDiscussionEventFindUniqueOrThrowArgs} args - Arguments to find a ChangedTitleChanDiscussionEvent
     * @example
     * // Get one ChangedTitleChanDiscussionEvent
     * const changedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChangedTitleChanDiscussionEventFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChangedTitleChanDiscussionEventFindUniqueOrThrowArgs>
    ): Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T>>

    /**
     * Find the first ChangedTitleChanDiscussionEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangedTitleChanDiscussionEventFindFirstArgs} args - Arguments to find a ChangedTitleChanDiscussionEvent
     * @example
     * // Get one ChangedTitleChanDiscussionEvent
     * const changedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChangedTitleChanDiscussionEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChangedTitleChanDiscussionEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChangedTitleChanDiscussionEvent'> extends True ? Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T>> : Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T> | null, null>

    /**
     * Find the first ChangedTitleChanDiscussionEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangedTitleChanDiscussionEventFindFirstOrThrowArgs} args - Arguments to find a ChangedTitleChanDiscussionEvent
     * @example
     * // Get one ChangedTitleChanDiscussionEvent
     * const changedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChangedTitleChanDiscussionEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChangedTitleChanDiscussionEventFindFirstOrThrowArgs>
    ): Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T>>

    /**
     * Find zero or more ChangedTitleChanDiscussionEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangedTitleChanDiscussionEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangedTitleChanDiscussionEvents
     * const changedTitleChanDiscussionEvents = await prisma.changedTitleChanDiscussionEvent.findMany()
     * 
     * // Get first 10 ChangedTitleChanDiscussionEvents
     * const changedTitleChanDiscussionEvents = await prisma.changedTitleChanDiscussionEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changedTitleChanDiscussionEventWithIdOnly = await prisma.changedTitleChanDiscussionEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChangedTitleChanDiscussionEventFindManyArgs>(
      args?: SelectSubset<T, ChangedTitleChanDiscussionEventFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChangedTitleChanDiscussionEventGetPayload<T>>>

    /**
     * Create a ChangedTitleChanDiscussionEvent.
     * @param {ChangedTitleChanDiscussionEventCreateArgs} args - Arguments to create a ChangedTitleChanDiscussionEvent.
     * @example
     * // Create one ChangedTitleChanDiscussionEvent
     * const ChangedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.create({
     *   data: {
     *     // ... data to create a ChangedTitleChanDiscussionEvent
     *   }
     * })
     * 
    **/
    create<T extends ChangedTitleChanDiscussionEventCreateArgs>(
      args: SelectSubset<T, ChangedTitleChanDiscussionEventCreateArgs>
    ): Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T>>

    /**
     * Create many ChangedTitleChanDiscussionEvents.
     *     @param {ChangedTitleChanDiscussionEventCreateManyArgs} args - Arguments to create many ChangedTitleChanDiscussionEvents.
     *     @example
     *     // Create many ChangedTitleChanDiscussionEvents
     *     const changedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChangedTitleChanDiscussionEventCreateManyArgs>(
      args?: SelectSubset<T, ChangedTitleChanDiscussionEventCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChangedTitleChanDiscussionEvent.
     * @param {ChangedTitleChanDiscussionEventDeleteArgs} args - Arguments to delete one ChangedTitleChanDiscussionEvent.
     * @example
     * // Delete one ChangedTitleChanDiscussionEvent
     * const ChangedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.delete({
     *   where: {
     *     // ... filter to delete one ChangedTitleChanDiscussionEvent
     *   }
     * })
     * 
    **/
    delete<T extends ChangedTitleChanDiscussionEventDeleteArgs>(
      args: SelectSubset<T, ChangedTitleChanDiscussionEventDeleteArgs>
    ): Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T>>

    /**
     * Update one ChangedTitleChanDiscussionEvent.
     * @param {ChangedTitleChanDiscussionEventUpdateArgs} args - Arguments to update one ChangedTitleChanDiscussionEvent.
     * @example
     * // Update one ChangedTitleChanDiscussionEvent
     * const changedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChangedTitleChanDiscussionEventUpdateArgs>(
      args: SelectSubset<T, ChangedTitleChanDiscussionEventUpdateArgs>
    ): Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T>>

    /**
     * Delete zero or more ChangedTitleChanDiscussionEvents.
     * @param {ChangedTitleChanDiscussionEventDeleteManyArgs} args - Arguments to filter ChangedTitleChanDiscussionEvents to delete.
     * @example
     * // Delete a few ChangedTitleChanDiscussionEvents
     * const { count } = await prisma.changedTitleChanDiscussionEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChangedTitleChanDiscussionEventDeleteManyArgs>(
      args?: SelectSubset<T, ChangedTitleChanDiscussionEventDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangedTitleChanDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangedTitleChanDiscussionEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangedTitleChanDiscussionEvents
     * const changedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChangedTitleChanDiscussionEventUpdateManyArgs>(
      args: SelectSubset<T, ChangedTitleChanDiscussionEventUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChangedTitleChanDiscussionEvent.
     * @param {ChangedTitleChanDiscussionEventUpsertArgs} args - Arguments to update or create a ChangedTitleChanDiscussionEvent.
     * @example
     * // Update or create a ChangedTitleChanDiscussionEvent
     * const changedTitleChanDiscussionEvent = await prisma.changedTitleChanDiscussionEvent.upsert({
     *   create: {
     *     // ... data to create a ChangedTitleChanDiscussionEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangedTitleChanDiscussionEvent we want to update
     *   }
     * })
    **/
    upsert<T extends ChangedTitleChanDiscussionEventUpsertArgs>(
      args: SelectSubset<T, ChangedTitleChanDiscussionEventUpsertArgs>
    ): Prisma__ChangedTitleChanDiscussionEventClient<ChangedTitleChanDiscussionEventGetPayload<T>>

    /**
     * Count the number of ChangedTitleChanDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangedTitleChanDiscussionEventCountArgs} args - Arguments to filter ChangedTitleChanDiscussionEvents to count.
     * @example
     * // Count the number of ChangedTitleChanDiscussionEvents
     * const count = await prisma.changedTitleChanDiscussionEvent.count({
     *   where: {
     *     // ... the filter for the ChangedTitleChanDiscussionEvents we want to count
     *   }
     * })
    **/
    count<T extends ChangedTitleChanDiscussionEventCountArgs>(
      args?: Subset<T, ChangedTitleChanDiscussionEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangedTitleChanDiscussionEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangedTitleChanDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangedTitleChanDiscussionEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangedTitleChanDiscussionEventAggregateArgs>(args: Subset<T, ChangedTitleChanDiscussionEventAggregateArgs>): Prisma.PrismaPromise<GetChangedTitleChanDiscussionEventAggregateType<T>>

    /**
     * Group by ChangedTitleChanDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangedTitleChanDiscussionEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangedTitleChanDiscussionEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangedTitleChanDiscussionEventGroupByArgs['orderBy'] }
        : { orderBy?: ChangedTitleChanDiscussionEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangedTitleChanDiscussionEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangedTitleChanDiscussionEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangedTitleChanDiscussionEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChangedTitleChanDiscussionEventClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chanDiscussionEvent<T extends ChangedTitleChanDiscussionEvent$chanDiscussionEventArgs= {}>(args?: Subset<T, ChangedTitleChanDiscussionEvent$chanDiscussionEventArgs>): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChangedTitleChanDiscussionEvent base type for findUnique actions
   */
  export type ChangedTitleChanDiscussionEventFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    /**
     * Filter, which ChangedTitleChanDiscussionEvent to fetch.
     */
    where: ChangedTitleChanDiscussionEventWhereUniqueInput
  }

  /**
   * ChangedTitleChanDiscussionEvent findUnique
   */
  export interface ChangedTitleChanDiscussionEventFindUniqueArgs extends ChangedTitleChanDiscussionEventFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChangedTitleChanDiscussionEvent findUniqueOrThrow
   */
  export type ChangedTitleChanDiscussionEventFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    /**
     * Filter, which ChangedTitleChanDiscussionEvent to fetch.
     */
    where: ChangedTitleChanDiscussionEventWhereUniqueInput
  }


  /**
   * ChangedTitleChanDiscussionEvent base type for findFirst actions
   */
  export type ChangedTitleChanDiscussionEventFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    /**
     * Filter, which ChangedTitleChanDiscussionEvent to fetch.
     */
    where?: ChangedTitleChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangedTitleChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChangedTitleChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangedTitleChanDiscussionEvents.
     */
    cursor?: ChangedTitleChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangedTitleChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangedTitleChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangedTitleChanDiscussionEvents.
     */
    distinct?: Enumerable<ChangedTitleChanDiscussionEventScalarFieldEnum>
  }

  /**
   * ChangedTitleChanDiscussionEvent findFirst
   */
  export interface ChangedTitleChanDiscussionEventFindFirstArgs extends ChangedTitleChanDiscussionEventFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChangedTitleChanDiscussionEvent findFirstOrThrow
   */
  export type ChangedTitleChanDiscussionEventFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    /**
     * Filter, which ChangedTitleChanDiscussionEvent to fetch.
     */
    where?: ChangedTitleChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangedTitleChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChangedTitleChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangedTitleChanDiscussionEvents.
     */
    cursor?: ChangedTitleChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangedTitleChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangedTitleChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangedTitleChanDiscussionEvents.
     */
    distinct?: Enumerable<ChangedTitleChanDiscussionEventScalarFieldEnum>
  }


  /**
   * ChangedTitleChanDiscussionEvent findMany
   */
  export type ChangedTitleChanDiscussionEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    /**
     * Filter, which ChangedTitleChanDiscussionEvents to fetch.
     */
    where?: ChangedTitleChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangedTitleChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ChangedTitleChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangedTitleChanDiscussionEvents.
     */
    cursor?: ChangedTitleChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangedTitleChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangedTitleChanDiscussionEvents.
     */
    skip?: number
    distinct?: Enumerable<ChangedTitleChanDiscussionEventScalarFieldEnum>
  }


  /**
   * ChangedTitleChanDiscussionEvent create
   */
  export type ChangedTitleChanDiscussionEventCreateArgs = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    /**
     * The data needed to create a ChangedTitleChanDiscussionEvent.
     */
    data: XOR<ChangedTitleChanDiscussionEventCreateInput, ChangedTitleChanDiscussionEventUncheckedCreateInput>
  }


  /**
   * ChangedTitleChanDiscussionEvent createMany
   */
  export type ChangedTitleChanDiscussionEventCreateManyArgs = {
    /**
     * The data used to create many ChangedTitleChanDiscussionEvents.
     */
    data: Enumerable<ChangedTitleChanDiscussionEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChangedTitleChanDiscussionEvent update
   */
  export type ChangedTitleChanDiscussionEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    /**
     * The data needed to update a ChangedTitleChanDiscussionEvent.
     */
    data: XOR<ChangedTitleChanDiscussionEventUpdateInput, ChangedTitleChanDiscussionEventUncheckedUpdateInput>
    /**
     * Choose, which ChangedTitleChanDiscussionEvent to update.
     */
    where: ChangedTitleChanDiscussionEventWhereUniqueInput
  }


  /**
   * ChangedTitleChanDiscussionEvent updateMany
   */
  export type ChangedTitleChanDiscussionEventUpdateManyArgs = {
    /**
     * The data used to update ChangedTitleChanDiscussionEvents.
     */
    data: XOR<ChangedTitleChanDiscussionEventUpdateManyMutationInput, ChangedTitleChanDiscussionEventUncheckedUpdateManyInput>
    /**
     * Filter which ChangedTitleChanDiscussionEvents to update
     */
    where?: ChangedTitleChanDiscussionEventWhereInput
  }


  /**
   * ChangedTitleChanDiscussionEvent upsert
   */
  export type ChangedTitleChanDiscussionEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    /**
     * The filter to search for the ChangedTitleChanDiscussionEvent to update in case it exists.
     */
    where: ChangedTitleChanDiscussionEventWhereUniqueInput
    /**
     * In case the ChangedTitleChanDiscussionEvent found by the `where` argument doesn't exist, create a new ChangedTitleChanDiscussionEvent with this data.
     */
    create: XOR<ChangedTitleChanDiscussionEventCreateInput, ChangedTitleChanDiscussionEventUncheckedCreateInput>
    /**
     * In case the ChangedTitleChanDiscussionEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangedTitleChanDiscussionEventUpdateInput, ChangedTitleChanDiscussionEventUncheckedUpdateInput>
  }


  /**
   * ChangedTitleChanDiscussionEvent delete
   */
  export type ChangedTitleChanDiscussionEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
    /**
     * Filter which ChangedTitleChanDiscussionEvent to delete.
     */
    where: ChangedTitleChanDiscussionEventWhereUniqueInput
  }


  /**
   * ChangedTitleChanDiscussionEvent deleteMany
   */
  export type ChangedTitleChanDiscussionEventDeleteManyArgs = {
    /**
     * Filter which ChangedTitleChanDiscussionEvents to delete
     */
    where?: ChangedTitleChanDiscussionEventWhereInput
  }


  /**
   * ChangedTitleChanDiscussionEvent.chanDiscussionEvent
   */
  export type ChangedTitleChanDiscussionEvent$chanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    where?: ChanDiscussionEventWhereInput
  }


  /**
   * ChangedTitleChanDiscussionEvent without action
   */
  export type ChangedTitleChanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChangedTitleChanDiscussionEvent
     */
    select?: ChangedTitleChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangedTitleChanDiscussionEventInclude | null
  }



  /**
   * Model DeletedMessageChanDiscussionEvent
   */


  export type AggregateDeletedMessageChanDiscussionEvent = {
    _count: DeletedMessageChanDiscussionEventCountAggregateOutputType | null
    _min: DeletedMessageChanDiscussionEventMinAggregateOutputType | null
    _max: DeletedMessageChanDiscussionEventMaxAggregateOutputType | null
  }

  export type DeletedMessageChanDiscussionEventMinAggregateOutputType = {
    id: string | null
    deletingUserName: string | null
  }

  export type DeletedMessageChanDiscussionEventMaxAggregateOutputType = {
    id: string | null
    deletingUserName: string | null
  }

  export type DeletedMessageChanDiscussionEventCountAggregateOutputType = {
    id: number
    deletingUserName: number
    _all: number
  }


  export type DeletedMessageChanDiscussionEventMinAggregateInputType = {
    id?: true
    deletingUserName?: true
  }

  export type DeletedMessageChanDiscussionEventMaxAggregateInputType = {
    id?: true
    deletingUserName?: true
  }

  export type DeletedMessageChanDiscussionEventCountAggregateInputType = {
    id?: true
    deletingUserName?: true
    _all?: true
  }

  export type DeletedMessageChanDiscussionEventAggregateArgs = {
    /**
     * Filter which DeletedMessageChanDiscussionEvent to aggregate.
     */
    where?: DeletedMessageChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedMessageChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<DeletedMessageChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeletedMessageChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedMessageChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedMessageChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeletedMessageChanDiscussionEvents
    **/
    _count?: true | DeletedMessageChanDiscussionEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeletedMessageChanDiscussionEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeletedMessageChanDiscussionEventMaxAggregateInputType
  }

  export type GetDeletedMessageChanDiscussionEventAggregateType<T extends DeletedMessageChanDiscussionEventAggregateArgs> = {
        [P in keyof T & keyof AggregateDeletedMessageChanDiscussionEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeletedMessageChanDiscussionEvent[P]>
      : GetScalarType<T[P], AggregateDeletedMessageChanDiscussionEvent[P]>
  }




  export type DeletedMessageChanDiscussionEventGroupByArgs = {
    where?: DeletedMessageChanDiscussionEventWhereInput
    orderBy?: Enumerable<DeletedMessageChanDiscussionEventOrderByWithAggregationInput>
    by: DeletedMessageChanDiscussionEventScalarFieldEnum[]
    having?: DeletedMessageChanDiscussionEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeletedMessageChanDiscussionEventCountAggregateInputType | true
    _min?: DeletedMessageChanDiscussionEventMinAggregateInputType
    _max?: DeletedMessageChanDiscussionEventMaxAggregateInputType
  }


  export type DeletedMessageChanDiscussionEventGroupByOutputType = {
    id: string
    deletingUserName: string
    _count: DeletedMessageChanDiscussionEventCountAggregateOutputType | null
    _min: DeletedMessageChanDiscussionEventMinAggregateOutputType | null
    _max: DeletedMessageChanDiscussionEventMaxAggregateOutputType | null
  }

  type GetDeletedMessageChanDiscussionEventGroupByPayload<T extends DeletedMessageChanDiscussionEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DeletedMessageChanDiscussionEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeletedMessageChanDiscussionEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeletedMessageChanDiscussionEventGroupByOutputType[P]>
            : GetScalarType<T[P], DeletedMessageChanDiscussionEventGroupByOutputType[P]>
        }
      >
    >


  export type DeletedMessageChanDiscussionEventSelect = {
    id?: boolean
    deletingUserName?: boolean
    deletingUsers?: boolean | UserArgs
    chanDiscussionEvent?: boolean | DeletedMessageChanDiscussionEvent$chanDiscussionEventArgs
  }


  export type DeletedMessageChanDiscussionEventInclude = {
    deletingUsers?: boolean | UserArgs
    chanDiscussionEvent?: boolean | DeletedMessageChanDiscussionEvent$chanDiscussionEventArgs
  }

  export type DeletedMessageChanDiscussionEventGetPayload<S extends boolean | null | undefined | DeletedMessageChanDiscussionEventArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DeletedMessageChanDiscussionEvent :
    S extends undefined ? never :
    S extends { include: any } & (DeletedMessageChanDiscussionEventArgs | DeletedMessageChanDiscussionEventFindManyArgs)
    ? DeletedMessageChanDiscussionEvent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'deletingUsers' ? UserGetPayload<S['include'][P]> :
        P extends 'chanDiscussionEvent' ? ChanDiscussionEventGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (DeletedMessageChanDiscussionEventArgs | DeletedMessageChanDiscussionEventFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'deletingUsers' ? UserGetPayload<S['select'][P]> :
        P extends 'chanDiscussionEvent' ? ChanDiscussionEventGetPayload<S['select'][P]> | null :  P extends keyof DeletedMessageChanDiscussionEvent ? DeletedMessageChanDiscussionEvent[P] : never
  } 
      : DeletedMessageChanDiscussionEvent


  type DeletedMessageChanDiscussionEventCountArgs = 
    Omit<DeletedMessageChanDiscussionEventFindManyArgs, 'select' | 'include'> & {
      select?: DeletedMessageChanDiscussionEventCountAggregateInputType | true
    }

  export interface DeletedMessageChanDiscussionEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DeletedMessageChanDiscussionEvent that matches the filter.
     * @param {DeletedMessageChanDiscussionEventFindUniqueArgs} args - Arguments to find a DeletedMessageChanDiscussionEvent
     * @example
     * // Get one DeletedMessageChanDiscussionEvent
     * const deletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeletedMessageChanDiscussionEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeletedMessageChanDiscussionEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeletedMessageChanDiscussionEvent'> extends True ? Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T>> : Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T> | null, null>

    /**
     * Find one DeletedMessageChanDiscussionEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeletedMessageChanDiscussionEventFindUniqueOrThrowArgs} args - Arguments to find a DeletedMessageChanDiscussionEvent
     * @example
     * // Get one DeletedMessageChanDiscussionEvent
     * const deletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeletedMessageChanDiscussionEventFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeletedMessageChanDiscussionEventFindUniqueOrThrowArgs>
    ): Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T>>

    /**
     * Find the first DeletedMessageChanDiscussionEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageChanDiscussionEventFindFirstArgs} args - Arguments to find a DeletedMessageChanDiscussionEvent
     * @example
     * // Get one DeletedMessageChanDiscussionEvent
     * const deletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeletedMessageChanDiscussionEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeletedMessageChanDiscussionEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeletedMessageChanDiscussionEvent'> extends True ? Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T>> : Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T> | null, null>

    /**
     * Find the first DeletedMessageChanDiscussionEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageChanDiscussionEventFindFirstOrThrowArgs} args - Arguments to find a DeletedMessageChanDiscussionEvent
     * @example
     * // Get one DeletedMessageChanDiscussionEvent
     * const deletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeletedMessageChanDiscussionEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeletedMessageChanDiscussionEventFindFirstOrThrowArgs>
    ): Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T>>

    /**
     * Find zero or more DeletedMessageChanDiscussionEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageChanDiscussionEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeletedMessageChanDiscussionEvents
     * const deletedMessageChanDiscussionEvents = await prisma.deletedMessageChanDiscussionEvent.findMany()
     * 
     * // Get first 10 DeletedMessageChanDiscussionEvents
     * const deletedMessageChanDiscussionEvents = await prisma.deletedMessageChanDiscussionEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deletedMessageChanDiscussionEventWithIdOnly = await prisma.deletedMessageChanDiscussionEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeletedMessageChanDiscussionEventFindManyArgs>(
      args?: SelectSubset<T, DeletedMessageChanDiscussionEventFindManyArgs>
    ): Prisma.PrismaPromise<Array<DeletedMessageChanDiscussionEventGetPayload<T>>>

    /**
     * Create a DeletedMessageChanDiscussionEvent.
     * @param {DeletedMessageChanDiscussionEventCreateArgs} args - Arguments to create a DeletedMessageChanDiscussionEvent.
     * @example
     * // Create one DeletedMessageChanDiscussionEvent
     * const DeletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.create({
     *   data: {
     *     // ... data to create a DeletedMessageChanDiscussionEvent
     *   }
     * })
     * 
    **/
    create<T extends DeletedMessageChanDiscussionEventCreateArgs>(
      args: SelectSubset<T, DeletedMessageChanDiscussionEventCreateArgs>
    ): Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T>>

    /**
     * Create many DeletedMessageChanDiscussionEvents.
     *     @param {DeletedMessageChanDiscussionEventCreateManyArgs} args - Arguments to create many DeletedMessageChanDiscussionEvents.
     *     @example
     *     // Create many DeletedMessageChanDiscussionEvents
     *     const deletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeletedMessageChanDiscussionEventCreateManyArgs>(
      args?: SelectSubset<T, DeletedMessageChanDiscussionEventCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeletedMessageChanDiscussionEvent.
     * @param {DeletedMessageChanDiscussionEventDeleteArgs} args - Arguments to delete one DeletedMessageChanDiscussionEvent.
     * @example
     * // Delete one DeletedMessageChanDiscussionEvent
     * const DeletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.delete({
     *   where: {
     *     // ... filter to delete one DeletedMessageChanDiscussionEvent
     *   }
     * })
     * 
    **/
    delete<T extends DeletedMessageChanDiscussionEventDeleteArgs>(
      args: SelectSubset<T, DeletedMessageChanDiscussionEventDeleteArgs>
    ): Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T>>

    /**
     * Update one DeletedMessageChanDiscussionEvent.
     * @param {DeletedMessageChanDiscussionEventUpdateArgs} args - Arguments to update one DeletedMessageChanDiscussionEvent.
     * @example
     * // Update one DeletedMessageChanDiscussionEvent
     * const deletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeletedMessageChanDiscussionEventUpdateArgs>(
      args: SelectSubset<T, DeletedMessageChanDiscussionEventUpdateArgs>
    ): Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T>>

    /**
     * Delete zero or more DeletedMessageChanDiscussionEvents.
     * @param {DeletedMessageChanDiscussionEventDeleteManyArgs} args - Arguments to filter DeletedMessageChanDiscussionEvents to delete.
     * @example
     * // Delete a few DeletedMessageChanDiscussionEvents
     * const { count } = await prisma.deletedMessageChanDiscussionEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeletedMessageChanDiscussionEventDeleteManyArgs>(
      args?: SelectSubset<T, DeletedMessageChanDiscussionEventDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeletedMessageChanDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageChanDiscussionEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeletedMessageChanDiscussionEvents
     * const deletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeletedMessageChanDiscussionEventUpdateManyArgs>(
      args: SelectSubset<T, DeletedMessageChanDiscussionEventUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeletedMessageChanDiscussionEvent.
     * @param {DeletedMessageChanDiscussionEventUpsertArgs} args - Arguments to update or create a DeletedMessageChanDiscussionEvent.
     * @example
     * // Update or create a DeletedMessageChanDiscussionEvent
     * const deletedMessageChanDiscussionEvent = await prisma.deletedMessageChanDiscussionEvent.upsert({
     *   create: {
     *     // ... data to create a DeletedMessageChanDiscussionEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeletedMessageChanDiscussionEvent we want to update
     *   }
     * })
    **/
    upsert<T extends DeletedMessageChanDiscussionEventUpsertArgs>(
      args: SelectSubset<T, DeletedMessageChanDiscussionEventUpsertArgs>
    ): Prisma__DeletedMessageChanDiscussionEventClient<DeletedMessageChanDiscussionEventGetPayload<T>>

    /**
     * Count the number of DeletedMessageChanDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageChanDiscussionEventCountArgs} args - Arguments to filter DeletedMessageChanDiscussionEvents to count.
     * @example
     * // Count the number of DeletedMessageChanDiscussionEvents
     * const count = await prisma.deletedMessageChanDiscussionEvent.count({
     *   where: {
     *     // ... the filter for the DeletedMessageChanDiscussionEvents we want to count
     *   }
     * })
    **/
    count<T extends DeletedMessageChanDiscussionEventCountArgs>(
      args?: Subset<T, DeletedMessageChanDiscussionEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeletedMessageChanDiscussionEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeletedMessageChanDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageChanDiscussionEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeletedMessageChanDiscussionEventAggregateArgs>(args: Subset<T, DeletedMessageChanDiscussionEventAggregateArgs>): Prisma.PrismaPromise<GetDeletedMessageChanDiscussionEventAggregateType<T>>

    /**
     * Group by DeletedMessageChanDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedMessageChanDiscussionEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeletedMessageChanDiscussionEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeletedMessageChanDiscussionEventGroupByArgs['orderBy'] }
        : { orderBy?: DeletedMessageChanDiscussionEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeletedMessageChanDiscussionEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeletedMessageChanDiscussionEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DeletedMessageChanDiscussionEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeletedMessageChanDiscussionEventClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    deletingUsers<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    chanDiscussionEvent<T extends DeletedMessageChanDiscussionEvent$chanDiscussionEventArgs= {}>(args?: Subset<T, DeletedMessageChanDiscussionEvent$chanDiscussionEventArgs>): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DeletedMessageChanDiscussionEvent base type for findUnique actions
   */
  export type DeletedMessageChanDiscussionEventFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    /**
     * Filter, which DeletedMessageChanDiscussionEvent to fetch.
     */
    where: DeletedMessageChanDiscussionEventWhereUniqueInput
  }

  /**
   * DeletedMessageChanDiscussionEvent findUnique
   */
  export interface DeletedMessageChanDiscussionEventFindUniqueArgs extends DeletedMessageChanDiscussionEventFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeletedMessageChanDiscussionEvent findUniqueOrThrow
   */
  export type DeletedMessageChanDiscussionEventFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    /**
     * Filter, which DeletedMessageChanDiscussionEvent to fetch.
     */
    where: DeletedMessageChanDiscussionEventWhereUniqueInput
  }


  /**
   * DeletedMessageChanDiscussionEvent base type for findFirst actions
   */
  export type DeletedMessageChanDiscussionEventFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    /**
     * Filter, which DeletedMessageChanDiscussionEvent to fetch.
     */
    where?: DeletedMessageChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedMessageChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<DeletedMessageChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedMessageChanDiscussionEvents.
     */
    cursor?: DeletedMessageChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedMessageChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedMessageChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletedMessageChanDiscussionEvents.
     */
    distinct?: Enumerable<DeletedMessageChanDiscussionEventScalarFieldEnum>
  }

  /**
   * DeletedMessageChanDiscussionEvent findFirst
   */
  export interface DeletedMessageChanDiscussionEventFindFirstArgs extends DeletedMessageChanDiscussionEventFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeletedMessageChanDiscussionEvent findFirstOrThrow
   */
  export type DeletedMessageChanDiscussionEventFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    /**
     * Filter, which DeletedMessageChanDiscussionEvent to fetch.
     */
    where?: DeletedMessageChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedMessageChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<DeletedMessageChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedMessageChanDiscussionEvents.
     */
    cursor?: DeletedMessageChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedMessageChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedMessageChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletedMessageChanDiscussionEvents.
     */
    distinct?: Enumerable<DeletedMessageChanDiscussionEventScalarFieldEnum>
  }


  /**
   * DeletedMessageChanDiscussionEvent findMany
   */
  export type DeletedMessageChanDiscussionEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    /**
     * Filter, which DeletedMessageChanDiscussionEvents to fetch.
     */
    where?: DeletedMessageChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedMessageChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<DeletedMessageChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeletedMessageChanDiscussionEvents.
     */
    cursor?: DeletedMessageChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedMessageChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedMessageChanDiscussionEvents.
     */
    skip?: number
    distinct?: Enumerable<DeletedMessageChanDiscussionEventScalarFieldEnum>
  }


  /**
   * DeletedMessageChanDiscussionEvent create
   */
  export type DeletedMessageChanDiscussionEventCreateArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    /**
     * The data needed to create a DeletedMessageChanDiscussionEvent.
     */
    data: XOR<DeletedMessageChanDiscussionEventCreateInput, DeletedMessageChanDiscussionEventUncheckedCreateInput>
  }


  /**
   * DeletedMessageChanDiscussionEvent createMany
   */
  export type DeletedMessageChanDiscussionEventCreateManyArgs = {
    /**
     * The data used to create many DeletedMessageChanDiscussionEvents.
     */
    data: Enumerable<DeletedMessageChanDiscussionEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DeletedMessageChanDiscussionEvent update
   */
  export type DeletedMessageChanDiscussionEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    /**
     * The data needed to update a DeletedMessageChanDiscussionEvent.
     */
    data: XOR<DeletedMessageChanDiscussionEventUpdateInput, DeletedMessageChanDiscussionEventUncheckedUpdateInput>
    /**
     * Choose, which DeletedMessageChanDiscussionEvent to update.
     */
    where: DeletedMessageChanDiscussionEventWhereUniqueInput
  }


  /**
   * DeletedMessageChanDiscussionEvent updateMany
   */
  export type DeletedMessageChanDiscussionEventUpdateManyArgs = {
    /**
     * The data used to update DeletedMessageChanDiscussionEvents.
     */
    data: XOR<DeletedMessageChanDiscussionEventUpdateManyMutationInput, DeletedMessageChanDiscussionEventUncheckedUpdateManyInput>
    /**
     * Filter which DeletedMessageChanDiscussionEvents to update
     */
    where?: DeletedMessageChanDiscussionEventWhereInput
  }


  /**
   * DeletedMessageChanDiscussionEvent upsert
   */
  export type DeletedMessageChanDiscussionEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    /**
     * The filter to search for the DeletedMessageChanDiscussionEvent to update in case it exists.
     */
    where: DeletedMessageChanDiscussionEventWhereUniqueInput
    /**
     * In case the DeletedMessageChanDiscussionEvent found by the `where` argument doesn't exist, create a new DeletedMessageChanDiscussionEvent with this data.
     */
    create: XOR<DeletedMessageChanDiscussionEventCreateInput, DeletedMessageChanDiscussionEventUncheckedCreateInput>
    /**
     * In case the DeletedMessageChanDiscussionEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeletedMessageChanDiscussionEventUpdateInput, DeletedMessageChanDiscussionEventUncheckedUpdateInput>
  }


  /**
   * DeletedMessageChanDiscussionEvent delete
   */
  export type DeletedMessageChanDiscussionEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
    /**
     * Filter which DeletedMessageChanDiscussionEvent to delete.
     */
    where: DeletedMessageChanDiscussionEventWhereUniqueInput
  }


  /**
   * DeletedMessageChanDiscussionEvent deleteMany
   */
  export type DeletedMessageChanDiscussionEventDeleteManyArgs = {
    /**
     * Filter which DeletedMessageChanDiscussionEvents to delete
     */
    where?: DeletedMessageChanDiscussionEventWhereInput
  }


  /**
   * DeletedMessageChanDiscussionEvent.chanDiscussionEvent
   */
  export type DeletedMessageChanDiscussionEvent$chanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    where?: ChanDiscussionEventWhereInput
  }


  /**
   * DeletedMessageChanDiscussionEvent without action
   */
  export type DeletedMessageChanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the DeletedMessageChanDiscussionEvent
     */
    select?: DeletedMessageChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeletedMessageChanDiscussionEventInclude | null
  }



  /**
   * Model ClassicChanDiscussionEvent
   */


  export type AggregateClassicChanDiscussionEvent = {
    _count: ClassicChanDiscussionEventCountAggregateOutputType | null
    _min: ClassicChanDiscussionEventMinAggregateOutputType | null
    _max: ClassicChanDiscussionEventMaxAggregateOutputType | null
  }

  export type ClassicChanDiscussionEventMinAggregateOutputType = {
    id: string | null
    eventType: ClassicChanEventType | null
  }

  export type ClassicChanDiscussionEventMaxAggregateOutputType = {
    id: string | null
    eventType: ClassicChanEventType | null
  }

  export type ClassicChanDiscussionEventCountAggregateOutputType = {
    id: number
    eventType: number
    _all: number
  }


  export type ClassicChanDiscussionEventMinAggregateInputType = {
    id?: true
    eventType?: true
  }

  export type ClassicChanDiscussionEventMaxAggregateInputType = {
    id?: true
    eventType?: true
  }

  export type ClassicChanDiscussionEventCountAggregateInputType = {
    id?: true
    eventType?: true
    _all?: true
  }

  export type ClassicChanDiscussionEventAggregateArgs = {
    /**
     * Filter which ClassicChanDiscussionEvent to aggregate.
     */
    where?: ClassicChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassicChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ClassicChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassicChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassicChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassicChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassicChanDiscussionEvents
    **/
    _count?: true | ClassicChanDiscussionEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassicChanDiscussionEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassicChanDiscussionEventMaxAggregateInputType
  }

  export type GetClassicChanDiscussionEventAggregateType<T extends ClassicChanDiscussionEventAggregateArgs> = {
        [P in keyof T & keyof AggregateClassicChanDiscussionEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassicChanDiscussionEvent[P]>
      : GetScalarType<T[P], AggregateClassicChanDiscussionEvent[P]>
  }




  export type ClassicChanDiscussionEventGroupByArgs = {
    where?: ClassicChanDiscussionEventWhereInput
    orderBy?: Enumerable<ClassicChanDiscussionEventOrderByWithAggregationInput>
    by: ClassicChanDiscussionEventScalarFieldEnum[]
    having?: ClassicChanDiscussionEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassicChanDiscussionEventCountAggregateInputType | true
    _min?: ClassicChanDiscussionEventMinAggregateInputType
    _max?: ClassicChanDiscussionEventMaxAggregateInputType
  }


  export type ClassicChanDiscussionEventGroupByOutputType = {
    id: string
    eventType: ClassicChanEventType
    _count: ClassicChanDiscussionEventCountAggregateOutputType | null
    _min: ClassicChanDiscussionEventMinAggregateOutputType | null
    _max: ClassicChanDiscussionEventMaxAggregateOutputType | null
  }

  type GetClassicChanDiscussionEventGroupByPayload<T extends ClassicChanDiscussionEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ClassicChanDiscussionEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassicChanDiscussionEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassicChanDiscussionEventGroupByOutputType[P]>
            : GetScalarType<T[P], ClassicChanDiscussionEventGroupByOutputType[P]>
        }
      >
    >


  export type ClassicChanDiscussionEventSelect = {
    id?: boolean
    eventType?: boolean
    chanDiscussionEvent?: boolean | ClassicChanDiscussionEvent$chanDiscussionEventArgs
  }


  export type ClassicChanDiscussionEventInclude = {
    chanDiscussionEvent?: boolean | ClassicChanDiscussionEvent$chanDiscussionEventArgs
  }

  export type ClassicChanDiscussionEventGetPayload<S extends boolean | null | undefined | ClassicChanDiscussionEventArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClassicChanDiscussionEvent :
    S extends undefined ? never :
    S extends { include: any } & (ClassicChanDiscussionEventArgs | ClassicChanDiscussionEventFindManyArgs)
    ? ClassicChanDiscussionEvent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'chanDiscussionEvent' ? ChanDiscussionEventGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ClassicChanDiscussionEventArgs | ClassicChanDiscussionEventFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'chanDiscussionEvent' ? ChanDiscussionEventGetPayload<S['select'][P]> | null :  P extends keyof ClassicChanDiscussionEvent ? ClassicChanDiscussionEvent[P] : never
  } 
      : ClassicChanDiscussionEvent


  type ClassicChanDiscussionEventCountArgs = 
    Omit<ClassicChanDiscussionEventFindManyArgs, 'select' | 'include'> & {
      select?: ClassicChanDiscussionEventCountAggregateInputType | true
    }

  export interface ClassicChanDiscussionEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ClassicChanDiscussionEvent that matches the filter.
     * @param {ClassicChanDiscussionEventFindUniqueArgs} args - Arguments to find a ClassicChanDiscussionEvent
     * @example
     * // Get one ClassicChanDiscussionEvent
     * const classicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClassicChanDiscussionEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClassicChanDiscussionEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ClassicChanDiscussionEvent'> extends True ? Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T>> : Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T> | null, null>

    /**
     * Find one ClassicChanDiscussionEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClassicChanDiscussionEventFindUniqueOrThrowArgs} args - Arguments to find a ClassicChanDiscussionEvent
     * @example
     * // Get one ClassicChanDiscussionEvent
     * const classicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClassicChanDiscussionEventFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClassicChanDiscussionEventFindUniqueOrThrowArgs>
    ): Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T>>

    /**
     * Find the first ClassicChanDiscussionEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicChanDiscussionEventFindFirstArgs} args - Arguments to find a ClassicChanDiscussionEvent
     * @example
     * // Get one ClassicChanDiscussionEvent
     * const classicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClassicChanDiscussionEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClassicChanDiscussionEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ClassicChanDiscussionEvent'> extends True ? Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T>> : Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T> | null, null>

    /**
     * Find the first ClassicChanDiscussionEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicChanDiscussionEventFindFirstOrThrowArgs} args - Arguments to find a ClassicChanDiscussionEvent
     * @example
     * // Get one ClassicChanDiscussionEvent
     * const classicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClassicChanDiscussionEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClassicChanDiscussionEventFindFirstOrThrowArgs>
    ): Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T>>

    /**
     * Find zero or more ClassicChanDiscussionEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicChanDiscussionEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassicChanDiscussionEvents
     * const classicChanDiscussionEvents = await prisma.classicChanDiscussionEvent.findMany()
     * 
     * // Get first 10 ClassicChanDiscussionEvents
     * const classicChanDiscussionEvents = await prisma.classicChanDiscussionEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classicChanDiscussionEventWithIdOnly = await prisma.classicChanDiscussionEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClassicChanDiscussionEventFindManyArgs>(
      args?: SelectSubset<T, ClassicChanDiscussionEventFindManyArgs>
    ): Prisma.PrismaPromise<Array<ClassicChanDiscussionEventGetPayload<T>>>

    /**
     * Create a ClassicChanDiscussionEvent.
     * @param {ClassicChanDiscussionEventCreateArgs} args - Arguments to create a ClassicChanDiscussionEvent.
     * @example
     * // Create one ClassicChanDiscussionEvent
     * const ClassicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.create({
     *   data: {
     *     // ... data to create a ClassicChanDiscussionEvent
     *   }
     * })
     * 
    **/
    create<T extends ClassicChanDiscussionEventCreateArgs>(
      args: SelectSubset<T, ClassicChanDiscussionEventCreateArgs>
    ): Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T>>

    /**
     * Create many ClassicChanDiscussionEvents.
     *     @param {ClassicChanDiscussionEventCreateManyArgs} args - Arguments to create many ClassicChanDiscussionEvents.
     *     @example
     *     // Create many ClassicChanDiscussionEvents
     *     const classicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClassicChanDiscussionEventCreateManyArgs>(
      args?: SelectSubset<T, ClassicChanDiscussionEventCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassicChanDiscussionEvent.
     * @param {ClassicChanDiscussionEventDeleteArgs} args - Arguments to delete one ClassicChanDiscussionEvent.
     * @example
     * // Delete one ClassicChanDiscussionEvent
     * const ClassicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.delete({
     *   where: {
     *     // ... filter to delete one ClassicChanDiscussionEvent
     *   }
     * })
     * 
    **/
    delete<T extends ClassicChanDiscussionEventDeleteArgs>(
      args: SelectSubset<T, ClassicChanDiscussionEventDeleteArgs>
    ): Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T>>

    /**
     * Update one ClassicChanDiscussionEvent.
     * @param {ClassicChanDiscussionEventUpdateArgs} args - Arguments to update one ClassicChanDiscussionEvent.
     * @example
     * // Update one ClassicChanDiscussionEvent
     * const classicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClassicChanDiscussionEventUpdateArgs>(
      args: SelectSubset<T, ClassicChanDiscussionEventUpdateArgs>
    ): Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T>>

    /**
     * Delete zero or more ClassicChanDiscussionEvents.
     * @param {ClassicChanDiscussionEventDeleteManyArgs} args - Arguments to filter ClassicChanDiscussionEvents to delete.
     * @example
     * // Delete a few ClassicChanDiscussionEvents
     * const { count } = await prisma.classicChanDiscussionEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClassicChanDiscussionEventDeleteManyArgs>(
      args?: SelectSubset<T, ClassicChanDiscussionEventDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassicChanDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicChanDiscussionEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassicChanDiscussionEvents
     * const classicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClassicChanDiscussionEventUpdateManyArgs>(
      args: SelectSubset<T, ClassicChanDiscussionEventUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassicChanDiscussionEvent.
     * @param {ClassicChanDiscussionEventUpsertArgs} args - Arguments to update or create a ClassicChanDiscussionEvent.
     * @example
     * // Update or create a ClassicChanDiscussionEvent
     * const classicChanDiscussionEvent = await prisma.classicChanDiscussionEvent.upsert({
     *   create: {
     *     // ... data to create a ClassicChanDiscussionEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassicChanDiscussionEvent we want to update
     *   }
     * })
    **/
    upsert<T extends ClassicChanDiscussionEventUpsertArgs>(
      args: SelectSubset<T, ClassicChanDiscussionEventUpsertArgs>
    ): Prisma__ClassicChanDiscussionEventClient<ClassicChanDiscussionEventGetPayload<T>>

    /**
     * Count the number of ClassicChanDiscussionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicChanDiscussionEventCountArgs} args - Arguments to filter ClassicChanDiscussionEvents to count.
     * @example
     * // Count the number of ClassicChanDiscussionEvents
     * const count = await prisma.classicChanDiscussionEvent.count({
     *   where: {
     *     // ... the filter for the ClassicChanDiscussionEvents we want to count
     *   }
     * })
    **/
    count<T extends ClassicChanDiscussionEventCountArgs>(
      args?: Subset<T, ClassicChanDiscussionEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassicChanDiscussionEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassicChanDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicChanDiscussionEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassicChanDiscussionEventAggregateArgs>(args: Subset<T, ClassicChanDiscussionEventAggregateArgs>): Prisma.PrismaPromise<GetClassicChanDiscussionEventAggregateType<T>>

    /**
     * Group by ClassicChanDiscussionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassicChanDiscussionEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassicChanDiscussionEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassicChanDiscussionEventGroupByArgs['orderBy'] }
        : { orderBy?: ClassicChanDiscussionEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassicChanDiscussionEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassicChanDiscussionEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassicChanDiscussionEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClassicChanDiscussionEventClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chanDiscussionEvent<T extends ClassicChanDiscussionEvent$chanDiscussionEventArgs= {}>(args?: Subset<T, ClassicChanDiscussionEvent$chanDiscussionEventArgs>): Prisma__ChanDiscussionEventClient<ChanDiscussionEventGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ClassicChanDiscussionEvent base type for findUnique actions
   */
  export type ClassicChanDiscussionEventFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    /**
     * Filter, which ClassicChanDiscussionEvent to fetch.
     */
    where: ClassicChanDiscussionEventWhereUniqueInput
  }

  /**
   * ClassicChanDiscussionEvent findUnique
   */
  export interface ClassicChanDiscussionEventFindUniqueArgs extends ClassicChanDiscussionEventFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClassicChanDiscussionEvent findUniqueOrThrow
   */
  export type ClassicChanDiscussionEventFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    /**
     * Filter, which ClassicChanDiscussionEvent to fetch.
     */
    where: ClassicChanDiscussionEventWhereUniqueInput
  }


  /**
   * ClassicChanDiscussionEvent base type for findFirst actions
   */
  export type ClassicChanDiscussionEventFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    /**
     * Filter, which ClassicChanDiscussionEvent to fetch.
     */
    where?: ClassicChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassicChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ClassicChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassicChanDiscussionEvents.
     */
    cursor?: ClassicChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassicChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassicChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassicChanDiscussionEvents.
     */
    distinct?: Enumerable<ClassicChanDiscussionEventScalarFieldEnum>
  }

  /**
   * ClassicChanDiscussionEvent findFirst
   */
  export interface ClassicChanDiscussionEventFindFirstArgs extends ClassicChanDiscussionEventFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClassicChanDiscussionEvent findFirstOrThrow
   */
  export type ClassicChanDiscussionEventFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    /**
     * Filter, which ClassicChanDiscussionEvent to fetch.
     */
    where?: ClassicChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassicChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ClassicChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassicChanDiscussionEvents.
     */
    cursor?: ClassicChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassicChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassicChanDiscussionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassicChanDiscussionEvents.
     */
    distinct?: Enumerable<ClassicChanDiscussionEventScalarFieldEnum>
  }


  /**
   * ClassicChanDiscussionEvent findMany
   */
  export type ClassicChanDiscussionEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    /**
     * Filter, which ClassicChanDiscussionEvents to fetch.
     */
    where?: ClassicChanDiscussionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassicChanDiscussionEvents to fetch.
     */
    orderBy?: Enumerable<ClassicChanDiscussionEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassicChanDiscussionEvents.
     */
    cursor?: ClassicChanDiscussionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassicChanDiscussionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassicChanDiscussionEvents.
     */
    skip?: number
    distinct?: Enumerable<ClassicChanDiscussionEventScalarFieldEnum>
  }


  /**
   * ClassicChanDiscussionEvent create
   */
  export type ClassicChanDiscussionEventCreateArgs = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    /**
     * The data needed to create a ClassicChanDiscussionEvent.
     */
    data: XOR<ClassicChanDiscussionEventCreateInput, ClassicChanDiscussionEventUncheckedCreateInput>
  }


  /**
   * ClassicChanDiscussionEvent createMany
   */
  export type ClassicChanDiscussionEventCreateManyArgs = {
    /**
     * The data used to create many ClassicChanDiscussionEvents.
     */
    data: Enumerable<ClassicChanDiscussionEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ClassicChanDiscussionEvent update
   */
  export type ClassicChanDiscussionEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    /**
     * The data needed to update a ClassicChanDiscussionEvent.
     */
    data: XOR<ClassicChanDiscussionEventUpdateInput, ClassicChanDiscussionEventUncheckedUpdateInput>
    /**
     * Choose, which ClassicChanDiscussionEvent to update.
     */
    where: ClassicChanDiscussionEventWhereUniqueInput
  }


  /**
   * ClassicChanDiscussionEvent updateMany
   */
  export type ClassicChanDiscussionEventUpdateManyArgs = {
    /**
     * The data used to update ClassicChanDiscussionEvents.
     */
    data: XOR<ClassicChanDiscussionEventUpdateManyMutationInput, ClassicChanDiscussionEventUncheckedUpdateManyInput>
    /**
     * Filter which ClassicChanDiscussionEvents to update
     */
    where?: ClassicChanDiscussionEventWhereInput
  }


  /**
   * ClassicChanDiscussionEvent upsert
   */
  export type ClassicChanDiscussionEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    /**
     * The filter to search for the ClassicChanDiscussionEvent to update in case it exists.
     */
    where: ClassicChanDiscussionEventWhereUniqueInput
    /**
     * In case the ClassicChanDiscussionEvent found by the `where` argument doesn't exist, create a new ClassicChanDiscussionEvent with this data.
     */
    create: XOR<ClassicChanDiscussionEventCreateInput, ClassicChanDiscussionEventUncheckedCreateInput>
    /**
     * In case the ClassicChanDiscussionEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassicChanDiscussionEventUpdateInput, ClassicChanDiscussionEventUncheckedUpdateInput>
  }


  /**
   * ClassicChanDiscussionEvent delete
   */
  export type ClassicChanDiscussionEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
    /**
     * Filter which ClassicChanDiscussionEvent to delete.
     */
    where: ClassicChanDiscussionEventWhereUniqueInput
  }


  /**
   * ClassicChanDiscussionEvent deleteMany
   */
  export type ClassicChanDiscussionEventDeleteManyArgs = {
    /**
     * Filter which ClassicChanDiscussionEvents to delete
     */
    where?: ClassicChanDiscussionEventWhereInput
  }


  /**
   * ClassicChanDiscussionEvent.chanDiscussionEvent
   */
  export type ClassicChanDiscussionEvent$chanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ChanDiscussionEvent
     */
    select?: ChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChanDiscussionEventInclude | null
    where?: ChanDiscussionEventWhereInput
  }


  /**
   * ClassicChanDiscussionEvent without action
   */
  export type ClassicChanDiscussionEventArgs = {
    /**
     * Select specific fields to fetch from the ClassicChanDiscussionEvent
     */
    select?: ClassicChanDiscussionEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassicChanDiscussionEventInclude | null
  }



  /**
   * Enums
   */

  export const BlockedShipScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    modificationDate: 'modificationDate',
    blockingUserName: 'blockingUserName',
    blockedUserName: 'blockedUserName'
  };

  export type BlockedShipScalarFieldEnum = (typeof BlockedShipScalarFieldEnum)[keyof typeof BlockedShipScalarFieldEnum]


  export const ChanDiscussionElementScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    eventId: 'eventId',
    authorName: 'authorName',
    creationDate: 'creationDate',
    modificationDate: 'modificationDate',
    chanId: 'chanId'
  };

  export type ChanDiscussionElementScalarFieldEnum = (typeof ChanDiscussionElementScalarFieldEnum)[keyof typeof ChanDiscussionElementScalarFieldEnum]


  export const ChanDiscussionEventScalarFieldEnum: {
    id: 'id',
    concernedUserName: 'concernedUserName',
    classicChanDiscussionEventId: 'classicChanDiscussionEventId',
    changedTitleChanDiscussionEventId: 'changedTitleChanDiscussionEventId',
    deletedMessageChanDiscussionEventId: 'deletedMessageChanDiscussionEventId'
  };

  export type ChanDiscussionEventScalarFieldEnum = (typeof ChanDiscussionEventScalarFieldEnum)[keyof typeof ChanDiscussionEventScalarFieldEnum]


  export const ChanDiscussionMessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    relatedTo: 'relatedTo'
  };

  export type ChanDiscussionMessageScalarFieldEnum = (typeof ChanDiscussionMessageScalarFieldEnum)[keyof typeof ChanDiscussionMessageScalarFieldEnum]


  export const ChanInvitationDmDiscussionEventScalarFieldEnum: {
    id: 'id',
    chanInvitationId: 'chanInvitationId'
  };

  export type ChanInvitationDmDiscussionEventScalarFieldEnum = (typeof ChanInvitationDmDiscussionEventScalarFieldEnum)[keyof typeof ChanInvitationDmDiscussionEventScalarFieldEnum]


  export const ChanInvitationScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    modificationDate: 'modificationDate',
    chanId: 'chanId',
    chanTitle: 'chanTitle',
    invitingUserName: 'invitingUserName',
    invitedUserName: 'invitedUserName',
    status: 'status'
  };

  export type ChanInvitationScalarFieldEnum = (typeof ChanInvitationScalarFieldEnum)[keyof typeof ChanInvitationScalarFieldEnum]


  export const ChanScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    password: 'password',
    creationDate: 'creationDate',
    modificationDate: 'modificationDate',
    ownerName: 'ownerName'
  };

  export type ChanScalarFieldEnum = (typeof ChanScalarFieldEnum)[keyof typeof ChanScalarFieldEnum]


  export const ChangedTitleChanDiscussionEventScalarFieldEnum: {
    id: 'id',
    oldTitle: 'oldTitle',
    newTitle: 'newTitle'
  };

  export type ChangedTitleChanDiscussionEventScalarFieldEnum = (typeof ChangedTitleChanDiscussionEventScalarFieldEnum)[keyof typeof ChangedTitleChanDiscussionEventScalarFieldEnum]


  export const ClassicChanDiscussionEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType'
  };

  export type ClassicChanDiscussionEventScalarFieldEnum = (typeof ClassicChanDiscussionEventScalarFieldEnum)[keyof typeof ClassicChanDiscussionEventScalarFieldEnum]


  export const ClassicDmDiscussionEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType'
  };

  export type ClassicDmDiscussionEventScalarFieldEnum = (typeof ClassicDmDiscussionEventScalarFieldEnum)[keyof typeof ClassicDmDiscussionEventScalarFieldEnum]


  export const DeletedMessageChanDiscussionEventScalarFieldEnum: {
    id: 'id',
    deletingUserName: 'deletingUserName'
  };

  export type DeletedMessageChanDiscussionEventScalarFieldEnum = (typeof DeletedMessageChanDiscussionEventScalarFieldEnum)[keyof typeof DeletedMessageChanDiscussionEventScalarFieldEnum]


  export const DirectMessageScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    modificationDate: 'modificationDate',
    requestingUserName: 'requestingUserName',
    requestingUserStatus: 'requestingUserStatus',
    requestingUserStatusMutedUntil: 'requestingUserStatusMutedUntil',
    requestedUserName: 'requestedUserName',
    requestedUserStatus: 'requestedUserStatus',
    requestedUserStatusMutedUntil: 'requestedUserStatusMutedUntil',
    status: 'status'
  };

  export type DirectMessageScalarFieldEnum = (typeof DirectMessageScalarFieldEnum)[keyof typeof DirectMessageScalarFieldEnum]


  export const DmDiscussionElementScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    eventId: 'eventId',
    author: 'author',
    creationDate: 'creationDate',
    modificationDate: 'modificationDate',
    directMessageId: 'directMessageId'
  };

  export type DmDiscussionElementScalarFieldEnum = (typeof DmDiscussionElementScalarFieldEnum)[keyof typeof DmDiscussionElementScalarFieldEnum]


  export const DmDiscussionEventScalarFieldEnum: {
    id: 'id',
    classicDmDiscussionEventId: 'classicDmDiscussionEventId',
    chanInvitationDmDiscussionEventId: 'chanInvitationDmDiscussionEventId'
  };

  export type DmDiscussionEventScalarFieldEnum = (typeof DmDiscussionEventScalarFieldEnum)[keyof typeof DmDiscussionEventScalarFieldEnum]


  export const DmDiscussionMessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    relatedTo: 'relatedTo'
  };

  export type DmDiscussionMessageScalarFieldEnum = (typeof DmDiscussionMessageScalarFieldEnum)[keyof typeof DmDiscussionMessageScalarFieldEnum]


  export const FriendInvitationScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    modificationDate: 'modificationDate',
    invitingUserName: 'invitingUserName',
    invitedUserName: 'invitedUserName',
    status: 'status'
  };

  export type FriendInvitationScalarFieldEnum = (typeof FriendInvitationScalarFieldEnum)[keyof typeof FriendInvitationScalarFieldEnum]


  export const FriendShipScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    modificationDate: 'modificationDate',
    requestingUserName: 'requestingUserName',
    requestedUserName: 'requestedUserName'
  };

  export type FriendShipScalarFieldEnum = (typeof FriendShipScalarFieldEnum)[keyof typeof FriendShipScalarFieldEnum]


  export const MutedUserChanScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    untilDate: 'untilDate',
    mutedUserName: 'mutedUserName',
    chanId: 'chanId'
  };

  export type MutedUserChanScalarFieldEnum = (typeof MutedUserChanScalarFieldEnum)[keyof typeof MutedUserChanScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    permissions: 'permissions',
    roleApplyOn: 'roleApplyOn',
    chanId: 'chanId'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    name: 'name',
    password: 'password',
    dmPolicyLevel: 'dmPolicyLevel'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    permissions?: EnumPermissionListNullableListFilter
    roleApplyOn?: EnumRoleApplyingTypeFilter | RoleApplyingType
    chanId?: StringFilter | string
    roles?: RoleListRelationFilter
    rolesSym?: RoleListRelationFilter
    users?: UserListRelationFilter
    chan?: XOR<ChanRelationFilter, ChanWhereInput>
    relatedDiscussionMessage?: ChanDiscussionMessageListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    roleApplyOn?: SortOrder
    chanId?: SortOrder
    roles?: RoleOrderByRelationAggregateInput
    rolesSym?: RoleOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    chan?: ChanOrderByWithRelationInput
    relatedDiscussionMessage?: ChanDiscussionMessageOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chanId_name?: RoleChanId_nameCompoundUniqueInput
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    name?: StringFilter | string
    permissions?: EnumPermissionListNullableListFilter
    roleApplyOn?: EnumRoleApplyingTypeFilter | RoleApplyingType
    chanId?: StringFilter | string
    roles?: RoleListRelationFilter
    rolesSym?: RoleListRelationFilter
    users?: UserListRelationFilter
    chan?: XOR<ChanRelationFilter, ChanWhereInput>
    relatedDiscussionMessage?: ChanDiscussionMessageListRelationFilter
  }, "id" | "chanId_name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    roleApplyOn?: SortOrder
    chanId?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    permissions?: EnumPermissionListNullableListFilter
    roleApplyOn?: EnumRoleApplyingTypeWithAggregatesFilter | RoleApplyingType
    chanId?: StringWithAggregatesFilter | string
  }

  export type FriendInvitationWhereInput = {
    AND?: Enumerable<FriendInvitationWhereInput>
    OR?: Enumerable<FriendInvitationWhereInput>
    NOT?: Enumerable<FriendInvitationWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    invitingUserName?: StringFilter | string
    invitedUserName?: StringFilter | string
    status?: EnumFriendInvitationStatusFilter | FriendInvitationStatus
    invitingUser?: XOR<UserRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FriendInvitationOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
    invitingUser?: UserOrderByWithRelationInput
    invitedUser?: UserOrderByWithRelationInput
  }

  export type FriendInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Enumerable<FriendInvitationWhereInput>
    OR?: Enumerable<FriendInvitationWhereInput>
    NOT?: Enumerable<FriendInvitationWhereInput>
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    invitingUserName?: StringFilter | string
    invitedUserName?: StringFilter | string
    status?: EnumFriendInvitationStatusFilter | FriendInvitationStatus
    invitingUser?: XOR<UserRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type FriendInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
    _count?: FriendInvitationCountOrderByAggregateInput
    _max?: FriendInvitationMaxOrderByAggregateInput
    _min?: FriendInvitationMinOrderByAggregateInput
  }

  export type FriendInvitationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FriendInvitationScalarWhereWithAggregatesInput>
    OR?: Enumerable<FriendInvitationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FriendInvitationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    modificationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    invitingUserName?: StringWithAggregatesFilter | string
    invitedUserName?: StringWithAggregatesFilter | string
    status?: EnumFriendInvitationStatusWithAggregatesFilter | FriendInvitationStatus
  }

  export type ChanInvitationWhereInput = {
    AND?: Enumerable<ChanInvitationWhereInput>
    OR?: Enumerable<ChanInvitationWhereInput>
    NOT?: Enumerable<ChanInvitationWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    chanId?: StringFilter | string
    chanTitle?: StringFilter | string
    invitingUserName?: StringFilter | string
    invitedUserName?: StringFilter | string
    status?: EnumChanInvitationStatusFilter | ChanInvitationStatus
    chan?: XOR<ChanRelationFilter, ChanWhereInput>
    discussionEvent?: XOR<ChanInvitationDmDiscussionEventRelationFilter, ChanInvitationDmDiscussionEventWhereInput> | null
    invitingUser?: XOR<UserRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChanInvitationOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
    chanTitle?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
    chan?: ChanOrderByWithRelationInput
    discussionEvent?: ChanInvitationDmDiscussionEventOrderByWithRelationInput
    invitingUser?: UserOrderByWithRelationInput
    invitedUser?: UserOrderByWithRelationInput
  }

  export type ChanInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Enumerable<ChanInvitationWhereInput>
    OR?: Enumerable<ChanInvitationWhereInput>
    NOT?: Enumerable<ChanInvitationWhereInput>
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    chanId?: StringFilter | string
    chanTitle?: StringFilter | string
    invitingUserName?: StringFilter | string
    invitedUserName?: StringFilter | string
    status?: EnumChanInvitationStatusFilter | ChanInvitationStatus
    chan?: XOR<ChanRelationFilter, ChanWhereInput>
    discussionEvent?: XOR<ChanInvitationDmDiscussionEventRelationFilter, ChanInvitationDmDiscussionEventWhereInput> | null
    invitingUser?: XOR<UserRelationFilter, UserWhereInput>
    invitedUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChanInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
    chanTitle?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
    _count?: ChanInvitationCountOrderByAggregateInput
    _max?: ChanInvitationMaxOrderByAggregateInput
    _min?: ChanInvitationMinOrderByAggregateInput
  }

  export type ChanInvitationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChanInvitationScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChanInvitationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChanInvitationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    modificationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    chanId?: StringWithAggregatesFilter | string
    chanTitle?: StringWithAggregatesFilter | string
    invitingUserName?: StringWithAggregatesFilter | string
    invitedUserName?: StringWithAggregatesFilter | string
    status?: EnumChanInvitationStatusWithAggregatesFilter | ChanInvitationStatus
  }

  export type FriendShipWhereInput = {
    AND?: Enumerable<FriendShipWhereInput>
    OR?: Enumerable<FriendShipWhereInput>
    NOT?: Enumerable<FriendShipWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    requestingUserName?: StringFilter | string
    requestedUserName?: StringFilter | string
    requestingUser?: XOR<UserRelationFilter, UserWhereInput>
    requestedUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FriendShipOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestedUserName?: SortOrder
    requestingUser?: UserOrderByWithRelationInput
    requestedUser?: UserOrderByWithRelationInput
  }

  export type FriendShipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requestingUserName_requestedUserName?: FriendShipRequestingUserNameRequestedUserNameCompoundUniqueInput
    AND?: Enumerable<FriendShipWhereInput>
    OR?: Enumerable<FriendShipWhereInput>
    NOT?: Enumerable<FriendShipWhereInput>
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    requestingUserName?: StringFilter | string
    requestedUserName?: StringFilter | string
    requestingUser?: XOR<UserRelationFilter, UserWhereInput>
    requestedUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "requestingUserName_requestedUserName">

  export type FriendShipOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestedUserName?: SortOrder
    _count?: FriendShipCountOrderByAggregateInput
    _max?: FriendShipMaxOrderByAggregateInput
    _min?: FriendShipMinOrderByAggregateInput
  }

  export type FriendShipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FriendShipScalarWhereWithAggregatesInput>
    OR?: Enumerable<FriendShipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FriendShipScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    modificationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    requestingUserName?: StringWithAggregatesFilter | string
    requestedUserName?: StringWithAggregatesFilter | string
  }

  export type BlockedShipWhereInput = {
    AND?: Enumerable<BlockedShipWhereInput>
    OR?: Enumerable<BlockedShipWhereInput>
    NOT?: Enumerable<BlockedShipWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    blockingUserName?: StringFilter | string
    blockedUserName?: StringFilter | string
    blockingUser?: XOR<UserRelationFilter, UserWhereInput>
    blockedUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BlockedShipOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    blockingUserName?: SortOrder
    blockedUserName?: SortOrder
    blockingUser?: UserOrderByWithRelationInput
    blockedUser?: UserOrderByWithRelationInput
  }

  export type BlockedShipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockingUserName_blockedUserName?: BlockedShipBlockingUserNameBlockedUserNameCompoundUniqueInput
    AND?: Enumerable<BlockedShipWhereInput>
    OR?: Enumerable<BlockedShipWhereInput>
    NOT?: Enumerable<BlockedShipWhereInput>
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    blockingUserName?: StringFilter | string
    blockedUserName?: StringFilter | string
    blockingUser?: XOR<UserRelationFilter, UserWhereInput>
    blockedUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "blockingUserName_blockedUserName">

  export type BlockedShipOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    blockingUserName?: SortOrder
    blockedUserName?: SortOrder
    _count?: BlockedShipCountOrderByAggregateInput
    _max?: BlockedShipMaxOrderByAggregateInput
    _min?: BlockedShipMinOrderByAggregateInput
  }

  export type BlockedShipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BlockedShipScalarWhereWithAggregatesInput>
    OR?: Enumerable<BlockedShipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BlockedShipScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    modificationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    blockingUserName?: StringWithAggregatesFilter | string
    blockedUserName?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    name?: StringFilter | string
    password?: StringFilter | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFilter | dmPolicyLevelType
    roles?: RoleListRelationFilter
    directMessage?: DirectMessageListRelationFilter
    directMessageOf?: DirectMessageListRelationFilter
    chans?: ChanListRelationFilter
    ownedChans?: ChanListRelationFilter
    friend?: FriendShipListRelationFilter
    friendOf?: FriendShipListRelationFilter
    outcomingFriendInvitation?: FriendInvitationListRelationFilter
    incomingFriendInvitation?: FriendInvitationListRelationFilter
    outcomingChanInvitation?: ChanInvitationListRelationFilter
    incomingChanInvitation?: ChanInvitationListRelationFilter
    blockedUser?: BlockedShipListRelationFilter
    blockedByUser?: BlockedShipListRelationFilter
    chanDiscussionElement?: ChanDiscussionElementListRelationFilter
    chanDiscussionEvent?: ChanDiscussionEventListRelationFilter
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventListRelationFilter
    chanDiscussionMessage?: ChanDiscussionMessageListRelationFilter
    dmDiscussionElement?: DmDiscussionElementListRelationFilter
    dmDiscussionMessage?: DmDiscussionMessageListRelationFilter
    mutedUserChan?: MutedUserChanListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    name?: SortOrder
    password?: SortOrder
    dmPolicyLevel?: SortOrder
    roles?: RoleOrderByRelationAggregateInput
    directMessage?: DirectMessageOrderByRelationAggregateInput
    directMessageOf?: DirectMessageOrderByRelationAggregateInput
    chans?: ChanOrderByRelationAggregateInput
    ownedChans?: ChanOrderByRelationAggregateInput
    friend?: FriendShipOrderByRelationAggregateInput
    friendOf?: FriendShipOrderByRelationAggregateInput
    outcomingFriendInvitation?: FriendInvitationOrderByRelationAggregateInput
    incomingFriendInvitation?: FriendInvitationOrderByRelationAggregateInput
    outcomingChanInvitation?: ChanInvitationOrderByRelationAggregateInput
    incomingChanInvitation?: ChanInvitationOrderByRelationAggregateInput
    blockedUser?: BlockedShipOrderByRelationAggregateInput
    blockedByUser?: BlockedShipOrderByRelationAggregateInput
    chanDiscussionElement?: ChanDiscussionElementOrderByRelationAggregateInput
    chanDiscussionEvent?: ChanDiscussionEventOrderByRelationAggregateInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventOrderByRelationAggregateInput
    chanDiscussionMessage?: ChanDiscussionMessageOrderByRelationAggregateInput
    dmDiscussionElement?: DmDiscussionElementOrderByRelationAggregateInput
    dmDiscussionMessage?: DmDiscussionMessageOrderByRelationAggregateInput
    mutedUserChan?: MutedUserChanOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    password?: StringFilter | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFilter | dmPolicyLevelType
    roles?: RoleListRelationFilter
    directMessage?: DirectMessageListRelationFilter
    directMessageOf?: DirectMessageListRelationFilter
    chans?: ChanListRelationFilter
    ownedChans?: ChanListRelationFilter
    friend?: FriendShipListRelationFilter
    friendOf?: FriendShipListRelationFilter
    outcomingFriendInvitation?: FriendInvitationListRelationFilter
    incomingFriendInvitation?: FriendInvitationListRelationFilter
    outcomingChanInvitation?: ChanInvitationListRelationFilter
    incomingChanInvitation?: ChanInvitationListRelationFilter
    blockedUser?: BlockedShipListRelationFilter
    blockedByUser?: BlockedShipListRelationFilter
    chanDiscussionElement?: ChanDiscussionElementListRelationFilter
    chanDiscussionEvent?: ChanDiscussionEventListRelationFilter
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventListRelationFilter
    chanDiscussionMessage?: ChanDiscussionMessageListRelationFilter
    dmDiscussionElement?: DmDiscussionElementListRelationFilter
    dmDiscussionMessage?: DmDiscussionMessageListRelationFilter
    mutedUserChan?: MutedUserChanListRelationFilter
  }, "name">

  export type UserOrderByWithAggregationInput = {
    name?: SortOrder
    password?: SortOrder
    dmPolicyLevel?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    name?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeWithAggregatesFilter | dmPolicyLevelType
  }

  export type DirectMessageWhereInput = {
    AND?: Enumerable<DirectMessageWhereInput>
    OR?: Enumerable<DirectMessageWhereInput>
    NOT?: Enumerable<DirectMessageWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    requestingUserName?: StringFilter | string
    requestingUserStatus?: EnumDirectMessageUserStatusFilter | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: DateTimeNullableFilter | Date | string | null
    requestedUserName?: StringFilter | string
    requestedUserStatus?: EnumDirectMessageUserStatusFilter | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: DateTimeNullableFilter | Date | string | null
    status?: EnumDirectMessageStatusFilter | DirectMessageStatus
    requestingUser?: XOR<UserRelationFilter, UserWhereInput>
    requestedUser?: XOR<UserRelationFilter, UserWhereInput>
    elements?: DmDiscussionElementListRelationFilter
  }

  export type DirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestingUserStatus?: SortOrder
    requestingUserStatusMutedUntil?: SortOrder
    requestedUserName?: SortOrder
    requestedUserStatus?: SortOrder
    requestedUserStatusMutedUntil?: SortOrder
    status?: SortOrder
    requestingUser?: UserOrderByWithRelationInput
    requestedUser?: UserOrderByWithRelationInput
    elements?: DmDiscussionElementOrderByRelationAggregateInput
  }

  export type DirectMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requestingUserName_requestedUserName?: DirectMessageRequestingUserNameRequestedUserNameCompoundUniqueInput
    AND?: Enumerable<DirectMessageWhereInput>
    OR?: Enumerable<DirectMessageWhereInput>
    NOT?: Enumerable<DirectMessageWhereInput>
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    requestingUserName?: StringFilter | string
    requestingUserStatus?: EnumDirectMessageUserStatusFilter | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: DateTimeNullableFilter | Date | string | null
    requestedUserName?: StringFilter | string
    requestedUserStatus?: EnumDirectMessageUserStatusFilter | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: DateTimeNullableFilter | Date | string | null
    status?: EnumDirectMessageStatusFilter | DirectMessageStatus
    requestingUser?: XOR<UserRelationFilter, UserWhereInput>
    requestedUser?: XOR<UserRelationFilter, UserWhereInput>
    elements?: DmDiscussionElementListRelationFilter
  }, "id" | "requestingUserName_requestedUserName">

  export type DirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestingUserStatus?: SortOrder
    requestingUserStatusMutedUntil?: SortOrder
    requestedUserName?: SortOrder
    requestedUserStatus?: SortOrder
    requestedUserStatusMutedUntil?: SortOrder
    status?: SortOrder
    _count?: DirectMessageCountOrderByAggregateInput
    _max?: DirectMessageMaxOrderByAggregateInput
    _min?: DirectMessageMinOrderByAggregateInput
  }

  export type DirectMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    modificationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    requestingUserName?: StringWithAggregatesFilter | string
    requestingUserStatus?: EnumDirectMessageUserStatusWithAggregatesFilter | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: DateTimeNullableWithAggregatesFilter | Date | string | null
    requestedUserName?: StringWithAggregatesFilter | string
    requestedUserStatus?: EnumDirectMessageUserStatusWithAggregatesFilter | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: EnumDirectMessageStatusWithAggregatesFilter | DirectMessageStatus
  }

  export type DmDiscussionElementWhereInput = {
    AND?: Enumerable<DmDiscussionElementWhereInput>
    OR?: Enumerable<DmDiscussionElementWhereInput>
    NOT?: Enumerable<DmDiscussionElementWhereInput>
    id?: StringFilter | string
    messageId?: StringNullableFilter | string | null
    eventId?: StringNullableFilter | string | null
    author?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    directMessageId?: StringFilter | string
    message?: XOR<DmDiscussionMessageRelationFilter, DmDiscussionMessageWhereInput> | null
    event?: XOR<DmDiscussionEventRelationFilter, DmDiscussionEventWhereInput> | null
    relatedOf?: DmDiscussionMessageListRelationFilter
    authorRelation?: XOR<UserRelationFilter, UserWhereInput>
    directMessage?: XOR<DirectMessageRelationFilter, DirectMessageWhereInput>
  }

  export type DmDiscussionElementOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    author?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    directMessageId?: SortOrder
    message?: DmDiscussionMessageOrderByWithRelationInput
    event?: DmDiscussionEventOrderByWithRelationInput
    relatedOf?: DmDiscussionMessageOrderByRelationAggregateInput
    authorRelation?: UserOrderByWithRelationInput
    directMessage?: DirectMessageOrderByWithRelationInput
  }

  export type DmDiscussionElementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    eventId?: string
    AND?: Enumerable<DmDiscussionElementWhereInput>
    OR?: Enumerable<DmDiscussionElementWhereInput>
    NOT?: Enumerable<DmDiscussionElementWhereInput>
    author?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    directMessageId?: StringFilter | string
    message?: XOR<DmDiscussionMessageRelationFilter, DmDiscussionMessageWhereInput> | null
    event?: XOR<DmDiscussionEventRelationFilter, DmDiscussionEventWhereInput> | null
    relatedOf?: DmDiscussionMessageListRelationFilter
    authorRelation?: XOR<UserRelationFilter, UserWhereInput>
    directMessage?: XOR<DirectMessageRelationFilter, DirectMessageWhereInput>
  }, "id" | "messageId" | "eventId">

  export type DmDiscussionElementOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    author?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    directMessageId?: SortOrder
    _count?: DmDiscussionElementCountOrderByAggregateInput
    _max?: DmDiscussionElementMaxOrderByAggregateInput
    _min?: DmDiscussionElementMinOrderByAggregateInput
  }

  export type DmDiscussionElementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DmDiscussionElementScalarWhereWithAggregatesInput>
    OR?: Enumerable<DmDiscussionElementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DmDiscussionElementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    messageId?: StringNullableWithAggregatesFilter | string | null
    eventId?: StringNullableWithAggregatesFilter | string | null
    author?: StringWithAggregatesFilter | string
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    modificationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    directMessageId?: StringWithAggregatesFilter | string
  }

  export type DmDiscussionMessageWhereInput = {
    AND?: Enumerable<DmDiscussionMessageWhereInput>
    OR?: Enumerable<DmDiscussionMessageWhereInput>
    NOT?: Enumerable<DmDiscussionMessageWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    relatedTo?: StringNullableFilter | string | null
    relatedUsers?: UserListRelationFilter
    related?: XOR<DmDiscussionElementRelationFilter, DmDiscussionElementWhereInput> | null
    discussionElement?: XOR<DmDiscussionElementRelationFilter, DmDiscussionElementWhereInput> | null
  }

  export type DmDiscussionMessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
    relatedUsers?: UserOrderByRelationAggregateInput
    related?: DmDiscussionElementOrderByWithRelationInput
    discussionElement?: DmDiscussionElementOrderByWithRelationInput
  }

  export type DmDiscussionMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Enumerable<DmDiscussionMessageWhereInput>
    OR?: Enumerable<DmDiscussionMessageWhereInput>
    NOT?: Enumerable<DmDiscussionMessageWhereInput>
    content?: StringFilter | string
    relatedTo?: StringNullableFilter | string | null
    relatedUsers?: UserListRelationFilter
    related?: XOR<DmDiscussionElementRelationFilter, DmDiscussionElementWhereInput> | null
    discussionElement?: XOR<DmDiscussionElementRelationFilter, DmDiscussionElementWhereInput> | null
  }, "id">

  export type DmDiscussionMessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
    _count?: DmDiscussionMessageCountOrderByAggregateInput
    _max?: DmDiscussionMessageMaxOrderByAggregateInput
    _min?: DmDiscussionMessageMinOrderByAggregateInput
  }

  export type DmDiscussionMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DmDiscussionMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<DmDiscussionMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DmDiscussionMessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    relatedTo?: StringNullableWithAggregatesFilter | string | null
  }

  export type DmDiscussionEventWhereInput = {
    AND?: Enumerable<DmDiscussionEventWhereInput>
    OR?: Enumerable<DmDiscussionEventWhereInput>
    NOT?: Enumerable<DmDiscussionEventWhereInput>
    id?: StringFilter | string
    classicDmDiscussionEventId?: StringNullableFilter | string | null
    chanInvitationDmDiscussionEventId?: StringNullableFilter | string | null
    classicDmDiscussionEvent?: XOR<ClassicDmDiscussionEventRelationFilter, ClassicDmDiscussionEventWhereInput> | null
    chanInvitationDmDiscussionEvent?: XOR<ChanInvitationDmDiscussionEventRelationFilter, ChanInvitationDmDiscussionEventWhereInput> | null
    discussionElement?: XOR<DmDiscussionElementRelationFilter, DmDiscussionElementWhereInput> | null
  }

  export type DmDiscussionEventOrderByWithRelationInput = {
    id?: SortOrder
    classicDmDiscussionEventId?: SortOrder
    chanInvitationDmDiscussionEventId?: SortOrder
    classicDmDiscussionEvent?: ClassicDmDiscussionEventOrderByWithRelationInput
    chanInvitationDmDiscussionEvent?: ChanInvitationDmDiscussionEventOrderByWithRelationInput
    discussionElement?: DmDiscussionElementOrderByWithRelationInput
  }

  export type DmDiscussionEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    classicDmDiscussionEventId?: string
    chanInvitationDmDiscussionEventId?: string
    AND?: Enumerable<DmDiscussionEventWhereInput>
    OR?: Enumerable<DmDiscussionEventWhereInput>
    NOT?: Enumerable<DmDiscussionEventWhereInput>
    classicDmDiscussionEvent?: XOR<ClassicDmDiscussionEventRelationFilter, ClassicDmDiscussionEventWhereInput> | null
    chanInvitationDmDiscussionEvent?: XOR<ChanInvitationDmDiscussionEventRelationFilter, ChanInvitationDmDiscussionEventWhereInput> | null
    discussionElement?: XOR<DmDiscussionElementRelationFilter, DmDiscussionElementWhereInput> | null
  }, "id" | "classicDmDiscussionEventId" | "chanInvitationDmDiscussionEventId">

  export type DmDiscussionEventOrderByWithAggregationInput = {
    id?: SortOrder
    classicDmDiscussionEventId?: SortOrder
    chanInvitationDmDiscussionEventId?: SortOrder
    _count?: DmDiscussionEventCountOrderByAggregateInput
    _max?: DmDiscussionEventMaxOrderByAggregateInput
    _min?: DmDiscussionEventMinOrderByAggregateInput
  }

  export type DmDiscussionEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DmDiscussionEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<DmDiscussionEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DmDiscussionEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    classicDmDiscussionEventId?: StringNullableWithAggregatesFilter | string | null
    chanInvitationDmDiscussionEventId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ChanInvitationDmDiscussionEventWhereInput = {
    AND?: Enumerable<ChanInvitationDmDiscussionEventWhereInput>
    OR?: Enumerable<ChanInvitationDmDiscussionEventWhereInput>
    NOT?: Enumerable<ChanInvitationDmDiscussionEventWhereInput>
    id?: StringFilter | string
    chanInvitationId?: StringFilter | string
    chanInvitation?: XOR<ChanInvitationRelationFilter, ChanInvitationWhereInput>
    dmDiscussionEvent?: XOR<DmDiscussionEventRelationFilter, DmDiscussionEventWhereInput> | null
  }

  export type ChanInvitationDmDiscussionEventOrderByWithRelationInput = {
    id?: SortOrder
    chanInvitationId?: SortOrder
    chanInvitation?: ChanInvitationOrderByWithRelationInput
    dmDiscussionEvent?: DmDiscussionEventOrderByWithRelationInput
  }

  export type ChanInvitationDmDiscussionEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chanInvitationId?: string
    AND?: Enumerable<ChanInvitationDmDiscussionEventWhereInput>
    OR?: Enumerable<ChanInvitationDmDiscussionEventWhereInput>
    NOT?: Enumerable<ChanInvitationDmDiscussionEventWhereInput>
    chanInvitation?: XOR<ChanInvitationRelationFilter, ChanInvitationWhereInput>
    dmDiscussionEvent?: XOR<DmDiscussionEventRelationFilter, DmDiscussionEventWhereInput> | null
  }, "id" | "chanInvitationId">

  export type ChanInvitationDmDiscussionEventOrderByWithAggregationInput = {
    id?: SortOrder
    chanInvitationId?: SortOrder
    _count?: ChanInvitationDmDiscussionEventCountOrderByAggregateInput
    _max?: ChanInvitationDmDiscussionEventMaxOrderByAggregateInput
    _min?: ChanInvitationDmDiscussionEventMinOrderByAggregateInput
  }

  export type ChanInvitationDmDiscussionEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChanInvitationDmDiscussionEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChanInvitationDmDiscussionEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChanInvitationDmDiscussionEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    chanInvitationId?: StringWithAggregatesFilter | string
  }

  export type ClassicDmDiscussionEventWhereInput = {
    AND?: Enumerable<ClassicDmDiscussionEventWhereInput>
    OR?: Enumerable<ClassicDmDiscussionEventWhereInput>
    NOT?: Enumerable<ClassicDmDiscussionEventWhereInput>
    id?: StringFilter | string
    eventType?: EnumClassicDmEventTypeFilter | ClassicDmEventType
    dmDiscussionEvent?: XOR<DmDiscussionEventRelationFilter, DmDiscussionEventWhereInput> | null
  }

  export type ClassicDmDiscussionEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    dmDiscussionEvent?: DmDiscussionEventOrderByWithRelationInput
  }

  export type ClassicDmDiscussionEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Enumerable<ClassicDmDiscussionEventWhereInput>
    OR?: Enumerable<ClassicDmDiscussionEventWhereInput>
    NOT?: Enumerable<ClassicDmDiscussionEventWhereInput>
    eventType?: EnumClassicDmEventTypeFilter | ClassicDmEventType
    dmDiscussionEvent?: XOR<DmDiscussionEventRelationFilter, DmDiscussionEventWhereInput> | null
  }, "id">

  export type ClassicDmDiscussionEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    _count?: ClassicDmDiscussionEventCountOrderByAggregateInput
    _max?: ClassicDmDiscussionEventMaxOrderByAggregateInput
    _min?: ClassicDmDiscussionEventMinOrderByAggregateInput
  }

  export type ClassicDmDiscussionEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClassicDmDiscussionEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClassicDmDiscussionEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClassicDmDiscussionEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    eventType?: EnumClassicDmEventTypeWithAggregatesFilter | ClassicDmEventType
  }

  export type ChanWhereInput = {
    AND?: Enumerable<ChanWhereInput>
    OR?: Enumerable<ChanWhereInput>
    NOT?: Enumerable<ChanWhereInput>
    id?: StringFilter | string
    type?: EnumChanTypeFilter | ChanType
    title?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    ownerName?: StringFilter | string
    users?: UserListRelationFilter
    roles?: RoleListRelationFilter
    owner?: XOR<UserRelationFilter, UserWhereInput>
    mutedUsers?: MutedUserChanListRelationFilter
    invitations?: ChanInvitationListRelationFilter
    elements?: ChanDiscussionElementListRelationFilter
  }

  export type ChanOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    password?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    ownerName?: SortOrder
    users?: UserOrderByRelationAggregateInput
    roles?: RoleOrderByRelationAggregateInput
    owner?: UserOrderByWithRelationInput
    mutedUsers?: MutedUserChanOrderByRelationAggregateInput
    invitations?: ChanInvitationOrderByRelationAggregateInput
    elements?: ChanDiscussionElementOrderByRelationAggregateInput
  }

  export type ChanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    id_title?: ChanIdTitleCompoundUniqueInput
    AND?: Enumerable<ChanWhereInput>
    OR?: Enumerable<ChanWhereInput>
    NOT?: Enumerable<ChanWhereInput>
    type?: EnumChanTypeFilter | ChanType
    password?: StringNullableFilter | string | null
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    ownerName?: StringFilter | string
    users?: UserListRelationFilter
    roles?: RoleListRelationFilter
    owner?: XOR<UserRelationFilter, UserWhereInput>
    mutedUsers?: MutedUserChanListRelationFilter
    invitations?: ChanInvitationListRelationFilter
    elements?: ChanDiscussionElementListRelationFilter
  }, "id" | "title" | "id_title">

  export type ChanOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    password?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    ownerName?: SortOrder
    _count?: ChanCountOrderByAggregateInput
    _max?: ChanMaxOrderByAggregateInput
    _min?: ChanMinOrderByAggregateInput
  }

  export type ChanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChanScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChanScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumChanTypeWithAggregatesFilter | ChanType
    title?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    modificationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ownerName?: StringWithAggregatesFilter | string
  }

  export type MutedUserChanWhereInput = {
    AND?: Enumerable<MutedUserChanWhereInput>
    OR?: Enumerable<MutedUserChanWhereInput>
    NOT?: Enumerable<MutedUserChanWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    untilDate?: DateTimeNullableFilter | Date | string | null
    mutedUserName?: StringFilter | string
    chanId?: StringFilter | string
    mutedUser?: XOR<UserRelationFilter, UserWhereInput>
    chan?: XOR<ChanRelationFilter, ChanWhereInput>
  }

  export type MutedUserChanOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    untilDate?: SortOrder
    mutedUserName?: SortOrder
    chanId?: SortOrder
    mutedUser?: UserOrderByWithRelationInput
    chan?: ChanOrderByWithRelationInput
  }

  export type MutedUserChanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chanId_mutedUserName?: MutedUserChanChanIdMutedUserNameCompoundUniqueInput
    AND?: Enumerable<MutedUserChanWhereInput>
    OR?: Enumerable<MutedUserChanWhereInput>
    NOT?: Enumerable<MutedUserChanWhereInput>
    creationDate?: DateTimeFilter | Date | string
    untilDate?: DateTimeNullableFilter | Date | string | null
    mutedUserName?: StringFilter | string
    chanId?: StringFilter | string
    mutedUser?: XOR<UserRelationFilter, UserWhereInput>
    chan?: XOR<ChanRelationFilter, ChanWhereInput>
  }, "id" | "chanId_mutedUserName">

  export type MutedUserChanOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    untilDate?: SortOrder
    mutedUserName?: SortOrder
    chanId?: SortOrder
    _count?: MutedUserChanCountOrderByAggregateInput
    _max?: MutedUserChanMaxOrderByAggregateInput
    _min?: MutedUserChanMinOrderByAggregateInput
  }

  export type MutedUserChanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MutedUserChanScalarWhereWithAggregatesInput>
    OR?: Enumerable<MutedUserChanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MutedUserChanScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    untilDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    mutedUserName?: StringWithAggregatesFilter | string
    chanId?: StringWithAggregatesFilter | string
  }

  export type ChanDiscussionElementWhereInput = {
    AND?: Enumerable<ChanDiscussionElementWhereInput>
    OR?: Enumerable<ChanDiscussionElementWhereInput>
    NOT?: Enumerable<ChanDiscussionElementWhereInput>
    id?: StringFilter | string
    messageId?: StringNullableFilter | string | null
    eventId?: StringNullableFilter | string | null
    authorName?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    chanId?: StringFilter | string
    message?: XOR<ChanDiscussionMessageRelationFilter, ChanDiscussionMessageWhereInput> | null
    event?: XOR<ChanDiscussionEventRelationFilter, ChanDiscussionEventWhereInput> | null
    relatedOf?: ChanDiscussionMessageListRelationFilter
    author?: XOR<UserRelationFilter, UserWhereInput>
    chan?: XOR<ChanRelationFilter, ChanWhereInput>
  }

  export type ChanDiscussionElementOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    authorName?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
    message?: ChanDiscussionMessageOrderByWithRelationInput
    event?: ChanDiscussionEventOrderByWithRelationInput
    relatedOf?: ChanDiscussionMessageOrderByRelationAggregateInput
    author?: UserOrderByWithRelationInput
    chan?: ChanOrderByWithRelationInput
  }

  export type ChanDiscussionElementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    eventId?: string
    AND?: Enumerable<ChanDiscussionElementWhereInput>
    OR?: Enumerable<ChanDiscussionElementWhereInput>
    NOT?: Enumerable<ChanDiscussionElementWhereInput>
    authorName?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    chanId?: StringFilter | string
    message?: XOR<ChanDiscussionMessageRelationFilter, ChanDiscussionMessageWhereInput> | null
    event?: XOR<ChanDiscussionEventRelationFilter, ChanDiscussionEventWhereInput> | null
    relatedOf?: ChanDiscussionMessageListRelationFilter
    author?: XOR<UserRelationFilter, UserWhereInput>
    chan?: XOR<ChanRelationFilter, ChanWhereInput>
  }, "id" | "messageId" | "eventId">

  export type ChanDiscussionElementOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    authorName?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
    _count?: ChanDiscussionElementCountOrderByAggregateInput
    _max?: ChanDiscussionElementMaxOrderByAggregateInput
    _min?: ChanDiscussionElementMinOrderByAggregateInput
  }

  export type ChanDiscussionElementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChanDiscussionElementScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChanDiscussionElementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChanDiscussionElementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    messageId?: StringNullableWithAggregatesFilter | string | null
    eventId?: StringNullableWithAggregatesFilter | string | null
    authorName?: StringWithAggregatesFilter | string
    creationDate?: DateTimeWithAggregatesFilter | Date | string
    modificationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    chanId?: StringWithAggregatesFilter | string
  }

  export type ChanDiscussionMessageWhereInput = {
    AND?: Enumerable<ChanDiscussionMessageWhereInput>
    OR?: Enumerable<ChanDiscussionMessageWhereInput>
    NOT?: Enumerable<ChanDiscussionMessageWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    relatedTo?: StringNullableFilter | string | null
    relatedUsers?: UserListRelationFilter
    relatedRoles?: RoleListRelationFilter
    related?: XOR<ChanDiscussionElementRelationFilter, ChanDiscussionElementWhereInput> | null
    discussionElement?: XOR<ChanDiscussionElementRelationFilter, ChanDiscussionElementWhereInput> | null
  }

  export type ChanDiscussionMessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
    relatedUsers?: UserOrderByRelationAggregateInput
    relatedRoles?: RoleOrderByRelationAggregateInput
    related?: ChanDiscussionElementOrderByWithRelationInput
    discussionElement?: ChanDiscussionElementOrderByWithRelationInput
  }

  export type ChanDiscussionMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Enumerable<ChanDiscussionMessageWhereInput>
    OR?: Enumerable<ChanDiscussionMessageWhereInput>
    NOT?: Enumerable<ChanDiscussionMessageWhereInput>
    content?: StringFilter | string
    relatedTo?: StringNullableFilter | string | null
    relatedUsers?: UserListRelationFilter
    relatedRoles?: RoleListRelationFilter
    related?: XOR<ChanDiscussionElementRelationFilter, ChanDiscussionElementWhereInput> | null
    discussionElement?: XOR<ChanDiscussionElementRelationFilter, ChanDiscussionElementWhereInput> | null
  }, "id">

  export type ChanDiscussionMessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
    _count?: ChanDiscussionMessageCountOrderByAggregateInput
    _max?: ChanDiscussionMessageMaxOrderByAggregateInput
    _min?: ChanDiscussionMessageMinOrderByAggregateInput
  }

  export type ChanDiscussionMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChanDiscussionMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChanDiscussionMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChanDiscussionMessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    relatedTo?: StringNullableWithAggregatesFilter | string | null
  }

  export type ChanDiscussionEventWhereInput = {
    AND?: Enumerable<ChanDiscussionEventWhereInput>
    OR?: Enumerable<ChanDiscussionEventWhereInput>
    NOT?: Enumerable<ChanDiscussionEventWhereInput>
    id?: StringFilter | string
    concernedUserName?: StringNullableFilter | string | null
    classicChanDiscussionEventId?: StringNullableFilter | string | null
    changedTitleChanDiscussionEventId?: StringNullableFilter | string | null
    deletedMessageChanDiscussionEventId?: StringNullableFilter | string | null
    concernedUser?: XOR<UserRelationFilter, UserWhereInput> | null
    classicChanDiscussionEvent?: XOR<ClassicChanDiscussionEventRelationFilter, ClassicChanDiscussionEventWhereInput> | null
    changedTitleChanDiscussionEvent?: XOR<ChangedTitleChanDiscussionEventRelationFilter, ChangedTitleChanDiscussionEventWhereInput> | null
    deletedMessageChanDiscussionEvent?: XOR<DeletedMessageChanDiscussionEventRelationFilter, DeletedMessageChanDiscussionEventWhereInput> | null
    discussionElement?: XOR<ChanDiscussionElementRelationFilter, ChanDiscussionElementWhereInput> | null
  }

  export type ChanDiscussionEventOrderByWithRelationInput = {
    id?: SortOrder
    concernedUserName?: SortOrder
    classicChanDiscussionEventId?: SortOrder
    changedTitleChanDiscussionEventId?: SortOrder
    deletedMessageChanDiscussionEventId?: SortOrder
    concernedUser?: UserOrderByWithRelationInput
    classicChanDiscussionEvent?: ClassicChanDiscussionEventOrderByWithRelationInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventOrderByWithRelationInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventOrderByWithRelationInput
    discussionElement?: ChanDiscussionElementOrderByWithRelationInput
  }

  export type ChanDiscussionEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    classicChanDiscussionEventId?: string
    changedTitleChanDiscussionEventId?: string
    deletedMessageChanDiscussionEventId?: string
    AND?: Enumerable<ChanDiscussionEventWhereInput>
    OR?: Enumerable<ChanDiscussionEventWhereInput>
    NOT?: Enumerable<ChanDiscussionEventWhereInput>
    concernedUserName?: StringNullableFilter | string | null
    concernedUser?: XOR<UserRelationFilter, UserWhereInput> | null
    classicChanDiscussionEvent?: XOR<ClassicChanDiscussionEventRelationFilter, ClassicChanDiscussionEventWhereInput> | null
    changedTitleChanDiscussionEvent?: XOR<ChangedTitleChanDiscussionEventRelationFilter, ChangedTitleChanDiscussionEventWhereInput> | null
    deletedMessageChanDiscussionEvent?: XOR<DeletedMessageChanDiscussionEventRelationFilter, DeletedMessageChanDiscussionEventWhereInput> | null
    discussionElement?: XOR<ChanDiscussionElementRelationFilter, ChanDiscussionElementWhereInput> | null
  }, "id" | "classicChanDiscussionEventId" | "changedTitleChanDiscussionEventId" | "deletedMessageChanDiscussionEventId">

  export type ChanDiscussionEventOrderByWithAggregationInput = {
    id?: SortOrder
    concernedUserName?: SortOrder
    classicChanDiscussionEventId?: SortOrder
    changedTitleChanDiscussionEventId?: SortOrder
    deletedMessageChanDiscussionEventId?: SortOrder
    _count?: ChanDiscussionEventCountOrderByAggregateInput
    _max?: ChanDiscussionEventMaxOrderByAggregateInput
    _min?: ChanDiscussionEventMinOrderByAggregateInput
  }

  export type ChanDiscussionEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChanDiscussionEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChanDiscussionEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChanDiscussionEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    concernedUserName?: StringNullableWithAggregatesFilter | string | null
    classicChanDiscussionEventId?: StringNullableWithAggregatesFilter | string | null
    changedTitleChanDiscussionEventId?: StringNullableWithAggregatesFilter | string | null
    deletedMessageChanDiscussionEventId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ChangedTitleChanDiscussionEventWhereInput = {
    AND?: Enumerable<ChangedTitleChanDiscussionEventWhereInput>
    OR?: Enumerable<ChangedTitleChanDiscussionEventWhereInput>
    NOT?: Enumerable<ChangedTitleChanDiscussionEventWhereInput>
    id?: StringFilter | string
    oldTitle?: StringFilter | string
    newTitle?: StringFilter | string
    chanDiscussionEvent?: XOR<ChanDiscussionEventRelationFilter, ChanDiscussionEventWhereInput> | null
  }

  export type ChangedTitleChanDiscussionEventOrderByWithRelationInput = {
    id?: SortOrder
    oldTitle?: SortOrder
    newTitle?: SortOrder
    chanDiscussionEvent?: ChanDiscussionEventOrderByWithRelationInput
  }

  export type ChangedTitleChanDiscussionEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Enumerable<ChangedTitleChanDiscussionEventWhereInput>
    OR?: Enumerable<ChangedTitleChanDiscussionEventWhereInput>
    NOT?: Enumerable<ChangedTitleChanDiscussionEventWhereInput>
    oldTitle?: StringFilter | string
    newTitle?: StringFilter | string
    chanDiscussionEvent?: XOR<ChanDiscussionEventRelationFilter, ChanDiscussionEventWhereInput> | null
  }, "id">

  export type ChangedTitleChanDiscussionEventOrderByWithAggregationInput = {
    id?: SortOrder
    oldTitle?: SortOrder
    newTitle?: SortOrder
    _count?: ChangedTitleChanDiscussionEventCountOrderByAggregateInput
    _max?: ChangedTitleChanDiscussionEventMaxOrderByAggregateInput
    _min?: ChangedTitleChanDiscussionEventMinOrderByAggregateInput
  }

  export type ChangedTitleChanDiscussionEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChangedTitleChanDiscussionEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChangedTitleChanDiscussionEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChangedTitleChanDiscussionEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    oldTitle?: StringWithAggregatesFilter | string
    newTitle?: StringWithAggregatesFilter | string
  }

  export type DeletedMessageChanDiscussionEventWhereInput = {
    AND?: Enumerable<DeletedMessageChanDiscussionEventWhereInput>
    OR?: Enumerable<DeletedMessageChanDiscussionEventWhereInput>
    NOT?: Enumerable<DeletedMessageChanDiscussionEventWhereInput>
    id?: StringFilter | string
    deletingUserName?: StringFilter | string
    deletingUsers?: XOR<UserRelationFilter, UserWhereInput>
    chanDiscussionEvent?: XOR<ChanDiscussionEventRelationFilter, ChanDiscussionEventWhereInput> | null
  }

  export type DeletedMessageChanDiscussionEventOrderByWithRelationInput = {
    id?: SortOrder
    deletingUserName?: SortOrder
    deletingUsers?: UserOrderByWithRelationInput
    chanDiscussionEvent?: ChanDiscussionEventOrderByWithRelationInput
  }

  export type DeletedMessageChanDiscussionEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deletingUserName?: string
    AND?: Enumerable<DeletedMessageChanDiscussionEventWhereInput>
    OR?: Enumerable<DeletedMessageChanDiscussionEventWhereInput>
    NOT?: Enumerable<DeletedMessageChanDiscussionEventWhereInput>
    deletingUsers?: XOR<UserRelationFilter, UserWhereInput>
    chanDiscussionEvent?: XOR<ChanDiscussionEventRelationFilter, ChanDiscussionEventWhereInput> | null
  }, "id" | "deletingUserName">

  export type DeletedMessageChanDiscussionEventOrderByWithAggregationInput = {
    id?: SortOrder
    deletingUserName?: SortOrder
    _count?: DeletedMessageChanDiscussionEventCountOrderByAggregateInput
    _max?: DeletedMessageChanDiscussionEventMaxOrderByAggregateInput
    _min?: DeletedMessageChanDiscussionEventMinOrderByAggregateInput
  }

  export type DeletedMessageChanDiscussionEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeletedMessageChanDiscussionEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeletedMessageChanDiscussionEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeletedMessageChanDiscussionEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    deletingUserName?: StringWithAggregatesFilter | string
  }

  export type ClassicChanDiscussionEventWhereInput = {
    AND?: Enumerable<ClassicChanDiscussionEventWhereInput>
    OR?: Enumerable<ClassicChanDiscussionEventWhereInput>
    NOT?: Enumerable<ClassicChanDiscussionEventWhereInput>
    id?: StringFilter | string
    eventType?: EnumClassicChanEventTypeFilter | ClassicChanEventType
    chanDiscussionEvent?: XOR<ChanDiscussionEventRelationFilter, ChanDiscussionEventWhereInput> | null
  }

  export type ClassicChanDiscussionEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    chanDiscussionEvent?: ChanDiscussionEventOrderByWithRelationInput
  }

  export type ClassicChanDiscussionEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Enumerable<ClassicChanDiscussionEventWhereInput>
    OR?: Enumerable<ClassicChanDiscussionEventWhereInput>
    NOT?: Enumerable<ClassicChanDiscussionEventWhereInput>
    eventType?: EnumClassicChanEventTypeFilter | ClassicChanEventType
    chanDiscussionEvent?: XOR<ChanDiscussionEventRelationFilter, ChanDiscussionEventWhereInput> | null
  }, "id">

  export type ClassicChanDiscussionEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    _count?: ClassicChanDiscussionEventCountOrderByAggregateInput
    _max?: ClassicChanDiscussionEventMaxOrderByAggregateInput
    _min?: ClassicChanDiscussionEventMinOrderByAggregateInput
  }

  export type ClassicChanDiscussionEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClassicChanDiscussionEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClassicChanDiscussionEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClassicChanDiscussionEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    eventType?: EnumClassicChanEventTypeWithAggregatesFilter | ClassicChanEventType
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    roles?: RoleCreateNestedManyWithoutRolesSymInput
    rolesSym?: RoleCreateNestedManyWithoutRolesInput
    users?: UserCreateNestedManyWithoutRolesInput
    chan: ChanCreateNestedOneWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    chanId: string
    roles?: RoleUncheckedCreateNestedManyWithoutRolesSymInput
    rolesSym?: RoleUncheckedCreateNestedManyWithoutRolesInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    roles?: RoleUpdateManyWithoutRolesSymNestedInput
    rolesSym?: RoleUpdateManyWithoutRolesNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
    chan?: ChanUpdateOneRequiredWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedRolesNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    chanId?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutRolesSymNestedInput
    rolesSym?: RoleUncheckedUpdateManyWithoutRolesNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedRolesNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    chanId: string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type FriendInvitationCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    status?: FriendInvitationStatus
    invitingUser: UserCreateNestedOneWithoutOutcomingFriendInvitationInput
    invitedUser: UserCreateNestedOneWithoutIncomingFriendInvitationInput
  }

  export type FriendInvitationUncheckedCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    invitingUserName: string
    invitedUserName: string
    status?: FriendInvitationStatus
  }

  export type FriendInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
    invitingUser?: UserUpdateOneRequiredWithoutOutcomingFriendInvitationNestedInput
    invitedUser?: UserUpdateOneRequiredWithoutIncomingFriendInvitationNestedInput
  }

  export type FriendInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitingUserName?: StringFieldUpdateOperationsInput | string
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
  }

  export type FriendInvitationCreateManyInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    invitingUserName: string
    invitedUserName: string
    status?: FriendInvitationStatus
  }

  export type FriendInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
  }

  export type FriendInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitingUserName?: StringFieldUpdateOperationsInput | string
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
  }

  export type ChanInvitationCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    status?: ChanInvitationStatus
    chan: ChanCreateNestedOneWithoutInvitationsInput
    discussionEvent?: ChanInvitationDmDiscussionEventCreateNestedOneWithoutChanInvitationInput
    invitingUser: UserCreateNestedOneWithoutOutcomingChanInvitationInput
    invitedUser: UserCreateNestedOneWithoutIncomingChanInvitationInput
  }

  export type ChanInvitationUncheckedCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    chanTitle: string
    invitingUserName: string
    invitedUserName: string
    status?: ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventUncheckedCreateNestedOneWithoutChanInvitationInput
  }

  export type ChanInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
    chan?: ChanUpdateOneRequiredWithoutInvitationsNestedInput
    discussionEvent?: ChanInvitationDmDiscussionEventUpdateOneWithoutChanInvitationNestedInput
    invitingUser?: UserUpdateOneRequiredWithoutOutcomingChanInvitationNestedInput
    invitedUser?: UserUpdateOneRequiredWithoutIncomingChanInvitationNestedInput
  }

  export type ChanInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    chanTitle?: StringFieldUpdateOperationsInput | string
    invitingUserName?: StringFieldUpdateOperationsInput | string
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventUncheckedUpdateOneWithoutChanInvitationNestedInput
  }

  export type ChanInvitationCreateManyInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    chanTitle: string
    invitingUserName: string
    invitedUserName: string
    status?: ChanInvitationStatus
  }

  export type ChanInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
  }

  export type ChanInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    chanTitle?: StringFieldUpdateOperationsInput | string
    invitingUserName?: StringFieldUpdateOperationsInput | string
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
  }

  export type FriendShipCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUser: UserCreateNestedOneWithoutFriendInput
    requestedUser: UserCreateNestedOneWithoutFriendOfInput
  }

  export type FriendShipUncheckedCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserName: string
    requestedUserName: string
  }

  export type FriendShipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUser?: UserUpdateOneRequiredWithoutFriendNestedInput
    requestedUser?: UserUpdateOneRequiredWithoutFriendOfNestedInput
  }

  export type FriendShipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserName?: StringFieldUpdateOperationsInput | string
    requestedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type FriendShipCreateManyInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserName: string
    requestedUserName: string
  }

  export type FriendShipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FriendShipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserName?: StringFieldUpdateOperationsInput | string
    requestedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type BlockedShipCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    blockingUser: UserCreateNestedOneWithoutBlockedUserInput
    blockedUser: UserCreateNestedOneWithoutBlockedByUserInput
  }

  export type BlockedShipUncheckedCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    blockingUserName: string
    blockedUserName: string
  }

  export type BlockedShipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockingUser?: UserUpdateOneRequiredWithoutBlockedUserNestedInput
    blockedUser?: UserUpdateOneRequiredWithoutBlockedByUserNestedInput
  }

  export type BlockedShipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockingUserName?: StringFieldUpdateOperationsInput | string
    blockedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type BlockedShipCreateManyInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    blockingUserName: string
    blockedUserName: string
  }

  export type BlockedShipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockedShipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockingUserName?: StringFieldUpdateOperationsInput | string
    blockedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserCreateManyInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
  }

  export type DirectMessageCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
    requestingUser: UserCreateNestedOneWithoutDirectMessageInput
    requestedUser: UserCreateNestedOneWithoutDirectMessageOfInput
    elements?: DmDiscussionElementCreateNestedManyWithoutDirectMessageInput
  }

  export type DirectMessageUncheckedCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserName: string
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserName: string
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
    elements?: DmDiscussionElementUncheckedCreateNestedManyWithoutDirectMessageInput
  }

  export type DirectMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
    requestingUser?: UserUpdateOneRequiredWithoutDirectMessageNestedInput
    requestedUser?: UserUpdateOneRequiredWithoutDirectMessageOfNestedInput
    elements?: DmDiscussionElementUpdateManyWithoutDirectMessageNestedInput
  }

  export type DirectMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserName?: StringFieldUpdateOperationsInput | string
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserName?: StringFieldUpdateOperationsInput | string
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
    elements?: DmDiscussionElementUncheckedUpdateManyWithoutDirectMessageNestedInput
  }

  export type DirectMessageCreateManyInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserName: string
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserName: string
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
  }

  export type DirectMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
  }

  export type DirectMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserName?: StringFieldUpdateOperationsInput | string
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserName?: StringFieldUpdateOperationsInput | string
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
  }

  export type DmDiscussionElementCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: DmDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    event?: DmDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: DmDiscussionMessageCreateNestedManyWithoutRelatedInput
    authorRelation: UserCreateNestedOneWithoutDmDiscussionElementInput
    directMessage: DirectMessageCreateNestedOneWithoutElementsInput
  }

  export type DmDiscussionElementUncheckedCreateInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    author: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    directMessageId: string
    relatedOf?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type DmDiscussionElementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: DmDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    event?: DmDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: DmDiscussionMessageUpdateManyWithoutRelatedNestedInput
    authorRelation?: UserUpdateOneRequiredWithoutDmDiscussionElementNestedInput
    directMessage?: DirectMessageUpdateOneRequiredWithoutElementsNestedInput
  }

  export type DmDiscussionElementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    author?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directMessageId?: StringFieldUpdateOperationsInput | string
    relatedOf?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type DmDiscussionElementCreateManyInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    author: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    directMessageId: string
  }

  export type DmDiscussionElementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DmDiscussionElementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    author?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directMessageId?: StringFieldUpdateOperationsInput | string
  }

  export type DmDiscussionMessageCreateInput = {
    id?: string
    content: string
    relatedUsers?: UserCreateNestedManyWithoutDmDiscussionMessageInput
    related?: DmDiscussionElementCreateNestedOneWithoutRelatedOfInput
    discussionElement?: DmDiscussionElementCreateNestedOneWithoutMessageInput
  }

  export type DmDiscussionMessageUncheckedCreateInput = {
    id?: string
    content: string
    relatedTo?: string | null
    relatedUsers?: UserUncheckedCreateNestedManyWithoutDmDiscussionMessageInput
    discussionElement?: DmDiscussionElementUncheckedCreateNestedOneWithoutMessageInput
  }

  export type DmDiscussionMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedUsers?: UserUpdateManyWithoutDmDiscussionMessageNestedInput
    related?: DmDiscussionElementUpdateOneWithoutRelatedOfNestedInput
    discussionElement?: DmDiscussionElementUpdateOneWithoutMessageNestedInput
  }

  export type DmDiscussionMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsers?: UserUncheckedUpdateManyWithoutDmDiscussionMessageNestedInput
    discussionElement?: DmDiscussionElementUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type DmDiscussionMessageCreateManyInput = {
    id?: string
    content: string
    relatedTo?: string | null
  }

  export type DmDiscussionMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type DmDiscussionMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DmDiscussionEventCreateInput = {
    id?: string
    classicDmDiscussionEvent?: ClassicDmDiscussionEventCreateNestedOneWithoutDmDiscussionEventInput
    chanInvitationDmDiscussionEvent?: ChanInvitationDmDiscussionEventCreateNestedOneWithoutDmDiscussionEventInput
    discussionElement?: DmDiscussionElementCreateNestedOneWithoutEventInput
  }

  export type DmDiscussionEventUncheckedCreateInput = {
    id?: string
    classicDmDiscussionEventId?: string | null
    chanInvitationDmDiscussionEventId?: string | null
    discussionElement?: DmDiscussionElementUncheckedCreateNestedOneWithoutEventInput
  }

  export type DmDiscussionEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicDmDiscussionEvent?: ClassicDmDiscussionEventUpdateOneWithoutDmDiscussionEventNestedInput
    chanInvitationDmDiscussionEvent?: ChanInvitationDmDiscussionEventUpdateOneWithoutDmDiscussionEventNestedInput
    discussionElement?: DmDiscussionElementUpdateOneWithoutEventNestedInput
  }

  export type DmDiscussionEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicDmDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    chanInvitationDmDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    discussionElement?: DmDiscussionElementUncheckedUpdateOneWithoutEventNestedInput
  }

  export type DmDiscussionEventCreateManyInput = {
    id?: string
    classicDmDiscussionEventId?: string | null
    chanInvitationDmDiscussionEventId?: string | null
  }

  export type DmDiscussionEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DmDiscussionEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicDmDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    chanInvitationDmDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChanInvitationDmDiscussionEventCreateInput = {
    id?: string
    chanInvitation: ChanInvitationCreateNestedOneWithoutDiscussionEventInput
    dmDiscussionEvent?: DmDiscussionEventCreateNestedOneWithoutChanInvitationDmDiscussionEventInput
  }

  export type ChanInvitationDmDiscussionEventUncheckedCreateInput = {
    id?: string
    chanInvitationId: string
    dmDiscussionEvent?: DmDiscussionEventUncheckedCreateNestedOneWithoutChanInvitationDmDiscussionEventInput
  }

  export type ChanInvitationDmDiscussionEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chanInvitation?: ChanInvitationUpdateOneRequiredWithoutDiscussionEventNestedInput
    dmDiscussionEvent?: DmDiscussionEventUpdateOneWithoutChanInvitationDmDiscussionEventNestedInput
  }

  export type ChanInvitationDmDiscussionEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chanInvitationId?: StringFieldUpdateOperationsInput | string
    dmDiscussionEvent?: DmDiscussionEventUncheckedUpdateOneWithoutChanInvitationDmDiscussionEventNestedInput
  }

  export type ChanInvitationDmDiscussionEventCreateManyInput = {
    id?: string
    chanInvitationId: string
  }

  export type ChanInvitationDmDiscussionEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ChanInvitationDmDiscussionEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chanInvitationId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassicDmDiscussionEventCreateInput = {
    id?: string
    eventType: ClassicDmEventType
    dmDiscussionEvent?: DmDiscussionEventCreateNestedOneWithoutClassicDmDiscussionEventInput
  }

  export type ClassicDmDiscussionEventUncheckedCreateInput = {
    id?: string
    eventType: ClassicDmEventType
    dmDiscussionEvent?: DmDiscussionEventUncheckedCreateNestedOneWithoutClassicDmDiscussionEventInput
  }

  export type ClassicDmDiscussionEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicDmEventTypeFieldUpdateOperationsInput | ClassicDmEventType
    dmDiscussionEvent?: DmDiscussionEventUpdateOneWithoutClassicDmDiscussionEventNestedInput
  }

  export type ClassicDmDiscussionEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicDmEventTypeFieldUpdateOperationsInput | ClassicDmEventType
    dmDiscussionEvent?: DmDiscussionEventUncheckedUpdateOneWithoutClassicDmDiscussionEventNestedInput
  }

  export type ClassicDmDiscussionEventCreateManyInput = {
    id?: string
    eventType: ClassicDmEventType
  }

  export type ClassicDmDiscussionEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicDmEventTypeFieldUpdateOperationsInput | ClassicDmEventType
  }

  export type ClassicDmDiscussionEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicDmEventTypeFieldUpdateOperationsInput | ClassicDmEventType
  }

  export type ChanCreateInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    users?: UserCreateNestedManyWithoutChansInput
    roles?: RoleCreateNestedManyWithoutChanInput
    owner: UserCreateNestedOneWithoutOwnedChansInput
    mutedUsers?: MutedUserChanCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementCreateNestedManyWithoutChanInput
  }

  export type ChanUncheckedCreateInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    ownerName: string
    users?: UserUncheckedCreateNestedManyWithoutChansInput
    roles?: RoleUncheckedCreateNestedManyWithoutChanInput
    mutedUsers?: MutedUserChanUncheckedCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationUncheckedCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementUncheckedCreateNestedManyWithoutChanInput
  }

  export type ChanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutChansNestedInput
    roles?: RoleUpdateManyWithoutChanNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedChansNestedInput
    mutedUsers?: MutedUserChanUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUpdateManyWithoutChanNestedInput
  }

  export type ChanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerName?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutChansNestedInput
    roles?: RoleUncheckedUpdateManyWithoutChanNestedInput
    mutedUsers?: MutedUserChanUncheckedUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUncheckedUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUncheckedUpdateManyWithoutChanNestedInput
  }

  export type ChanCreateManyInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    ownerName: string
  }

  export type ChanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerName?: StringFieldUpdateOperationsInput | string
  }

  export type MutedUserChanCreateInput = {
    id?: string
    creationDate?: Date | string
    untilDate?: Date | string | null
    mutedUser: UserCreateNestedOneWithoutMutedUserChanInput
    chan: ChanCreateNestedOneWithoutMutedUsersInput
  }

  export type MutedUserChanUncheckedCreateInput = {
    id?: string
    creationDate?: Date | string
    untilDate?: Date | string | null
    mutedUserName: string
    chanId: string
  }

  export type MutedUserChanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mutedUser?: UserUpdateOneRequiredWithoutMutedUserChanNestedInput
    chan?: ChanUpdateOneRequiredWithoutMutedUsersNestedInput
  }

  export type MutedUserChanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mutedUserName?: StringFieldUpdateOperationsInput | string
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type MutedUserChanCreateManyInput = {
    id?: string
    creationDate?: Date | string
    untilDate?: Date | string | null
    mutedUserName: string
    chanId: string
  }

  export type MutedUserChanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MutedUserChanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mutedUserName?: StringFieldUpdateOperationsInput | string
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type ChanDiscussionElementCreateInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: ChanDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    event?: ChanDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: ChanDiscussionMessageCreateNestedManyWithoutRelatedInput
    author: UserCreateNestedOneWithoutChanDiscussionElementInput
    chan: ChanCreateNestedOneWithoutElementsInput
  }

  export type ChanDiscussionElementUncheckedCreateInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    authorName: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    relatedOf?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type ChanDiscussionElementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: ChanDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    event?: ChanDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: ChanDiscussionMessageUpdateManyWithoutRelatedNestedInput
    author?: UserUpdateOneRequiredWithoutChanDiscussionElementNestedInput
    chan?: ChanUpdateOneRequiredWithoutElementsNestedInput
  }

  export type ChanDiscussionElementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    relatedOf?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type ChanDiscussionElementCreateManyInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    authorName: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
  }

  export type ChanDiscussionElementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChanDiscussionElementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type ChanDiscussionMessageCreateInput = {
    id?: string
    content: string
    relatedUsers?: UserCreateNestedManyWithoutChanDiscussionMessageInput
    relatedRoles?: RoleCreateNestedManyWithoutRelatedDiscussionMessageInput
    related?: ChanDiscussionElementCreateNestedOneWithoutRelatedOfInput
    discussionElement?: ChanDiscussionElementCreateNestedOneWithoutMessageInput
  }

  export type ChanDiscussionMessageUncheckedCreateInput = {
    id?: string
    content: string
    relatedTo?: string | null
    relatedUsers?: UserUncheckedCreateNestedManyWithoutChanDiscussionMessageInput
    relatedRoles?: RoleUncheckedCreateNestedManyWithoutRelatedDiscussionMessageInput
    discussionElement?: ChanDiscussionElementUncheckedCreateNestedOneWithoutMessageInput
  }

  export type ChanDiscussionMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedUsers?: UserUpdateManyWithoutChanDiscussionMessageNestedInput
    relatedRoles?: RoleUpdateManyWithoutRelatedDiscussionMessageNestedInput
    related?: ChanDiscussionElementUpdateOneWithoutRelatedOfNestedInput
    discussionElement?: ChanDiscussionElementUpdateOneWithoutMessageNestedInput
  }

  export type ChanDiscussionMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsers?: UserUncheckedUpdateManyWithoutChanDiscussionMessageNestedInput
    relatedRoles?: RoleUncheckedUpdateManyWithoutRelatedDiscussionMessageNestedInput
    discussionElement?: ChanDiscussionElementUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type ChanDiscussionMessageCreateManyInput = {
    id?: string
    content: string
    relatedTo?: string | null
  }

  export type ChanDiscussionMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ChanDiscussionMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChanDiscussionEventCreateInput = {
    id?: string
    concernedUser?: UserCreateNestedOneWithoutChanDiscussionEventInput
    classicChanDiscussionEvent?: ClassicChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    discussionElement?: ChanDiscussionElementCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventUncheckedCreateInput = {
    id?: string
    concernedUserName?: string | null
    classicChanDiscussionEventId?: string | null
    changedTitleChanDiscussionEventId?: string | null
    deletedMessageChanDiscussionEventId?: string | null
    discussionElement?: ChanDiscussionElementUncheckedCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUser?: UserUpdateOneWithoutChanDiscussionEventNestedInput
    classicChanDiscussionEvent?: ClassicChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    discussionElement?: ChanDiscussionElementUpdateOneWithoutEventNestedInput
  }

  export type ChanDiscussionEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    classicChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    changedTitleChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedMessageChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    discussionElement?: ChanDiscussionElementUncheckedUpdateOneWithoutEventNestedInput
  }

  export type ChanDiscussionEventCreateManyInput = {
    id?: string
    concernedUserName?: string | null
    classicChanDiscussionEventId?: string | null
    changedTitleChanDiscussionEventId?: string | null
    deletedMessageChanDiscussionEventId?: string | null
  }

  export type ChanDiscussionEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ChanDiscussionEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    classicChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    changedTitleChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedMessageChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangedTitleChanDiscussionEventCreateInput = {
    id?: string
    oldTitle: string
    newTitle: string
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedOneWithoutChangedTitleChanDiscussionEventInput
  }

  export type ChangedTitleChanDiscussionEventUncheckedCreateInput = {
    id?: string
    oldTitle: string
    newTitle: string
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedOneWithoutChangedTitleChanDiscussionEventInput
  }

  export type ChangedTitleChanDiscussionEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldTitle?: StringFieldUpdateOperationsInput | string
    newTitle?: StringFieldUpdateOperationsInput | string
    chanDiscussionEvent?: ChanDiscussionEventUpdateOneWithoutChangedTitleChanDiscussionEventNestedInput
  }

  export type ChangedTitleChanDiscussionEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldTitle?: StringFieldUpdateOperationsInput | string
    newTitle?: StringFieldUpdateOperationsInput | string
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateOneWithoutChangedTitleChanDiscussionEventNestedInput
  }

  export type ChangedTitleChanDiscussionEventCreateManyInput = {
    id?: string
    oldTitle: string
    newTitle: string
  }

  export type ChangedTitleChanDiscussionEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldTitle?: StringFieldUpdateOperationsInput | string
    newTitle?: StringFieldUpdateOperationsInput | string
  }

  export type ChangedTitleChanDiscussionEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldTitle?: StringFieldUpdateOperationsInput | string
    newTitle?: StringFieldUpdateOperationsInput | string
  }

  export type DeletedMessageChanDiscussionEventCreateInput = {
    id?: string
    deletingUsers: UserCreateNestedOneWithoutDeletedMessageChanDiscussionEventInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedOneWithoutDeletedMessageChanDiscussionEventInput
  }

  export type DeletedMessageChanDiscussionEventUncheckedCreateInput = {
    id?: string
    deletingUserName: string
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedOneWithoutDeletedMessageChanDiscussionEventInput
  }

  export type DeletedMessageChanDiscussionEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletingUsers?: UserUpdateOneRequiredWithoutDeletedMessageChanDiscussionEventNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateOneWithoutDeletedMessageChanDiscussionEventNestedInput
  }

  export type DeletedMessageChanDiscussionEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletingUserName?: StringFieldUpdateOperationsInput | string
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateOneWithoutDeletedMessageChanDiscussionEventNestedInput
  }

  export type DeletedMessageChanDiscussionEventCreateManyInput = {
    id?: string
    deletingUserName: string
  }

  export type DeletedMessageChanDiscussionEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DeletedMessageChanDiscussionEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletingUserName?: StringFieldUpdateOperationsInput | string
  }

  export type ClassicChanDiscussionEventCreateInput = {
    id?: string
    eventType: ClassicChanEventType
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedOneWithoutClassicChanDiscussionEventInput
  }

  export type ClassicChanDiscussionEventUncheckedCreateInput = {
    id?: string
    eventType: ClassicChanEventType
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedOneWithoutClassicChanDiscussionEventInput
  }

  export type ClassicChanDiscussionEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicChanEventTypeFieldUpdateOperationsInput | ClassicChanEventType
    chanDiscussionEvent?: ChanDiscussionEventUpdateOneWithoutClassicChanDiscussionEventNestedInput
  }

  export type ClassicChanDiscussionEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicChanEventTypeFieldUpdateOperationsInput | ClassicChanEventType
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateOneWithoutClassicChanDiscussionEventNestedInput
  }

  export type ClassicChanDiscussionEventCreateManyInput = {
    id?: string
    eventType: ClassicChanEventType
  }

  export type ClassicChanDiscussionEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicChanEventTypeFieldUpdateOperationsInput | ClassicChanEventType
  }

  export type ClassicChanDiscussionEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicChanEventTypeFieldUpdateOperationsInput | ClassicChanEventType
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type EnumPermissionListNullableListFilter = {
    equals?: Enumerable<PermissionList> | null
    has?: PermissionList | null
    hasEvery?: Enumerable<PermissionList>
    hasSome?: Enumerable<PermissionList>
    isEmpty?: boolean
  }

  export type EnumRoleApplyingTypeFilter = {
    equals?: RoleApplyingType
    in?: Enumerable<RoleApplyingType>
    notIn?: Enumerable<RoleApplyingType>
    not?: NestedEnumRoleApplyingTypeFilter | RoleApplyingType
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ChanRelationFilter = {
    is?: ChanWhereInput
    isNot?: ChanWhereInput
  }

  export type ChanDiscussionMessageListRelationFilter = {
    every?: ChanDiscussionMessageWhereInput
    some?: ChanDiscussionMessageWhereInput
    none?: ChanDiscussionMessageWhereInput
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChanDiscussionMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleChanId_nameCompoundUniqueInput = {
    chanId: string
    name: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    roleApplyOn?: SortOrder
    chanId?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    roleApplyOn?: SortOrder
    chanId?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    roleApplyOn?: SortOrder
    chanId?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumRoleApplyingTypeWithAggregatesFilter = {
    equals?: RoleApplyingType
    in?: Enumerable<RoleApplyingType>
    notIn?: Enumerable<RoleApplyingType>
    not?: NestedEnumRoleApplyingTypeWithAggregatesFilter | RoleApplyingType
    _count?: NestedIntFilter
    _min?: NestedEnumRoleApplyingTypeFilter
    _max?: NestedEnumRoleApplyingTypeFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type EnumFriendInvitationStatusFilter = {
    equals?: FriendInvitationStatus
    in?: Enumerable<FriendInvitationStatus>
    notIn?: Enumerable<FriendInvitationStatus>
    not?: NestedEnumFriendInvitationStatusFilter | FriendInvitationStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FriendInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
  }

  export type FriendInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
  }

  export type FriendInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type EnumFriendInvitationStatusWithAggregatesFilter = {
    equals?: FriendInvitationStatus
    in?: Enumerable<FriendInvitationStatus>
    notIn?: Enumerable<FriendInvitationStatus>
    not?: NestedEnumFriendInvitationStatusWithAggregatesFilter | FriendInvitationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumFriendInvitationStatusFilter
    _max?: NestedEnumFriendInvitationStatusFilter
  }

  export type EnumChanInvitationStatusFilter = {
    equals?: ChanInvitationStatus
    in?: Enumerable<ChanInvitationStatus>
    notIn?: Enumerable<ChanInvitationStatus>
    not?: NestedEnumChanInvitationStatusFilter | ChanInvitationStatus
  }

  export type ChanInvitationDmDiscussionEventRelationFilter = {
    is?: ChanInvitationDmDiscussionEventWhereInput | null
    isNot?: ChanInvitationDmDiscussionEventWhereInput | null
  }

  export type ChanInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
    chanTitle?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
  }

  export type ChanInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
    chanTitle?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
  }

  export type ChanInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
    chanTitle?: SortOrder
    invitingUserName?: SortOrder
    invitedUserName?: SortOrder
    status?: SortOrder
  }

  export type EnumChanInvitationStatusWithAggregatesFilter = {
    equals?: ChanInvitationStatus
    in?: Enumerable<ChanInvitationStatus>
    notIn?: Enumerable<ChanInvitationStatus>
    not?: NestedEnumChanInvitationStatusWithAggregatesFilter | ChanInvitationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumChanInvitationStatusFilter
    _max?: NestedEnumChanInvitationStatusFilter
  }

  export type FriendShipRequestingUserNameRequestedUserNameCompoundUniqueInput = {
    requestingUserName: string
    requestedUserName: string
  }

  export type FriendShipCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestedUserName?: SortOrder
  }

  export type FriendShipMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestedUserName?: SortOrder
  }

  export type FriendShipMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestedUserName?: SortOrder
  }

  export type BlockedShipBlockingUserNameBlockedUserNameCompoundUniqueInput = {
    blockingUserName: string
    blockedUserName: string
  }

  export type BlockedShipCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    blockingUserName?: SortOrder
    blockedUserName?: SortOrder
  }

  export type BlockedShipMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    blockingUserName?: SortOrder
    blockedUserName?: SortOrder
  }

  export type BlockedShipMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    blockingUserName?: SortOrder
    blockedUserName?: SortOrder
  }

  export type EnumdmPolicyLevelTypeFilter = {
    equals?: dmPolicyLevelType
    in?: Enumerable<dmPolicyLevelType>
    notIn?: Enumerable<dmPolicyLevelType>
    not?: NestedEnumdmPolicyLevelTypeFilter | dmPolicyLevelType
  }

  export type DirectMessageListRelationFilter = {
    every?: DirectMessageWhereInput
    some?: DirectMessageWhereInput
    none?: DirectMessageWhereInput
  }

  export type ChanListRelationFilter = {
    every?: ChanWhereInput
    some?: ChanWhereInput
    none?: ChanWhereInput
  }

  export type FriendShipListRelationFilter = {
    every?: FriendShipWhereInput
    some?: FriendShipWhereInput
    none?: FriendShipWhereInput
  }

  export type FriendInvitationListRelationFilter = {
    every?: FriendInvitationWhereInput
    some?: FriendInvitationWhereInput
    none?: FriendInvitationWhereInput
  }

  export type ChanInvitationListRelationFilter = {
    every?: ChanInvitationWhereInput
    some?: ChanInvitationWhereInput
    none?: ChanInvitationWhereInput
  }

  export type BlockedShipListRelationFilter = {
    every?: BlockedShipWhereInput
    some?: BlockedShipWhereInput
    none?: BlockedShipWhereInput
  }

  export type ChanDiscussionElementListRelationFilter = {
    every?: ChanDiscussionElementWhereInput
    some?: ChanDiscussionElementWhereInput
    none?: ChanDiscussionElementWhereInput
  }

  export type ChanDiscussionEventListRelationFilter = {
    every?: ChanDiscussionEventWhereInput
    some?: ChanDiscussionEventWhereInput
    none?: ChanDiscussionEventWhereInput
  }

  export type DeletedMessageChanDiscussionEventListRelationFilter = {
    every?: DeletedMessageChanDiscussionEventWhereInput
    some?: DeletedMessageChanDiscussionEventWhereInput
    none?: DeletedMessageChanDiscussionEventWhereInput
  }

  export type DmDiscussionElementListRelationFilter = {
    every?: DmDiscussionElementWhereInput
    some?: DmDiscussionElementWhereInput
    none?: DmDiscussionElementWhereInput
  }

  export type DmDiscussionMessageListRelationFilter = {
    every?: DmDiscussionMessageWhereInput
    some?: DmDiscussionMessageWhereInput
    none?: DmDiscussionMessageWhereInput
  }

  export type MutedUserChanListRelationFilter = {
    every?: MutedUserChanWhereInput
    some?: MutedUserChanWhereInput
    none?: MutedUserChanWhereInput
  }

  export type DirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendShipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChanInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockedShipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChanDiscussionElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChanDiscussionEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeletedMessageChanDiscussionEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DmDiscussionElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DmDiscussionMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MutedUserChanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    name?: SortOrder
    password?: SortOrder
    dmPolicyLevel?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    name?: SortOrder
    password?: SortOrder
    dmPolicyLevel?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    name?: SortOrder
    password?: SortOrder
    dmPolicyLevel?: SortOrder
  }

  export type EnumdmPolicyLevelTypeWithAggregatesFilter = {
    equals?: dmPolicyLevelType
    in?: Enumerable<dmPolicyLevelType>
    notIn?: Enumerable<dmPolicyLevelType>
    not?: NestedEnumdmPolicyLevelTypeWithAggregatesFilter | dmPolicyLevelType
    _count?: NestedIntFilter
    _min?: NestedEnumdmPolicyLevelTypeFilter
    _max?: NestedEnumdmPolicyLevelTypeFilter
  }

  export type EnumDirectMessageUserStatusFilter = {
    equals?: DirectMessageUserStatus
    in?: Enumerable<DirectMessageUserStatus>
    notIn?: Enumerable<DirectMessageUserStatus>
    not?: NestedEnumDirectMessageUserStatusFilter | DirectMessageUserStatus
  }

  export type EnumDirectMessageStatusFilter = {
    equals?: DirectMessageStatus
    in?: Enumerable<DirectMessageStatus>
    notIn?: Enumerable<DirectMessageStatus>
    not?: NestedEnumDirectMessageStatusFilter | DirectMessageStatus
  }

  export type DirectMessageRequestingUserNameRequestedUserNameCompoundUniqueInput = {
    requestingUserName: string
    requestedUserName: string
  }

  export type DirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestingUserStatus?: SortOrder
    requestingUserStatusMutedUntil?: SortOrder
    requestedUserName?: SortOrder
    requestedUserStatus?: SortOrder
    requestedUserStatusMutedUntil?: SortOrder
    status?: SortOrder
  }

  export type DirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestingUserStatus?: SortOrder
    requestingUserStatusMutedUntil?: SortOrder
    requestedUserName?: SortOrder
    requestedUserStatus?: SortOrder
    requestedUserStatusMutedUntil?: SortOrder
    status?: SortOrder
  }

  export type DirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    requestingUserName?: SortOrder
    requestingUserStatus?: SortOrder
    requestingUserStatusMutedUntil?: SortOrder
    requestedUserName?: SortOrder
    requestedUserStatus?: SortOrder
    requestedUserStatusMutedUntil?: SortOrder
    status?: SortOrder
  }

  export type EnumDirectMessageUserStatusWithAggregatesFilter = {
    equals?: DirectMessageUserStatus
    in?: Enumerable<DirectMessageUserStatus>
    notIn?: Enumerable<DirectMessageUserStatus>
    not?: NestedEnumDirectMessageUserStatusWithAggregatesFilter | DirectMessageUserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumDirectMessageUserStatusFilter
    _max?: NestedEnumDirectMessageUserStatusFilter
  }

  export type EnumDirectMessageStatusWithAggregatesFilter = {
    equals?: DirectMessageStatus
    in?: Enumerable<DirectMessageStatus>
    notIn?: Enumerable<DirectMessageStatus>
    not?: NestedEnumDirectMessageStatusWithAggregatesFilter | DirectMessageStatus
    _count?: NestedIntFilter
    _min?: NestedEnumDirectMessageStatusFilter
    _max?: NestedEnumDirectMessageStatusFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DmDiscussionMessageRelationFilter = {
    is?: DmDiscussionMessageWhereInput | null
    isNot?: DmDiscussionMessageWhereInput | null
  }

  export type DmDiscussionEventRelationFilter = {
    is?: DmDiscussionEventWhereInput | null
    isNot?: DmDiscussionEventWhereInput | null
  }

  export type DirectMessageRelationFilter = {
    is?: DirectMessageWhereInput
    isNot?: DirectMessageWhereInput
  }

  export type DmDiscussionElementCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    author?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    directMessageId?: SortOrder
  }

  export type DmDiscussionElementMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    author?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    directMessageId?: SortOrder
  }

  export type DmDiscussionElementMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    author?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    directMessageId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DmDiscussionElementRelationFilter = {
    is?: DmDiscussionElementWhereInput | null
    isNot?: DmDiscussionElementWhereInput | null
  }

  export type DmDiscussionMessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
  }

  export type DmDiscussionMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
  }

  export type DmDiscussionMessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
  }

  export type ClassicDmDiscussionEventRelationFilter = {
    is?: ClassicDmDiscussionEventWhereInput | null
    isNot?: ClassicDmDiscussionEventWhereInput | null
  }

  export type DmDiscussionEventCountOrderByAggregateInput = {
    id?: SortOrder
    classicDmDiscussionEventId?: SortOrder
    chanInvitationDmDiscussionEventId?: SortOrder
  }

  export type DmDiscussionEventMaxOrderByAggregateInput = {
    id?: SortOrder
    classicDmDiscussionEventId?: SortOrder
    chanInvitationDmDiscussionEventId?: SortOrder
  }

  export type DmDiscussionEventMinOrderByAggregateInput = {
    id?: SortOrder
    classicDmDiscussionEventId?: SortOrder
    chanInvitationDmDiscussionEventId?: SortOrder
  }

  export type ChanInvitationRelationFilter = {
    is?: ChanInvitationWhereInput
    isNot?: ChanInvitationWhereInput
  }

  export type ChanInvitationDmDiscussionEventCountOrderByAggregateInput = {
    id?: SortOrder
    chanInvitationId?: SortOrder
  }

  export type ChanInvitationDmDiscussionEventMaxOrderByAggregateInput = {
    id?: SortOrder
    chanInvitationId?: SortOrder
  }

  export type ChanInvitationDmDiscussionEventMinOrderByAggregateInput = {
    id?: SortOrder
    chanInvitationId?: SortOrder
  }

  export type EnumClassicDmEventTypeFilter = {
    equals?: ClassicDmEventType
    in?: Enumerable<ClassicDmEventType>
    notIn?: Enumerable<ClassicDmEventType>
    not?: NestedEnumClassicDmEventTypeFilter | ClassicDmEventType
  }

  export type ClassicDmDiscussionEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
  }

  export type ClassicDmDiscussionEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
  }

  export type ClassicDmDiscussionEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
  }

  export type EnumClassicDmEventTypeWithAggregatesFilter = {
    equals?: ClassicDmEventType
    in?: Enumerable<ClassicDmEventType>
    notIn?: Enumerable<ClassicDmEventType>
    not?: NestedEnumClassicDmEventTypeWithAggregatesFilter | ClassicDmEventType
    _count?: NestedIntFilter
    _min?: NestedEnumClassicDmEventTypeFilter
    _max?: NestedEnumClassicDmEventTypeFilter
  }

  export type EnumChanTypeFilter = {
    equals?: ChanType
    in?: Enumerable<ChanType>
    notIn?: Enumerable<ChanType>
    not?: NestedEnumChanTypeFilter | ChanType
  }

  export type ChanIdTitleCompoundUniqueInput = {
    id: string
    title: string
  }

  export type ChanCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    password?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    ownerName?: SortOrder
  }

  export type ChanMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    password?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    ownerName?: SortOrder
  }

  export type ChanMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    password?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    ownerName?: SortOrder
  }

  export type EnumChanTypeWithAggregatesFilter = {
    equals?: ChanType
    in?: Enumerable<ChanType>
    notIn?: Enumerable<ChanType>
    not?: NestedEnumChanTypeWithAggregatesFilter | ChanType
    _count?: NestedIntFilter
    _min?: NestedEnumChanTypeFilter
    _max?: NestedEnumChanTypeFilter
  }

  export type MutedUserChanChanIdMutedUserNameCompoundUniqueInput = {
    chanId: string
    mutedUserName: string
  }

  export type MutedUserChanCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    untilDate?: SortOrder
    mutedUserName?: SortOrder
    chanId?: SortOrder
  }

  export type MutedUserChanMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    untilDate?: SortOrder
    mutedUserName?: SortOrder
    chanId?: SortOrder
  }

  export type MutedUserChanMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    untilDate?: SortOrder
    mutedUserName?: SortOrder
    chanId?: SortOrder
  }

  export type ChanDiscussionMessageRelationFilter = {
    is?: ChanDiscussionMessageWhereInput | null
    isNot?: ChanDiscussionMessageWhereInput | null
  }

  export type ChanDiscussionEventRelationFilter = {
    is?: ChanDiscussionEventWhereInput | null
    isNot?: ChanDiscussionEventWhereInput | null
  }

  export type ChanDiscussionElementCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    authorName?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
  }

  export type ChanDiscussionElementMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    authorName?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
  }

  export type ChanDiscussionElementMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    eventId?: SortOrder
    authorName?: SortOrder
    creationDate?: SortOrder
    modificationDate?: SortOrder
    chanId?: SortOrder
  }

  export type ChanDiscussionElementRelationFilter = {
    is?: ChanDiscussionElementWhereInput | null
    isNot?: ChanDiscussionElementWhereInput | null
  }

  export type ChanDiscussionMessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
  }

  export type ChanDiscussionMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
  }

  export type ChanDiscussionMessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    relatedTo?: SortOrder
  }

  export type ClassicChanDiscussionEventRelationFilter = {
    is?: ClassicChanDiscussionEventWhereInput | null
    isNot?: ClassicChanDiscussionEventWhereInput | null
  }

  export type ChangedTitleChanDiscussionEventRelationFilter = {
    is?: ChangedTitleChanDiscussionEventWhereInput | null
    isNot?: ChangedTitleChanDiscussionEventWhereInput | null
  }

  export type DeletedMessageChanDiscussionEventRelationFilter = {
    is?: DeletedMessageChanDiscussionEventWhereInput | null
    isNot?: DeletedMessageChanDiscussionEventWhereInput | null
  }

  export type ChanDiscussionEventCountOrderByAggregateInput = {
    id?: SortOrder
    concernedUserName?: SortOrder
    classicChanDiscussionEventId?: SortOrder
    changedTitleChanDiscussionEventId?: SortOrder
    deletedMessageChanDiscussionEventId?: SortOrder
  }

  export type ChanDiscussionEventMaxOrderByAggregateInput = {
    id?: SortOrder
    concernedUserName?: SortOrder
    classicChanDiscussionEventId?: SortOrder
    changedTitleChanDiscussionEventId?: SortOrder
    deletedMessageChanDiscussionEventId?: SortOrder
  }

  export type ChanDiscussionEventMinOrderByAggregateInput = {
    id?: SortOrder
    concernedUserName?: SortOrder
    classicChanDiscussionEventId?: SortOrder
    changedTitleChanDiscussionEventId?: SortOrder
    deletedMessageChanDiscussionEventId?: SortOrder
  }

  export type ChangedTitleChanDiscussionEventCountOrderByAggregateInput = {
    id?: SortOrder
    oldTitle?: SortOrder
    newTitle?: SortOrder
  }

  export type ChangedTitleChanDiscussionEventMaxOrderByAggregateInput = {
    id?: SortOrder
    oldTitle?: SortOrder
    newTitle?: SortOrder
  }

  export type ChangedTitleChanDiscussionEventMinOrderByAggregateInput = {
    id?: SortOrder
    oldTitle?: SortOrder
    newTitle?: SortOrder
  }

  export type DeletedMessageChanDiscussionEventCountOrderByAggregateInput = {
    id?: SortOrder
    deletingUserName?: SortOrder
  }

  export type DeletedMessageChanDiscussionEventMaxOrderByAggregateInput = {
    id?: SortOrder
    deletingUserName?: SortOrder
  }

  export type DeletedMessageChanDiscussionEventMinOrderByAggregateInput = {
    id?: SortOrder
    deletingUserName?: SortOrder
  }

  export type EnumClassicChanEventTypeFilter = {
    equals?: ClassicChanEventType
    in?: Enumerable<ClassicChanEventType>
    notIn?: Enumerable<ClassicChanEventType>
    not?: NestedEnumClassicChanEventTypeFilter | ClassicChanEventType
  }

  export type ClassicChanDiscussionEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
  }

  export type ClassicChanDiscussionEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
  }

  export type ClassicChanDiscussionEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
  }

  export type EnumClassicChanEventTypeWithAggregatesFilter = {
    equals?: ClassicChanEventType
    in?: Enumerable<ClassicChanEventType>
    notIn?: Enumerable<ClassicChanEventType>
    not?: NestedEnumClassicChanEventTypeWithAggregatesFilter | ClassicChanEventType
    _count?: NestedIntFilter
    _min?: NestedEnumClassicChanEventTypeFilter
    _max?: NestedEnumClassicChanEventTypeFilter
  }

  export type RoleCreatepermissionsInput = {
    set: Enumerable<PermissionList>
  }

  export type RoleCreateNestedManyWithoutRolesSymInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRolesSymInput>, Enumerable<RoleUncheckedCreateWithoutRolesSymInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRolesSymInput>
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type RoleCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRolesInput>, Enumerable<RoleUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRolesInput>
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type ChanCreateNestedOneWithoutRolesInput = {
    create?: XOR<ChanCreateWithoutRolesInput, ChanUncheckedCreateWithoutRolesInput>
    connectOrCreate?: ChanCreateOrConnectWithoutRolesInput
    connect?: ChanWhereUniqueInput
  }

  export type ChanDiscussionMessageCreateNestedManyWithoutRelatedRolesInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedRolesInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedRolesInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedRolesInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedManyWithoutRolesSymInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRolesSymInput>, Enumerable<RoleUncheckedCreateWithoutRolesSymInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRolesSymInput>
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRolesInput>, Enumerable<RoleUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRolesInput>
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedRolesInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedRolesInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedRolesInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedRolesInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type RoleUpdatepermissionsInput = {
    set?: Enumerable<PermissionList>
    push?: Enumerable<PermissionList>
  }

  export type EnumRoleApplyingTypeFieldUpdateOperationsInput = {
    set?: RoleApplyingType
  }

  export type RoleUpdateManyWithoutRolesSymNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRolesSymInput>, Enumerable<RoleUncheckedCreateWithoutRolesSymInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRolesSymInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutRolesSymInput>
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutRolesSymInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutRolesSymInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type RoleUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRolesInput>, Enumerable<RoleUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutRolesInput>
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type UserUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRolesInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type ChanUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<ChanCreateWithoutRolesInput, ChanUncheckedCreateWithoutRolesInput>
    connectOrCreate?: ChanCreateOrConnectWithoutRolesInput
    upsert?: ChanUpsertWithoutRolesInput
    connect?: ChanWhereUniqueInput
    update?: XOR<XOR<ChanUpdateToOneWithWhereWithoutRolesInput, ChanUpdateWithoutRolesInput>, ChanUncheckedUpdateWithoutRolesInput>
  }

  export type ChanDiscussionMessageUpdateManyWithoutRelatedRolesNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedRolesInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedRolesInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedRolesInput>
    upsert?: Enumerable<ChanDiscussionMessageUpsertWithWhereUniqueWithoutRelatedRolesInput>
    set?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    update?: Enumerable<ChanDiscussionMessageUpdateWithWhereUniqueWithoutRelatedRolesInput>
    updateMany?: Enumerable<ChanDiscussionMessageUpdateManyWithWhereWithoutRelatedRolesInput>
    deleteMany?: Enumerable<ChanDiscussionMessageScalarWhereInput>
  }

  export type RoleUncheckedUpdateManyWithoutRolesSymNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRolesSymInput>, Enumerable<RoleUncheckedCreateWithoutRolesSymInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRolesSymInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutRolesSymInput>
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutRolesSymInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutRolesSymInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type RoleUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRolesInput>, Enumerable<RoleUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutRolesInput>
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRolesInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedRolesNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedRolesInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedRolesInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedRolesInput>
    upsert?: Enumerable<ChanDiscussionMessageUpsertWithWhereUniqueWithoutRelatedRolesInput>
    set?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    update?: Enumerable<ChanDiscussionMessageUpdateWithWhereUniqueWithoutRelatedRolesInput>
    updateMany?: Enumerable<ChanDiscussionMessageUpdateManyWithWhereWithoutRelatedRolesInput>
    deleteMany?: Enumerable<ChanDiscussionMessageScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutOutcomingFriendInvitationInput = {
    create?: XOR<UserCreateWithoutOutcomingFriendInvitationInput, UserUncheckedCreateWithoutOutcomingFriendInvitationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutcomingFriendInvitationInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIncomingFriendInvitationInput = {
    create?: XOR<UserCreateWithoutIncomingFriendInvitationInput, UserUncheckedCreateWithoutIncomingFriendInvitationInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomingFriendInvitationInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumFriendInvitationStatusFieldUpdateOperationsInput = {
    set?: FriendInvitationStatus
  }

  export type UserUpdateOneRequiredWithoutOutcomingFriendInvitationNestedInput = {
    create?: XOR<UserCreateWithoutOutcomingFriendInvitationInput, UserUncheckedCreateWithoutOutcomingFriendInvitationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutcomingFriendInvitationInput
    upsert?: UserUpsertWithoutOutcomingFriendInvitationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOutcomingFriendInvitationInput, UserUpdateWithoutOutcomingFriendInvitationInput>, UserUncheckedUpdateWithoutOutcomingFriendInvitationInput>
  }

  export type UserUpdateOneRequiredWithoutIncomingFriendInvitationNestedInput = {
    create?: XOR<UserCreateWithoutIncomingFriendInvitationInput, UserUncheckedCreateWithoutIncomingFriendInvitationInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomingFriendInvitationInput
    upsert?: UserUpsertWithoutIncomingFriendInvitationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIncomingFriendInvitationInput, UserUpdateWithoutIncomingFriendInvitationInput>, UserUncheckedUpdateWithoutIncomingFriendInvitationInput>
  }

  export type ChanCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<ChanCreateWithoutInvitationsInput, ChanUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: ChanCreateOrConnectWithoutInvitationsInput
    connect?: ChanWhereUniqueInput
  }

  export type ChanInvitationDmDiscussionEventCreateNestedOneWithoutChanInvitationInput = {
    create?: XOR<ChanInvitationDmDiscussionEventCreateWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutChanInvitationInput>
    connectOrCreate?: ChanInvitationDmDiscussionEventCreateOrConnectWithoutChanInvitationInput
    connect?: ChanInvitationDmDiscussionEventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOutcomingChanInvitationInput = {
    create?: XOR<UserCreateWithoutOutcomingChanInvitationInput, UserUncheckedCreateWithoutOutcomingChanInvitationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutcomingChanInvitationInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIncomingChanInvitationInput = {
    create?: XOR<UserCreateWithoutIncomingChanInvitationInput, UserUncheckedCreateWithoutIncomingChanInvitationInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomingChanInvitationInput
    connect?: UserWhereUniqueInput
  }

  export type ChanInvitationDmDiscussionEventUncheckedCreateNestedOneWithoutChanInvitationInput = {
    create?: XOR<ChanInvitationDmDiscussionEventCreateWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutChanInvitationInput>
    connectOrCreate?: ChanInvitationDmDiscussionEventCreateOrConnectWithoutChanInvitationInput
    connect?: ChanInvitationDmDiscussionEventWhereUniqueInput
  }

  export type EnumChanInvitationStatusFieldUpdateOperationsInput = {
    set?: ChanInvitationStatus
  }

  export type ChanUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<ChanCreateWithoutInvitationsInput, ChanUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: ChanCreateOrConnectWithoutInvitationsInput
    upsert?: ChanUpsertWithoutInvitationsInput
    connect?: ChanWhereUniqueInput
    update?: XOR<XOR<ChanUpdateToOneWithWhereWithoutInvitationsInput, ChanUpdateWithoutInvitationsInput>, ChanUncheckedUpdateWithoutInvitationsInput>
  }

  export type ChanInvitationDmDiscussionEventUpdateOneWithoutChanInvitationNestedInput = {
    create?: XOR<ChanInvitationDmDiscussionEventCreateWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutChanInvitationInput>
    connectOrCreate?: ChanInvitationDmDiscussionEventCreateOrConnectWithoutChanInvitationInput
    upsert?: ChanInvitationDmDiscussionEventUpsertWithoutChanInvitationInput
    disconnect?: ChanInvitationDmDiscussionEventWhereInput | boolean
    delete?: ChanInvitationDmDiscussionEventWhereInput | boolean
    connect?: ChanInvitationDmDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanInvitationDmDiscussionEventUpdateToOneWithWhereWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUpdateWithoutChanInvitationInput>, ChanInvitationDmDiscussionEventUncheckedUpdateWithoutChanInvitationInput>
  }

  export type UserUpdateOneRequiredWithoutOutcomingChanInvitationNestedInput = {
    create?: XOR<UserCreateWithoutOutcomingChanInvitationInput, UserUncheckedCreateWithoutOutcomingChanInvitationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutcomingChanInvitationInput
    upsert?: UserUpsertWithoutOutcomingChanInvitationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOutcomingChanInvitationInput, UserUpdateWithoutOutcomingChanInvitationInput>, UserUncheckedUpdateWithoutOutcomingChanInvitationInput>
  }

  export type UserUpdateOneRequiredWithoutIncomingChanInvitationNestedInput = {
    create?: XOR<UserCreateWithoutIncomingChanInvitationInput, UserUncheckedCreateWithoutIncomingChanInvitationInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomingChanInvitationInput
    upsert?: UserUpsertWithoutIncomingChanInvitationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIncomingChanInvitationInput, UserUpdateWithoutIncomingChanInvitationInput>, UserUncheckedUpdateWithoutIncomingChanInvitationInput>
  }

  export type ChanInvitationDmDiscussionEventUncheckedUpdateOneWithoutChanInvitationNestedInput = {
    create?: XOR<ChanInvitationDmDiscussionEventCreateWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutChanInvitationInput>
    connectOrCreate?: ChanInvitationDmDiscussionEventCreateOrConnectWithoutChanInvitationInput
    upsert?: ChanInvitationDmDiscussionEventUpsertWithoutChanInvitationInput
    disconnect?: ChanInvitationDmDiscussionEventWhereInput | boolean
    delete?: ChanInvitationDmDiscussionEventWhereInput | boolean
    connect?: ChanInvitationDmDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanInvitationDmDiscussionEventUpdateToOneWithWhereWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUpdateWithoutChanInvitationInput>, ChanInvitationDmDiscussionEventUncheckedUpdateWithoutChanInvitationInput>
  }

  export type UserCreateNestedOneWithoutFriendInput = {
    create?: XOR<UserCreateWithoutFriendInput, UserUncheckedCreateWithoutFriendInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFriendOfInput = {
    create?: XOR<UserCreateWithoutFriendOfInput, UserUncheckedCreateWithoutFriendOfInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendOfInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFriendNestedInput = {
    create?: XOR<UserCreateWithoutFriendInput, UserUncheckedCreateWithoutFriendInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendInput
    upsert?: UserUpsertWithoutFriendInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendInput, UserUpdateWithoutFriendInput>, UserUncheckedUpdateWithoutFriendInput>
  }

  export type UserUpdateOneRequiredWithoutFriendOfNestedInput = {
    create?: XOR<UserCreateWithoutFriendOfInput, UserUncheckedCreateWithoutFriendOfInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendOfInput
    upsert?: UserUpsertWithoutFriendOfInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendOfInput, UserUpdateWithoutFriendOfInput>, UserUncheckedUpdateWithoutFriendOfInput>
  }

  export type UserCreateNestedOneWithoutBlockedUserInput = {
    create?: XOR<UserCreateWithoutBlockedUserInput, UserUncheckedCreateWithoutBlockedUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlockedByUserInput = {
    create?: XOR<UserCreateWithoutBlockedByUserInput, UserUncheckedCreateWithoutBlockedByUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlockedUserNestedInput = {
    create?: XOR<UserCreateWithoutBlockedUserInput, UserUncheckedCreateWithoutBlockedUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedUserInput
    upsert?: UserUpsertWithoutBlockedUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedUserInput, UserUpdateWithoutBlockedUserInput>, UserUncheckedUpdateWithoutBlockedUserInput>
  }

  export type UserUpdateOneRequiredWithoutBlockedByUserNestedInput = {
    create?: XOR<UserCreateWithoutBlockedByUserInput, UserUncheckedCreateWithoutBlockedByUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByUserInput
    upsert?: UserUpsertWithoutBlockedByUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedByUserInput, UserUpdateWithoutBlockedByUserInput>, UserUncheckedUpdateWithoutBlockedByUserInput>
  }

  export type RoleCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<RoleCreateWithoutUsersInput>, Enumerable<RoleUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type DirectMessageCreateNestedManyWithoutRequestingUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutRequestingUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutRequestingUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutRequestingUserInput>
    createMany?: DirectMessageCreateManyRequestingUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type DirectMessageCreateNestedManyWithoutRequestedUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutRequestedUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutRequestedUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutRequestedUserInput>
    createMany?: DirectMessageCreateManyRequestedUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type ChanCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<ChanCreateWithoutUsersInput>, Enumerable<ChanUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ChanCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<ChanWhereUniqueInput>
  }

  export type ChanCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ChanCreateWithoutOwnerInput>, Enumerable<ChanUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ChanCreateOrConnectWithoutOwnerInput>
    createMany?: ChanCreateManyOwnerInputEnvelope
    connect?: Enumerable<ChanWhereUniqueInput>
  }

  export type FriendShipCreateNestedManyWithoutRequestingUserInput = {
    create?: XOR<Enumerable<FriendShipCreateWithoutRequestingUserInput>, Enumerable<FriendShipUncheckedCreateWithoutRequestingUserInput>>
    connectOrCreate?: Enumerable<FriendShipCreateOrConnectWithoutRequestingUserInput>
    createMany?: FriendShipCreateManyRequestingUserInputEnvelope
    connect?: Enumerable<FriendShipWhereUniqueInput>
  }

  export type FriendShipCreateNestedManyWithoutRequestedUserInput = {
    create?: XOR<Enumerable<FriendShipCreateWithoutRequestedUserInput>, Enumerable<FriendShipUncheckedCreateWithoutRequestedUserInput>>
    connectOrCreate?: Enumerable<FriendShipCreateOrConnectWithoutRequestedUserInput>
    createMany?: FriendShipCreateManyRequestedUserInputEnvelope
    connect?: Enumerable<FriendShipWhereUniqueInput>
  }

  export type FriendInvitationCreateNestedManyWithoutInvitingUserInput = {
    create?: XOR<Enumerable<FriendInvitationCreateWithoutInvitingUserInput>, Enumerable<FriendInvitationUncheckedCreateWithoutInvitingUserInput>>
    connectOrCreate?: Enumerable<FriendInvitationCreateOrConnectWithoutInvitingUserInput>
    createMany?: FriendInvitationCreateManyInvitingUserInputEnvelope
    connect?: Enumerable<FriendInvitationWhereUniqueInput>
  }

  export type FriendInvitationCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<Enumerable<FriendInvitationCreateWithoutInvitedUserInput>, Enumerable<FriendInvitationUncheckedCreateWithoutInvitedUserInput>>
    connectOrCreate?: Enumerable<FriendInvitationCreateOrConnectWithoutInvitedUserInput>
    createMany?: FriendInvitationCreateManyInvitedUserInputEnvelope
    connect?: Enumerable<FriendInvitationWhereUniqueInput>
  }

  export type ChanInvitationCreateNestedManyWithoutInvitingUserInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutInvitingUserInput>, Enumerable<ChanInvitationUncheckedCreateWithoutInvitingUserInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutInvitingUserInput>
    createMany?: ChanInvitationCreateManyInvitingUserInputEnvelope
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
  }

  export type ChanInvitationCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutInvitedUserInput>, Enumerable<ChanInvitationUncheckedCreateWithoutInvitedUserInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutInvitedUserInput>
    createMany?: ChanInvitationCreateManyInvitedUserInputEnvelope
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
  }

  export type BlockedShipCreateNestedManyWithoutBlockingUserInput = {
    create?: XOR<Enumerable<BlockedShipCreateWithoutBlockingUserInput>, Enumerable<BlockedShipUncheckedCreateWithoutBlockingUserInput>>
    connectOrCreate?: Enumerable<BlockedShipCreateOrConnectWithoutBlockingUserInput>
    createMany?: BlockedShipCreateManyBlockingUserInputEnvelope
    connect?: Enumerable<BlockedShipWhereUniqueInput>
  }

  export type BlockedShipCreateNestedManyWithoutBlockedUserInput = {
    create?: XOR<Enumerable<BlockedShipCreateWithoutBlockedUserInput>, Enumerable<BlockedShipUncheckedCreateWithoutBlockedUserInput>>
    connectOrCreate?: Enumerable<BlockedShipCreateOrConnectWithoutBlockedUserInput>
    createMany?: BlockedShipCreateManyBlockedUserInputEnvelope
    connect?: Enumerable<BlockedShipWhereUniqueInput>
  }

  export type ChanDiscussionElementCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ChanDiscussionElementCreateWithoutAuthorInput>, Enumerable<ChanDiscussionElementUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ChanDiscussionElementCreateOrConnectWithoutAuthorInput>
    createMany?: ChanDiscussionElementCreateManyAuthorInputEnvelope
    connect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
  }

  export type ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput = {
    create?: XOR<Enumerable<ChanDiscussionEventCreateWithoutConcernedUserInput>, Enumerable<ChanDiscussionEventUncheckedCreateWithoutConcernedUserInput>>
    connectOrCreate?: Enumerable<ChanDiscussionEventCreateOrConnectWithoutConcernedUserInput>
    createMany?: ChanDiscussionEventCreateManyConcernedUserInputEnvelope
    connect?: Enumerable<ChanDiscussionEventWhereUniqueInput>
  }

  export type DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput = {
    create?: XOR<Enumerable<DeletedMessageChanDiscussionEventCreateWithoutDeletingUsersInput>, Enumerable<DeletedMessageChanDiscussionEventUncheckedCreateWithoutDeletingUsersInput>>
    connectOrCreate?: Enumerable<DeletedMessageChanDiscussionEventCreateOrConnectWithoutDeletingUsersInput>
    createMany?: DeletedMessageChanDiscussionEventCreateManyDeletingUsersInputEnvelope
    connect?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
  }

  export type ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedUsersInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedUsersInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
  }

  export type DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput = {
    create?: XOR<Enumerable<DmDiscussionElementCreateWithoutAuthorRelationInput>, Enumerable<DmDiscussionElementUncheckedCreateWithoutAuthorRelationInput>>
    connectOrCreate?: Enumerable<DmDiscussionElementCreateOrConnectWithoutAuthorRelationInput>
    createMany?: DmDiscussionElementCreateManyAuthorRelationInputEnvelope
    connect?: Enumerable<DmDiscussionElementWhereUniqueInput>
  }

  export type DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput = {
    create?: XOR<Enumerable<DmDiscussionMessageCreateWithoutRelatedUsersInput>, Enumerable<DmDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>>
    connectOrCreate?: Enumerable<DmDiscussionMessageCreateOrConnectWithoutRelatedUsersInput>
    connect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
  }

  export type MutedUserChanCreateNestedManyWithoutMutedUserInput = {
    create?: XOR<Enumerable<MutedUserChanCreateWithoutMutedUserInput>, Enumerable<MutedUserChanUncheckedCreateWithoutMutedUserInput>>
    connectOrCreate?: Enumerable<MutedUserChanCreateOrConnectWithoutMutedUserInput>
    createMany?: MutedUserChanCreateManyMutedUserInputEnvelope
    connect?: Enumerable<MutedUserChanWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<RoleCreateWithoutUsersInput>, Enumerable<RoleUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutRequestingUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutRequestingUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutRequestingUserInput>
    createMany?: DirectMessageCreateManyRequestingUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutRequestedUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutRequestedUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutRequestedUserInput>
    createMany?: DirectMessageCreateManyRequestedUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type ChanUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<ChanCreateWithoutUsersInput>, Enumerable<ChanUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ChanCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<ChanWhereUniqueInput>
  }

  export type ChanUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ChanCreateWithoutOwnerInput>, Enumerable<ChanUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ChanCreateOrConnectWithoutOwnerInput>
    createMany?: ChanCreateManyOwnerInputEnvelope
    connect?: Enumerable<ChanWhereUniqueInput>
  }

  export type FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput = {
    create?: XOR<Enumerable<FriendShipCreateWithoutRequestingUserInput>, Enumerable<FriendShipUncheckedCreateWithoutRequestingUserInput>>
    connectOrCreate?: Enumerable<FriendShipCreateOrConnectWithoutRequestingUserInput>
    createMany?: FriendShipCreateManyRequestingUserInputEnvelope
    connect?: Enumerable<FriendShipWhereUniqueInput>
  }

  export type FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput = {
    create?: XOR<Enumerable<FriendShipCreateWithoutRequestedUserInput>, Enumerable<FriendShipUncheckedCreateWithoutRequestedUserInput>>
    connectOrCreate?: Enumerable<FriendShipCreateOrConnectWithoutRequestedUserInput>
    createMany?: FriendShipCreateManyRequestedUserInputEnvelope
    connect?: Enumerable<FriendShipWhereUniqueInput>
  }

  export type FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput = {
    create?: XOR<Enumerable<FriendInvitationCreateWithoutInvitingUserInput>, Enumerable<FriendInvitationUncheckedCreateWithoutInvitingUserInput>>
    connectOrCreate?: Enumerable<FriendInvitationCreateOrConnectWithoutInvitingUserInput>
    createMany?: FriendInvitationCreateManyInvitingUserInputEnvelope
    connect?: Enumerable<FriendInvitationWhereUniqueInput>
  }

  export type FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<Enumerable<FriendInvitationCreateWithoutInvitedUserInput>, Enumerable<FriendInvitationUncheckedCreateWithoutInvitedUserInput>>
    connectOrCreate?: Enumerable<FriendInvitationCreateOrConnectWithoutInvitedUserInput>
    createMany?: FriendInvitationCreateManyInvitedUserInputEnvelope
    connect?: Enumerable<FriendInvitationWhereUniqueInput>
  }

  export type ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutInvitingUserInput>, Enumerable<ChanInvitationUncheckedCreateWithoutInvitingUserInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutInvitingUserInput>
    createMany?: ChanInvitationCreateManyInvitingUserInputEnvelope
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
  }

  export type ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutInvitedUserInput>, Enumerable<ChanInvitationUncheckedCreateWithoutInvitedUserInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutInvitedUserInput>
    createMany?: ChanInvitationCreateManyInvitedUserInputEnvelope
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
  }

  export type BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput = {
    create?: XOR<Enumerable<BlockedShipCreateWithoutBlockingUserInput>, Enumerable<BlockedShipUncheckedCreateWithoutBlockingUserInput>>
    connectOrCreate?: Enumerable<BlockedShipCreateOrConnectWithoutBlockingUserInput>
    createMany?: BlockedShipCreateManyBlockingUserInputEnvelope
    connect?: Enumerable<BlockedShipWhereUniqueInput>
  }

  export type BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput = {
    create?: XOR<Enumerable<BlockedShipCreateWithoutBlockedUserInput>, Enumerable<BlockedShipUncheckedCreateWithoutBlockedUserInput>>
    connectOrCreate?: Enumerable<BlockedShipCreateOrConnectWithoutBlockedUserInput>
    createMany?: BlockedShipCreateManyBlockedUserInputEnvelope
    connect?: Enumerable<BlockedShipWhereUniqueInput>
  }

  export type ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ChanDiscussionElementCreateWithoutAuthorInput>, Enumerable<ChanDiscussionElementUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ChanDiscussionElementCreateOrConnectWithoutAuthorInput>
    createMany?: ChanDiscussionElementCreateManyAuthorInputEnvelope
    connect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
  }

  export type ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput = {
    create?: XOR<Enumerable<ChanDiscussionEventCreateWithoutConcernedUserInput>, Enumerable<ChanDiscussionEventUncheckedCreateWithoutConcernedUserInput>>
    connectOrCreate?: Enumerable<ChanDiscussionEventCreateOrConnectWithoutConcernedUserInput>
    createMany?: ChanDiscussionEventCreateManyConcernedUserInputEnvelope
    connect?: Enumerable<ChanDiscussionEventWhereUniqueInput>
  }

  export type DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput = {
    create?: XOR<Enumerable<DeletedMessageChanDiscussionEventCreateWithoutDeletingUsersInput>, Enumerable<DeletedMessageChanDiscussionEventUncheckedCreateWithoutDeletingUsersInput>>
    connectOrCreate?: Enumerable<DeletedMessageChanDiscussionEventCreateOrConnectWithoutDeletingUsersInput>
    createMany?: DeletedMessageChanDiscussionEventCreateManyDeletingUsersInputEnvelope
    connect?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
  }

  export type ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedUsersInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedUsersInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
  }

  export type DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput = {
    create?: XOR<Enumerable<DmDiscussionElementCreateWithoutAuthorRelationInput>, Enumerable<DmDiscussionElementUncheckedCreateWithoutAuthorRelationInput>>
    connectOrCreate?: Enumerable<DmDiscussionElementCreateOrConnectWithoutAuthorRelationInput>
    createMany?: DmDiscussionElementCreateManyAuthorRelationInputEnvelope
    connect?: Enumerable<DmDiscussionElementWhereUniqueInput>
  }

  export type DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput = {
    create?: XOR<Enumerable<DmDiscussionMessageCreateWithoutRelatedUsersInput>, Enumerable<DmDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>>
    connectOrCreate?: Enumerable<DmDiscussionMessageCreateOrConnectWithoutRelatedUsersInput>
    connect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
  }

  export type MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput = {
    create?: XOR<Enumerable<MutedUserChanCreateWithoutMutedUserInput>, Enumerable<MutedUserChanUncheckedCreateWithoutMutedUserInput>>
    connectOrCreate?: Enumerable<MutedUserChanCreateOrConnectWithoutMutedUserInput>
    createMany?: MutedUserChanCreateManyMutedUserInputEnvelope
    connect?: Enumerable<MutedUserChanWhereUniqueInput>
  }

  export type EnumdmPolicyLevelTypeFieldUpdateOperationsInput = {
    set?: dmPolicyLevelType
  }

  export type RoleUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutUsersInput>, Enumerable<RoleUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type DirectMessageUpdateManyWithoutRequestingUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutRequestingUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutRequestingUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutRequestingUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutRequestingUserInput>
    createMany?: DirectMessageCreateManyRequestingUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutRequestingUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutRequestingUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type DirectMessageUpdateManyWithoutRequestedUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutRequestedUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutRequestedUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutRequestedUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutRequestedUserInput>
    createMany?: DirectMessageCreateManyRequestedUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutRequestedUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutRequestedUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type ChanUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<ChanCreateWithoutUsersInput>, Enumerable<ChanUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ChanCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<ChanUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<ChanWhereUniqueInput>
    disconnect?: Enumerable<ChanWhereUniqueInput>
    delete?: Enumerable<ChanWhereUniqueInput>
    connect?: Enumerable<ChanWhereUniqueInput>
    update?: Enumerable<ChanUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<ChanUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<ChanScalarWhereInput>
  }

  export type ChanUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<ChanCreateWithoutOwnerInput>, Enumerable<ChanUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ChanCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<ChanUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: ChanCreateManyOwnerInputEnvelope
    set?: Enumerable<ChanWhereUniqueInput>
    disconnect?: Enumerable<ChanWhereUniqueInput>
    delete?: Enumerable<ChanWhereUniqueInput>
    connect?: Enumerable<ChanWhereUniqueInput>
    update?: Enumerable<ChanUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<ChanUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<ChanScalarWhereInput>
  }

  export type FriendShipUpdateManyWithoutRequestingUserNestedInput = {
    create?: XOR<Enumerable<FriendShipCreateWithoutRequestingUserInput>, Enumerable<FriendShipUncheckedCreateWithoutRequestingUserInput>>
    connectOrCreate?: Enumerable<FriendShipCreateOrConnectWithoutRequestingUserInput>
    upsert?: Enumerable<FriendShipUpsertWithWhereUniqueWithoutRequestingUserInput>
    createMany?: FriendShipCreateManyRequestingUserInputEnvelope
    set?: Enumerable<FriendShipWhereUniqueInput>
    disconnect?: Enumerable<FriendShipWhereUniqueInput>
    delete?: Enumerable<FriendShipWhereUniqueInput>
    connect?: Enumerable<FriendShipWhereUniqueInput>
    update?: Enumerable<FriendShipUpdateWithWhereUniqueWithoutRequestingUserInput>
    updateMany?: Enumerable<FriendShipUpdateManyWithWhereWithoutRequestingUserInput>
    deleteMany?: Enumerable<FriendShipScalarWhereInput>
  }

  export type FriendShipUpdateManyWithoutRequestedUserNestedInput = {
    create?: XOR<Enumerable<FriendShipCreateWithoutRequestedUserInput>, Enumerable<FriendShipUncheckedCreateWithoutRequestedUserInput>>
    connectOrCreate?: Enumerable<FriendShipCreateOrConnectWithoutRequestedUserInput>
    upsert?: Enumerable<FriendShipUpsertWithWhereUniqueWithoutRequestedUserInput>
    createMany?: FriendShipCreateManyRequestedUserInputEnvelope
    set?: Enumerable<FriendShipWhereUniqueInput>
    disconnect?: Enumerable<FriendShipWhereUniqueInput>
    delete?: Enumerable<FriendShipWhereUniqueInput>
    connect?: Enumerable<FriendShipWhereUniqueInput>
    update?: Enumerable<FriendShipUpdateWithWhereUniqueWithoutRequestedUserInput>
    updateMany?: Enumerable<FriendShipUpdateManyWithWhereWithoutRequestedUserInput>
    deleteMany?: Enumerable<FriendShipScalarWhereInput>
  }

  export type FriendInvitationUpdateManyWithoutInvitingUserNestedInput = {
    create?: XOR<Enumerable<FriendInvitationCreateWithoutInvitingUserInput>, Enumerable<FriendInvitationUncheckedCreateWithoutInvitingUserInput>>
    connectOrCreate?: Enumerable<FriendInvitationCreateOrConnectWithoutInvitingUserInput>
    upsert?: Enumerable<FriendInvitationUpsertWithWhereUniqueWithoutInvitingUserInput>
    createMany?: FriendInvitationCreateManyInvitingUserInputEnvelope
    set?: Enumerable<FriendInvitationWhereUniqueInput>
    disconnect?: Enumerable<FriendInvitationWhereUniqueInput>
    delete?: Enumerable<FriendInvitationWhereUniqueInput>
    connect?: Enumerable<FriendInvitationWhereUniqueInput>
    update?: Enumerable<FriendInvitationUpdateWithWhereUniqueWithoutInvitingUserInput>
    updateMany?: Enumerable<FriendInvitationUpdateManyWithWhereWithoutInvitingUserInput>
    deleteMany?: Enumerable<FriendInvitationScalarWhereInput>
  }

  export type FriendInvitationUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<Enumerable<FriendInvitationCreateWithoutInvitedUserInput>, Enumerable<FriendInvitationUncheckedCreateWithoutInvitedUserInput>>
    connectOrCreate?: Enumerable<FriendInvitationCreateOrConnectWithoutInvitedUserInput>
    upsert?: Enumerable<FriendInvitationUpsertWithWhereUniqueWithoutInvitedUserInput>
    createMany?: FriendInvitationCreateManyInvitedUserInputEnvelope
    set?: Enumerable<FriendInvitationWhereUniqueInput>
    disconnect?: Enumerable<FriendInvitationWhereUniqueInput>
    delete?: Enumerable<FriendInvitationWhereUniqueInput>
    connect?: Enumerable<FriendInvitationWhereUniqueInput>
    update?: Enumerable<FriendInvitationUpdateWithWhereUniqueWithoutInvitedUserInput>
    updateMany?: Enumerable<FriendInvitationUpdateManyWithWhereWithoutInvitedUserInput>
    deleteMany?: Enumerable<FriendInvitationScalarWhereInput>
  }

  export type ChanInvitationUpdateManyWithoutInvitingUserNestedInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutInvitingUserInput>, Enumerable<ChanInvitationUncheckedCreateWithoutInvitingUserInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutInvitingUserInput>
    upsert?: Enumerable<ChanInvitationUpsertWithWhereUniqueWithoutInvitingUserInput>
    createMany?: ChanInvitationCreateManyInvitingUserInputEnvelope
    set?: Enumerable<ChanInvitationWhereUniqueInput>
    disconnect?: Enumerable<ChanInvitationWhereUniqueInput>
    delete?: Enumerable<ChanInvitationWhereUniqueInput>
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
    update?: Enumerable<ChanInvitationUpdateWithWhereUniqueWithoutInvitingUserInput>
    updateMany?: Enumerable<ChanInvitationUpdateManyWithWhereWithoutInvitingUserInput>
    deleteMany?: Enumerable<ChanInvitationScalarWhereInput>
  }

  export type ChanInvitationUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutInvitedUserInput>, Enumerable<ChanInvitationUncheckedCreateWithoutInvitedUserInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutInvitedUserInput>
    upsert?: Enumerable<ChanInvitationUpsertWithWhereUniqueWithoutInvitedUserInput>
    createMany?: ChanInvitationCreateManyInvitedUserInputEnvelope
    set?: Enumerable<ChanInvitationWhereUniqueInput>
    disconnect?: Enumerable<ChanInvitationWhereUniqueInput>
    delete?: Enumerable<ChanInvitationWhereUniqueInput>
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
    update?: Enumerable<ChanInvitationUpdateWithWhereUniqueWithoutInvitedUserInput>
    updateMany?: Enumerable<ChanInvitationUpdateManyWithWhereWithoutInvitedUserInput>
    deleteMany?: Enumerable<ChanInvitationScalarWhereInput>
  }

  export type BlockedShipUpdateManyWithoutBlockingUserNestedInput = {
    create?: XOR<Enumerable<BlockedShipCreateWithoutBlockingUserInput>, Enumerable<BlockedShipUncheckedCreateWithoutBlockingUserInput>>
    connectOrCreate?: Enumerable<BlockedShipCreateOrConnectWithoutBlockingUserInput>
    upsert?: Enumerable<BlockedShipUpsertWithWhereUniqueWithoutBlockingUserInput>
    createMany?: BlockedShipCreateManyBlockingUserInputEnvelope
    set?: Enumerable<BlockedShipWhereUniqueInput>
    disconnect?: Enumerable<BlockedShipWhereUniqueInput>
    delete?: Enumerable<BlockedShipWhereUniqueInput>
    connect?: Enumerable<BlockedShipWhereUniqueInput>
    update?: Enumerable<BlockedShipUpdateWithWhereUniqueWithoutBlockingUserInput>
    updateMany?: Enumerable<BlockedShipUpdateManyWithWhereWithoutBlockingUserInput>
    deleteMany?: Enumerable<BlockedShipScalarWhereInput>
  }

  export type BlockedShipUpdateManyWithoutBlockedUserNestedInput = {
    create?: XOR<Enumerable<BlockedShipCreateWithoutBlockedUserInput>, Enumerable<BlockedShipUncheckedCreateWithoutBlockedUserInput>>
    connectOrCreate?: Enumerable<BlockedShipCreateOrConnectWithoutBlockedUserInput>
    upsert?: Enumerable<BlockedShipUpsertWithWhereUniqueWithoutBlockedUserInput>
    createMany?: BlockedShipCreateManyBlockedUserInputEnvelope
    set?: Enumerable<BlockedShipWhereUniqueInput>
    disconnect?: Enumerable<BlockedShipWhereUniqueInput>
    delete?: Enumerable<BlockedShipWhereUniqueInput>
    connect?: Enumerable<BlockedShipWhereUniqueInput>
    update?: Enumerable<BlockedShipUpdateWithWhereUniqueWithoutBlockedUserInput>
    updateMany?: Enumerable<BlockedShipUpdateManyWithWhereWithoutBlockedUserInput>
    deleteMany?: Enumerable<BlockedShipScalarWhereInput>
  }

  export type ChanDiscussionElementUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionElementCreateWithoutAuthorInput>, Enumerable<ChanDiscussionElementUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ChanDiscussionElementCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ChanDiscussionElementUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ChanDiscussionElementCreateManyAuthorInputEnvelope
    set?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    update?: Enumerable<ChanDiscussionElementUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ChanDiscussionElementUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ChanDiscussionElementScalarWhereInput>
  }

  export type ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionEventCreateWithoutConcernedUserInput>, Enumerable<ChanDiscussionEventUncheckedCreateWithoutConcernedUserInput>>
    connectOrCreate?: Enumerable<ChanDiscussionEventCreateOrConnectWithoutConcernedUserInput>
    upsert?: Enumerable<ChanDiscussionEventUpsertWithWhereUniqueWithoutConcernedUserInput>
    createMany?: ChanDiscussionEventCreateManyConcernedUserInputEnvelope
    set?: Enumerable<ChanDiscussionEventWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionEventWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionEventWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionEventWhereUniqueInput>
    update?: Enumerable<ChanDiscussionEventUpdateWithWhereUniqueWithoutConcernedUserInput>
    updateMany?: Enumerable<ChanDiscussionEventUpdateManyWithWhereWithoutConcernedUserInput>
    deleteMany?: Enumerable<ChanDiscussionEventScalarWhereInput>
  }

  export type DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput = {
    create?: XOR<Enumerable<DeletedMessageChanDiscussionEventCreateWithoutDeletingUsersInput>, Enumerable<DeletedMessageChanDiscussionEventUncheckedCreateWithoutDeletingUsersInput>>
    connectOrCreate?: Enumerable<DeletedMessageChanDiscussionEventCreateOrConnectWithoutDeletingUsersInput>
    upsert?: Enumerable<DeletedMessageChanDiscussionEventUpsertWithWhereUniqueWithoutDeletingUsersInput>
    createMany?: DeletedMessageChanDiscussionEventCreateManyDeletingUsersInputEnvelope
    set?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
    disconnect?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
    delete?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
    connect?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
    update?: Enumerable<DeletedMessageChanDiscussionEventUpdateWithWhereUniqueWithoutDeletingUsersInput>
    updateMany?: Enumerable<DeletedMessageChanDiscussionEventUpdateManyWithWhereWithoutDeletingUsersInput>
    deleteMany?: Enumerable<DeletedMessageChanDiscussionEventScalarWhereInput>
  }

  export type ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedUsersInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedUsersInput>
    upsert?: Enumerable<ChanDiscussionMessageUpsertWithWhereUniqueWithoutRelatedUsersInput>
    set?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    update?: Enumerable<ChanDiscussionMessageUpdateWithWhereUniqueWithoutRelatedUsersInput>
    updateMany?: Enumerable<ChanDiscussionMessageUpdateManyWithWhereWithoutRelatedUsersInput>
    deleteMany?: Enumerable<ChanDiscussionMessageScalarWhereInput>
  }

  export type DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput = {
    create?: XOR<Enumerable<DmDiscussionElementCreateWithoutAuthorRelationInput>, Enumerable<DmDiscussionElementUncheckedCreateWithoutAuthorRelationInput>>
    connectOrCreate?: Enumerable<DmDiscussionElementCreateOrConnectWithoutAuthorRelationInput>
    upsert?: Enumerable<DmDiscussionElementUpsertWithWhereUniqueWithoutAuthorRelationInput>
    createMany?: DmDiscussionElementCreateManyAuthorRelationInputEnvelope
    set?: Enumerable<DmDiscussionElementWhereUniqueInput>
    disconnect?: Enumerable<DmDiscussionElementWhereUniqueInput>
    delete?: Enumerable<DmDiscussionElementWhereUniqueInput>
    connect?: Enumerable<DmDiscussionElementWhereUniqueInput>
    update?: Enumerable<DmDiscussionElementUpdateWithWhereUniqueWithoutAuthorRelationInput>
    updateMany?: Enumerable<DmDiscussionElementUpdateManyWithWhereWithoutAuthorRelationInput>
    deleteMany?: Enumerable<DmDiscussionElementScalarWhereInput>
  }

  export type DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput = {
    create?: XOR<Enumerable<DmDiscussionMessageCreateWithoutRelatedUsersInput>, Enumerable<DmDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>>
    connectOrCreate?: Enumerable<DmDiscussionMessageCreateOrConnectWithoutRelatedUsersInput>
    upsert?: Enumerable<DmDiscussionMessageUpsertWithWhereUniqueWithoutRelatedUsersInput>
    set?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    update?: Enumerable<DmDiscussionMessageUpdateWithWhereUniqueWithoutRelatedUsersInput>
    updateMany?: Enumerable<DmDiscussionMessageUpdateManyWithWhereWithoutRelatedUsersInput>
    deleteMany?: Enumerable<DmDiscussionMessageScalarWhereInput>
  }

  export type MutedUserChanUpdateManyWithoutMutedUserNestedInput = {
    create?: XOR<Enumerable<MutedUserChanCreateWithoutMutedUserInput>, Enumerable<MutedUserChanUncheckedCreateWithoutMutedUserInput>>
    connectOrCreate?: Enumerable<MutedUserChanCreateOrConnectWithoutMutedUserInput>
    upsert?: Enumerable<MutedUserChanUpsertWithWhereUniqueWithoutMutedUserInput>
    createMany?: MutedUserChanCreateManyMutedUserInputEnvelope
    set?: Enumerable<MutedUserChanWhereUniqueInput>
    disconnect?: Enumerable<MutedUserChanWhereUniqueInput>
    delete?: Enumerable<MutedUserChanWhereUniqueInput>
    connect?: Enumerable<MutedUserChanWhereUniqueInput>
    update?: Enumerable<MutedUserChanUpdateWithWhereUniqueWithoutMutedUserInput>
    updateMany?: Enumerable<MutedUserChanUpdateManyWithWhereWithoutMutedUserInput>
    deleteMany?: Enumerable<MutedUserChanScalarWhereInput>
  }

  export type RoleUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutUsersInput>, Enumerable<RoleUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutRequestingUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutRequestingUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutRequestingUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutRequestingUserInput>
    createMany?: DirectMessageCreateManyRequestingUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutRequestingUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutRequestingUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutRequestedUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutRequestedUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutRequestedUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutRequestedUserInput>
    createMany?: DirectMessageCreateManyRequestedUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutRequestedUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutRequestedUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type ChanUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<ChanCreateWithoutUsersInput>, Enumerable<ChanUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ChanCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<ChanUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<ChanWhereUniqueInput>
    disconnect?: Enumerable<ChanWhereUniqueInput>
    delete?: Enumerable<ChanWhereUniqueInput>
    connect?: Enumerable<ChanWhereUniqueInput>
    update?: Enumerable<ChanUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<ChanUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<ChanScalarWhereInput>
  }

  export type ChanUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<ChanCreateWithoutOwnerInput>, Enumerable<ChanUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ChanCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<ChanUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: ChanCreateManyOwnerInputEnvelope
    set?: Enumerable<ChanWhereUniqueInput>
    disconnect?: Enumerable<ChanWhereUniqueInput>
    delete?: Enumerable<ChanWhereUniqueInput>
    connect?: Enumerable<ChanWhereUniqueInput>
    update?: Enumerable<ChanUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<ChanUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<ChanScalarWhereInput>
  }

  export type FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput = {
    create?: XOR<Enumerable<FriendShipCreateWithoutRequestingUserInput>, Enumerable<FriendShipUncheckedCreateWithoutRequestingUserInput>>
    connectOrCreate?: Enumerable<FriendShipCreateOrConnectWithoutRequestingUserInput>
    upsert?: Enumerable<FriendShipUpsertWithWhereUniqueWithoutRequestingUserInput>
    createMany?: FriendShipCreateManyRequestingUserInputEnvelope
    set?: Enumerable<FriendShipWhereUniqueInput>
    disconnect?: Enumerable<FriendShipWhereUniqueInput>
    delete?: Enumerable<FriendShipWhereUniqueInput>
    connect?: Enumerable<FriendShipWhereUniqueInput>
    update?: Enumerable<FriendShipUpdateWithWhereUniqueWithoutRequestingUserInput>
    updateMany?: Enumerable<FriendShipUpdateManyWithWhereWithoutRequestingUserInput>
    deleteMany?: Enumerable<FriendShipScalarWhereInput>
  }

  export type FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput = {
    create?: XOR<Enumerable<FriendShipCreateWithoutRequestedUserInput>, Enumerable<FriendShipUncheckedCreateWithoutRequestedUserInput>>
    connectOrCreate?: Enumerable<FriendShipCreateOrConnectWithoutRequestedUserInput>
    upsert?: Enumerable<FriendShipUpsertWithWhereUniqueWithoutRequestedUserInput>
    createMany?: FriendShipCreateManyRequestedUserInputEnvelope
    set?: Enumerable<FriendShipWhereUniqueInput>
    disconnect?: Enumerable<FriendShipWhereUniqueInput>
    delete?: Enumerable<FriendShipWhereUniqueInput>
    connect?: Enumerable<FriendShipWhereUniqueInput>
    update?: Enumerable<FriendShipUpdateWithWhereUniqueWithoutRequestedUserInput>
    updateMany?: Enumerable<FriendShipUpdateManyWithWhereWithoutRequestedUserInput>
    deleteMany?: Enumerable<FriendShipScalarWhereInput>
  }

  export type FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput = {
    create?: XOR<Enumerable<FriendInvitationCreateWithoutInvitingUserInput>, Enumerable<FriendInvitationUncheckedCreateWithoutInvitingUserInput>>
    connectOrCreate?: Enumerable<FriendInvitationCreateOrConnectWithoutInvitingUserInput>
    upsert?: Enumerable<FriendInvitationUpsertWithWhereUniqueWithoutInvitingUserInput>
    createMany?: FriendInvitationCreateManyInvitingUserInputEnvelope
    set?: Enumerable<FriendInvitationWhereUniqueInput>
    disconnect?: Enumerable<FriendInvitationWhereUniqueInput>
    delete?: Enumerable<FriendInvitationWhereUniqueInput>
    connect?: Enumerable<FriendInvitationWhereUniqueInput>
    update?: Enumerable<FriendInvitationUpdateWithWhereUniqueWithoutInvitingUserInput>
    updateMany?: Enumerable<FriendInvitationUpdateManyWithWhereWithoutInvitingUserInput>
    deleteMany?: Enumerable<FriendInvitationScalarWhereInput>
  }

  export type FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<Enumerable<FriendInvitationCreateWithoutInvitedUserInput>, Enumerable<FriendInvitationUncheckedCreateWithoutInvitedUserInput>>
    connectOrCreate?: Enumerable<FriendInvitationCreateOrConnectWithoutInvitedUserInput>
    upsert?: Enumerable<FriendInvitationUpsertWithWhereUniqueWithoutInvitedUserInput>
    createMany?: FriendInvitationCreateManyInvitedUserInputEnvelope
    set?: Enumerable<FriendInvitationWhereUniqueInput>
    disconnect?: Enumerable<FriendInvitationWhereUniqueInput>
    delete?: Enumerable<FriendInvitationWhereUniqueInput>
    connect?: Enumerable<FriendInvitationWhereUniqueInput>
    update?: Enumerable<FriendInvitationUpdateWithWhereUniqueWithoutInvitedUserInput>
    updateMany?: Enumerable<FriendInvitationUpdateManyWithWhereWithoutInvitedUserInput>
    deleteMany?: Enumerable<FriendInvitationScalarWhereInput>
  }

  export type ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutInvitingUserInput>, Enumerable<ChanInvitationUncheckedCreateWithoutInvitingUserInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutInvitingUserInput>
    upsert?: Enumerable<ChanInvitationUpsertWithWhereUniqueWithoutInvitingUserInput>
    createMany?: ChanInvitationCreateManyInvitingUserInputEnvelope
    set?: Enumerable<ChanInvitationWhereUniqueInput>
    disconnect?: Enumerable<ChanInvitationWhereUniqueInput>
    delete?: Enumerable<ChanInvitationWhereUniqueInput>
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
    update?: Enumerable<ChanInvitationUpdateWithWhereUniqueWithoutInvitingUserInput>
    updateMany?: Enumerable<ChanInvitationUpdateManyWithWhereWithoutInvitingUserInput>
    deleteMany?: Enumerable<ChanInvitationScalarWhereInput>
  }

  export type ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutInvitedUserInput>, Enumerable<ChanInvitationUncheckedCreateWithoutInvitedUserInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutInvitedUserInput>
    upsert?: Enumerable<ChanInvitationUpsertWithWhereUniqueWithoutInvitedUserInput>
    createMany?: ChanInvitationCreateManyInvitedUserInputEnvelope
    set?: Enumerable<ChanInvitationWhereUniqueInput>
    disconnect?: Enumerable<ChanInvitationWhereUniqueInput>
    delete?: Enumerable<ChanInvitationWhereUniqueInput>
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
    update?: Enumerable<ChanInvitationUpdateWithWhereUniqueWithoutInvitedUserInput>
    updateMany?: Enumerable<ChanInvitationUpdateManyWithWhereWithoutInvitedUserInput>
    deleteMany?: Enumerable<ChanInvitationScalarWhereInput>
  }

  export type BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput = {
    create?: XOR<Enumerable<BlockedShipCreateWithoutBlockingUserInput>, Enumerable<BlockedShipUncheckedCreateWithoutBlockingUserInput>>
    connectOrCreate?: Enumerable<BlockedShipCreateOrConnectWithoutBlockingUserInput>
    upsert?: Enumerable<BlockedShipUpsertWithWhereUniqueWithoutBlockingUserInput>
    createMany?: BlockedShipCreateManyBlockingUserInputEnvelope
    set?: Enumerable<BlockedShipWhereUniqueInput>
    disconnect?: Enumerable<BlockedShipWhereUniqueInput>
    delete?: Enumerable<BlockedShipWhereUniqueInput>
    connect?: Enumerable<BlockedShipWhereUniqueInput>
    update?: Enumerable<BlockedShipUpdateWithWhereUniqueWithoutBlockingUserInput>
    updateMany?: Enumerable<BlockedShipUpdateManyWithWhereWithoutBlockingUserInput>
    deleteMany?: Enumerable<BlockedShipScalarWhereInput>
  }

  export type BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput = {
    create?: XOR<Enumerable<BlockedShipCreateWithoutBlockedUserInput>, Enumerable<BlockedShipUncheckedCreateWithoutBlockedUserInput>>
    connectOrCreate?: Enumerable<BlockedShipCreateOrConnectWithoutBlockedUserInput>
    upsert?: Enumerable<BlockedShipUpsertWithWhereUniqueWithoutBlockedUserInput>
    createMany?: BlockedShipCreateManyBlockedUserInputEnvelope
    set?: Enumerable<BlockedShipWhereUniqueInput>
    disconnect?: Enumerable<BlockedShipWhereUniqueInput>
    delete?: Enumerable<BlockedShipWhereUniqueInput>
    connect?: Enumerable<BlockedShipWhereUniqueInput>
    update?: Enumerable<BlockedShipUpdateWithWhereUniqueWithoutBlockedUserInput>
    updateMany?: Enumerable<BlockedShipUpdateManyWithWhereWithoutBlockedUserInput>
    deleteMany?: Enumerable<BlockedShipScalarWhereInput>
  }

  export type ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionElementCreateWithoutAuthorInput>, Enumerable<ChanDiscussionElementUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ChanDiscussionElementCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ChanDiscussionElementUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ChanDiscussionElementCreateManyAuthorInputEnvelope
    set?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    update?: Enumerable<ChanDiscussionElementUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ChanDiscussionElementUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ChanDiscussionElementScalarWhereInput>
  }

  export type ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionEventCreateWithoutConcernedUserInput>, Enumerable<ChanDiscussionEventUncheckedCreateWithoutConcernedUserInput>>
    connectOrCreate?: Enumerable<ChanDiscussionEventCreateOrConnectWithoutConcernedUserInput>
    upsert?: Enumerable<ChanDiscussionEventUpsertWithWhereUniqueWithoutConcernedUserInput>
    createMany?: ChanDiscussionEventCreateManyConcernedUserInputEnvelope
    set?: Enumerable<ChanDiscussionEventWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionEventWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionEventWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionEventWhereUniqueInput>
    update?: Enumerable<ChanDiscussionEventUpdateWithWhereUniqueWithoutConcernedUserInput>
    updateMany?: Enumerable<ChanDiscussionEventUpdateManyWithWhereWithoutConcernedUserInput>
    deleteMany?: Enumerable<ChanDiscussionEventScalarWhereInput>
  }

  export type DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput = {
    create?: XOR<Enumerable<DeletedMessageChanDiscussionEventCreateWithoutDeletingUsersInput>, Enumerable<DeletedMessageChanDiscussionEventUncheckedCreateWithoutDeletingUsersInput>>
    connectOrCreate?: Enumerable<DeletedMessageChanDiscussionEventCreateOrConnectWithoutDeletingUsersInput>
    upsert?: Enumerable<DeletedMessageChanDiscussionEventUpsertWithWhereUniqueWithoutDeletingUsersInput>
    createMany?: DeletedMessageChanDiscussionEventCreateManyDeletingUsersInputEnvelope
    set?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
    disconnect?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
    delete?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
    connect?: Enumerable<DeletedMessageChanDiscussionEventWhereUniqueInput>
    update?: Enumerable<DeletedMessageChanDiscussionEventUpdateWithWhereUniqueWithoutDeletingUsersInput>
    updateMany?: Enumerable<DeletedMessageChanDiscussionEventUpdateManyWithWhereWithoutDeletingUsersInput>
    deleteMany?: Enumerable<DeletedMessageChanDiscussionEventScalarWhereInput>
  }

  export type ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedUsersInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedUsersInput>
    upsert?: Enumerable<ChanDiscussionMessageUpsertWithWhereUniqueWithoutRelatedUsersInput>
    set?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    update?: Enumerable<ChanDiscussionMessageUpdateWithWhereUniqueWithoutRelatedUsersInput>
    updateMany?: Enumerable<ChanDiscussionMessageUpdateManyWithWhereWithoutRelatedUsersInput>
    deleteMany?: Enumerable<ChanDiscussionMessageScalarWhereInput>
  }

  export type DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput = {
    create?: XOR<Enumerable<DmDiscussionElementCreateWithoutAuthorRelationInput>, Enumerable<DmDiscussionElementUncheckedCreateWithoutAuthorRelationInput>>
    connectOrCreate?: Enumerable<DmDiscussionElementCreateOrConnectWithoutAuthorRelationInput>
    upsert?: Enumerable<DmDiscussionElementUpsertWithWhereUniqueWithoutAuthorRelationInput>
    createMany?: DmDiscussionElementCreateManyAuthorRelationInputEnvelope
    set?: Enumerable<DmDiscussionElementWhereUniqueInput>
    disconnect?: Enumerable<DmDiscussionElementWhereUniqueInput>
    delete?: Enumerable<DmDiscussionElementWhereUniqueInput>
    connect?: Enumerable<DmDiscussionElementWhereUniqueInput>
    update?: Enumerable<DmDiscussionElementUpdateWithWhereUniqueWithoutAuthorRelationInput>
    updateMany?: Enumerable<DmDiscussionElementUpdateManyWithWhereWithoutAuthorRelationInput>
    deleteMany?: Enumerable<DmDiscussionElementScalarWhereInput>
  }

  export type DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput = {
    create?: XOR<Enumerable<DmDiscussionMessageCreateWithoutRelatedUsersInput>, Enumerable<DmDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>>
    connectOrCreate?: Enumerable<DmDiscussionMessageCreateOrConnectWithoutRelatedUsersInput>
    upsert?: Enumerable<DmDiscussionMessageUpsertWithWhereUniqueWithoutRelatedUsersInput>
    set?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    update?: Enumerable<DmDiscussionMessageUpdateWithWhereUniqueWithoutRelatedUsersInput>
    updateMany?: Enumerable<DmDiscussionMessageUpdateManyWithWhereWithoutRelatedUsersInput>
    deleteMany?: Enumerable<DmDiscussionMessageScalarWhereInput>
  }

  export type MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput = {
    create?: XOR<Enumerable<MutedUserChanCreateWithoutMutedUserInput>, Enumerable<MutedUserChanUncheckedCreateWithoutMutedUserInput>>
    connectOrCreate?: Enumerable<MutedUserChanCreateOrConnectWithoutMutedUserInput>
    upsert?: Enumerable<MutedUserChanUpsertWithWhereUniqueWithoutMutedUserInput>
    createMany?: MutedUserChanCreateManyMutedUserInputEnvelope
    set?: Enumerable<MutedUserChanWhereUniqueInput>
    disconnect?: Enumerable<MutedUserChanWhereUniqueInput>
    delete?: Enumerable<MutedUserChanWhereUniqueInput>
    connect?: Enumerable<MutedUserChanWhereUniqueInput>
    update?: Enumerable<MutedUserChanUpdateWithWhereUniqueWithoutMutedUserInput>
    updateMany?: Enumerable<MutedUserChanUpdateManyWithWhereWithoutMutedUserInput>
    deleteMany?: Enumerable<MutedUserChanScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutDirectMessageInput = {
    create?: XOR<UserCreateWithoutDirectMessageInput, UserUncheckedCreateWithoutDirectMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessageInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDirectMessageOfInput = {
    create?: XOR<UserCreateWithoutDirectMessageOfInput, UserUncheckedCreateWithoutDirectMessageOfInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessageOfInput
    connect?: UserWhereUniqueInput
  }

  export type DmDiscussionElementCreateNestedManyWithoutDirectMessageInput = {
    create?: XOR<Enumerable<DmDiscussionElementCreateWithoutDirectMessageInput>, Enumerable<DmDiscussionElementUncheckedCreateWithoutDirectMessageInput>>
    connectOrCreate?: Enumerable<DmDiscussionElementCreateOrConnectWithoutDirectMessageInput>
    createMany?: DmDiscussionElementCreateManyDirectMessageInputEnvelope
    connect?: Enumerable<DmDiscussionElementWhereUniqueInput>
  }

  export type DmDiscussionElementUncheckedCreateNestedManyWithoutDirectMessageInput = {
    create?: XOR<Enumerable<DmDiscussionElementCreateWithoutDirectMessageInput>, Enumerable<DmDiscussionElementUncheckedCreateWithoutDirectMessageInput>>
    connectOrCreate?: Enumerable<DmDiscussionElementCreateOrConnectWithoutDirectMessageInput>
    createMany?: DmDiscussionElementCreateManyDirectMessageInputEnvelope
    connect?: Enumerable<DmDiscussionElementWhereUniqueInput>
  }

  export type EnumDirectMessageUserStatusFieldUpdateOperationsInput = {
    set?: DirectMessageUserStatus
  }

  export type EnumDirectMessageStatusFieldUpdateOperationsInput = {
    set?: DirectMessageStatus
  }

  export type UserUpdateOneRequiredWithoutDirectMessageNestedInput = {
    create?: XOR<UserCreateWithoutDirectMessageInput, UserUncheckedCreateWithoutDirectMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessageInput
    upsert?: UserUpsertWithoutDirectMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDirectMessageInput, UserUpdateWithoutDirectMessageInput>, UserUncheckedUpdateWithoutDirectMessageInput>
  }

  export type UserUpdateOneRequiredWithoutDirectMessageOfNestedInput = {
    create?: XOR<UserCreateWithoutDirectMessageOfInput, UserUncheckedCreateWithoutDirectMessageOfInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessageOfInput
    upsert?: UserUpsertWithoutDirectMessageOfInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDirectMessageOfInput, UserUpdateWithoutDirectMessageOfInput>, UserUncheckedUpdateWithoutDirectMessageOfInput>
  }

  export type DmDiscussionElementUpdateManyWithoutDirectMessageNestedInput = {
    create?: XOR<Enumerable<DmDiscussionElementCreateWithoutDirectMessageInput>, Enumerable<DmDiscussionElementUncheckedCreateWithoutDirectMessageInput>>
    connectOrCreate?: Enumerable<DmDiscussionElementCreateOrConnectWithoutDirectMessageInput>
    upsert?: Enumerable<DmDiscussionElementUpsertWithWhereUniqueWithoutDirectMessageInput>
    createMany?: DmDiscussionElementCreateManyDirectMessageInputEnvelope
    set?: Enumerable<DmDiscussionElementWhereUniqueInput>
    disconnect?: Enumerable<DmDiscussionElementWhereUniqueInput>
    delete?: Enumerable<DmDiscussionElementWhereUniqueInput>
    connect?: Enumerable<DmDiscussionElementWhereUniqueInput>
    update?: Enumerable<DmDiscussionElementUpdateWithWhereUniqueWithoutDirectMessageInput>
    updateMany?: Enumerable<DmDiscussionElementUpdateManyWithWhereWithoutDirectMessageInput>
    deleteMany?: Enumerable<DmDiscussionElementScalarWhereInput>
  }

  export type DmDiscussionElementUncheckedUpdateManyWithoutDirectMessageNestedInput = {
    create?: XOR<Enumerable<DmDiscussionElementCreateWithoutDirectMessageInput>, Enumerable<DmDiscussionElementUncheckedCreateWithoutDirectMessageInput>>
    connectOrCreate?: Enumerable<DmDiscussionElementCreateOrConnectWithoutDirectMessageInput>
    upsert?: Enumerable<DmDiscussionElementUpsertWithWhereUniqueWithoutDirectMessageInput>
    createMany?: DmDiscussionElementCreateManyDirectMessageInputEnvelope
    set?: Enumerable<DmDiscussionElementWhereUniqueInput>
    disconnect?: Enumerable<DmDiscussionElementWhereUniqueInput>
    delete?: Enumerable<DmDiscussionElementWhereUniqueInput>
    connect?: Enumerable<DmDiscussionElementWhereUniqueInput>
    update?: Enumerable<DmDiscussionElementUpdateWithWhereUniqueWithoutDirectMessageInput>
    updateMany?: Enumerable<DmDiscussionElementUpdateManyWithWhereWithoutDirectMessageInput>
    deleteMany?: Enumerable<DmDiscussionElementScalarWhereInput>
  }

  export type DmDiscussionMessageCreateNestedOneWithoutDiscussionElementInput = {
    create?: XOR<DmDiscussionMessageCreateWithoutDiscussionElementInput, DmDiscussionMessageUncheckedCreateWithoutDiscussionElementInput>
    connectOrCreate?: DmDiscussionMessageCreateOrConnectWithoutDiscussionElementInput
    connect?: DmDiscussionMessageWhereUniqueInput
  }

  export type DmDiscussionEventCreateNestedOneWithoutDiscussionElementInput = {
    create?: XOR<DmDiscussionEventCreateWithoutDiscussionElementInput, DmDiscussionEventUncheckedCreateWithoutDiscussionElementInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutDiscussionElementInput
    connect?: DmDiscussionEventWhereUniqueInput
  }

  export type DmDiscussionMessageCreateNestedManyWithoutRelatedInput = {
    create?: XOR<Enumerable<DmDiscussionMessageCreateWithoutRelatedInput>, Enumerable<DmDiscussionMessageUncheckedCreateWithoutRelatedInput>>
    connectOrCreate?: Enumerable<DmDiscussionMessageCreateOrConnectWithoutRelatedInput>
    createMany?: DmDiscussionMessageCreateManyRelatedInputEnvelope
    connect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutDmDiscussionElementInput = {
    create?: XOR<UserCreateWithoutDmDiscussionElementInput, UserUncheckedCreateWithoutDmDiscussionElementInput>
    connectOrCreate?: UserCreateOrConnectWithoutDmDiscussionElementInput
    connect?: UserWhereUniqueInput
  }

  export type DirectMessageCreateNestedOneWithoutElementsInput = {
    create?: XOR<DirectMessageCreateWithoutElementsInput, DirectMessageUncheckedCreateWithoutElementsInput>
    connectOrCreate?: DirectMessageCreateOrConnectWithoutElementsInput
    connect?: DirectMessageWhereUniqueInput
  }

  export type DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput = {
    create?: XOR<Enumerable<DmDiscussionMessageCreateWithoutRelatedInput>, Enumerable<DmDiscussionMessageUncheckedCreateWithoutRelatedInput>>
    connectOrCreate?: Enumerable<DmDiscussionMessageCreateOrConnectWithoutRelatedInput>
    createMany?: DmDiscussionMessageCreateManyRelatedInputEnvelope
    connect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
  }

  export type DmDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput = {
    create?: XOR<DmDiscussionMessageCreateWithoutDiscussionElementInput, DmDiscussionMessageUncheckedCreateWithoutDiscussionElementInput>
    connectOrCreate?: DmDiscussionMessageCreateOrConnectWithoutDiscussionElementInput
    upsert?: DmDiscussionMessageUpsertWithoutDiscussionElementInput
    disconnect?: DmDiscussionMessageWhereInput | boolean
    delete?: DmDiscussionMessageWhereInput | boolean
    connect?: DmDiscussionMessageWhereUniqueInput
    update?: XOR<XOR<DmDiscussionMessageUpdateToOneWithWhereWithoutDiscussionElementInput, DmDiscussionMessageUpdateWithoutDiscussionElementInput>, DmDiscussionMessageUncheckedUpdateWithoutDiscussionElementInput>
  }

  export type DmDiscussionEventUpdateOneWithoutDiscussionElementNestedInput = {
    create?: XOR<DmDiscussionEventCreateWithoutDiscussionElementInput, DmDiscussionEventUncheckedCreateWithoutDiscussionElementInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutDiscussionElementInput
    upsert?: DmDiscussionEventUpsertWithoutDiscussionElementInput
    disconnect?: DmDiscussionEventWhereInput | boolean
    delete?: DmDiscussionEventWhereInput | boolean
    connect?: DmDiscussionEventWhereUniqueInput
    update?: XOR<XOR<DmDiscussionEventUpdateToOneWithWhereWithoutDiscussionElementInput, DmDiscussionEventUpdateWithoutDiscussionElementInput>, DmDiscussionEventUncheckedUpdateWithoutDiscussionElementInput>
  }

  export type DmDiscussionMessageUpdateManyWithoutRelatedNestedInput = {
    create?: XOR<Enumerable<DmDiscussionMessageCreateWithoutRelatedInput>, Enumerable<DmDiscussionMessageUncheckedCreateWithoutRelatedInput>>
    connectOrCreate?: Enumerable<DmDiscussionMessageCreateOrConnectWithoutRelatedInput>
    upsert?: Enumerable<DmDiscussionMessageUpsertWithWhereUniqueWithoutRelatedInput>
    createMany?: DmDiscussionMessageCreateManyRelatedInputEnvelope
    set?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    update?: Enumerable<DmDiscussionMessageUpdateWithWhereUniqueWithoutRelatedInput>
    updateMany?: Enumerable<DmDiscussionMessageUpdateManyWithWhereWithoutRelatedInput>
    deleteMany?: Enumerable<DmDiscussionMessageScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutDmDiscussionElementNestedInput = {
    create?: XOR<UserCreateWithoutDmDiscussionElementInput, UserUncheckedCreateWithoutDmDiscussionElementInput>
    connectOrCreate?: UserCreateOrConnectWithoutDmDiscussionElementInput
    upsert?: UserUpsertWithoutDmDiscussionElementInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDmDiscussionElementInput, UserUpdateWithoutDmDiscussionElementInput>, UserUncheckedUpdateWithoutDmDiscussionElementInput>
  }

  export type DirectMessageUpdateOneRequiredWithoutElementsNestedInput = {
    create?: XOR<DirectMessageCreateWithoutElementsInput, DirectMessageUncheckedCreateWithoutElementsInput>
    connectOrCreate?: DirectMessageCreateOrConnectWithoutElementsInput
    upsert?: DirectMessageUpsertWithoutElementsInput
    connect?: DirectMessageWhereUniqueInput
    update?: XOR<XOR<DirectMessageUpdateToOneWithWhereWithoutElementsInput, DirectMessageUpdateWithoutElementsInput>, DirectMessageUncheckedUpdateWithoutElementsInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DmDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput = {
    create?: XOR<Enumerable<DmDiscussionMessageCreateWithoutRelatedInput>, Enumerable<DmDiscussionMessageUncheckedCreateWithoutRelatedInput>>
    connectOrCreate?: Enumerable<DmDiscussionMessageCreateOrConnectWithoutRelatedInput>
    upsert?: Enumerable<DmDiscussionMessageUpsertWithWhereUniqueWithoutRelatedInput>
    createMany?: DmDiscussionMessageCreateManyRelatedInputEnvelope
    set?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<DmDiscussionMessageWhereUniqueInput>
    update?: Enumerable<DmDiscussionMessageUpdateWithWhereUniqueWithoutRelatedInput>
    updateMany?: Enumerable<DmDiscussionMessageUpdateManyWithWhereWithoutRelatedInput>
    deleteMany?: Enumerable<DmDiscussionMessageScalarWhereInput>
  }

  export type UserCreateNestedManyWithoutDmDiscussionMessageInput = {
    create?: XOR<Enumerable<UserCreateWithoutDmDiscussionMessageInput>, Enumerable<UserUncheckedCreateWithoutDmDiscussionMessageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutDmDiscussionMessageInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type DmDiscussionElementCreateNestedOneWithoutRelatedOfInput = {
    create?: XOR<DmDiscussionElementCreateWithoutRelatedOfInput, DmDiscussionElementUncheckedCreateWithoutRelatedOfInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutRelatedOfInput
    connect?: DmDiscussionElementWhereUniqueInput
  }

  export type DmDiscussionElementCreateNestedOneWithoutMessageInput = {
    create?: XOR<DmDiscussionElementCreateWithoutMessageInput, DmDiscussionElementUncheckedCreateWithoutMessageInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutMessageInput
    connect?: DmDiscussionElementWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutDmDiscussionMessageInput = {
    create?: XOR<Enumerable<UserCreateWithoutDmDiscussionMessageInput>, Enumerable<UserUncheckedCreateWithoutDmDiscussionMessageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutDmDiscussionMessageInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type DmDiscussionElementUncheckedCreateNestedOneWithoutMessageInput = {
    create?: XOR<DmDiscussionElementCreateWithoutMessageInput, DmDiscussionElementUncheckedCreateWithoutMessageInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutMessageInput
    connect?: DmDiscussionElementWhereUniqueInput
  }

  export type UserUpdateManyWithoutDmDiscussionMessageNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutDmDiscussionMessageInput>, Enumerable<UserUncheckedCreateWithoutDmDiscussionMessageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutDmDiscussionMessageInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutDmDiscussionMessageInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutDmDiscussionMessageInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutDmDiscussionMessageInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type DmDiscussionElementUpdateOneWithoutRelatedOfNestedInput = {
    create?: XOR<DmDiscussionElementCreateWithoutRelatedOfInput, DmDiscussionElementUncheckedCreateWithoutRelatedOfInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutRelatedOfInput
    upsert?: DmDiscussionElementUpsertWithoutRelatedOfInput
    disconnect?: DmDiscussionElementWhereInput | boolean
    delete?: DmDiscussionElementWhereInput | boolean
    connect?: DmDiscussionElementWhereUniqueInput
    update?: XOR<XOR<DmDiscussionElementUpdateToOneWithWhereWithoutRelatedOfInput, DmDiscussionElementUpdateWithoutRelatedOfInput>, DmDiscussionElementUncheckedUpdateWithoutRelatedOfInput>
  }

  export type DmDiscussionElementUpdateOneWithoutMessageNestedInput = {
    create?: XOR<DmDiscussionElementCreateWithoutMessageInput, DmDiscussionElementUncheckedCreateWithoutMessageInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutMessageInput
    upsert?: DmDiscussionElementUpsertWithoutMessageInput
    disconnect?: DmDiscussionElementWhereInput | boolean
    delete?: DmDiscussionElementWhereInput | boolean
    connect?: DmDiscussionElementWhereUniqueInput
    update?: XOR<XOR<DmDiscussionElementUpdateToOneWithWhereWithoutMessageInput, DmDiscussionElementUpdateWithoutMessageInput>, DmDiscussionElementUncheckedUpdateWithoutMessageInput>
  }

  export type UserUncheckedUpdateManyWithoutDmDiscussionMessageNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutDmDiscussionMessageInput>, Enumerable<UserUncheckedCreateWithoutDmDiscussionMessageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutDmDiscussionMessageInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutDmDiscussionMessageInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutDmDiscussionMessageInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutDmDiscussionMessageInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type DmDiscussionElementUncheckedUpdateOneWithoutMessageNestedInput = {
    create?: XOR<DmDiscussionElementCreateWithoutMessageInput, DmDiscussionElementUncheckedCreateWithoutMessageInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutMessageInput
    upsert?: DmDiscussionElementUpsertWithoutMessageInput
    disconnect?: DmDiscussionElementWhereInput | boolean
    delete?: DmDiscussionElementWhereInput | boolean
    connect?: DmDiscussionElementWhereUniqueInput
    update?: XOR<XOR<DmDiscussionElementUpdateToOneWithWhereWithoutMessageInput, DmDiscussionElementUpdateWithoutMessageInput>, DmDiscussionElementUncheckedUpdateWithoutMessageInput>
  }

  export type ClassicDmDiscussionEventCreateNestedOneWithoutDmDiscussionEventInput = {
    create?: XOR<ClassicDmDiscussionEventCreateWithoutDmDiscussionEventInput, ClassicDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput>
    connectOrCreate?: ClassicDmDiscussionEventCreateOrConnectWithoutDmDiscussionEventInput
    connect?: ClassicDmDiscussionEventWhereUniqueInput
  }

  export type ChanInvitationDmDiscussionEventCreateNestedOneWithoutDmDiscussionEventInput = {
    create?: XOR<ChanInvitationDmDiscussionEventCreateWithoutDmDiscussionEventInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput>
    connectOrCreate?: ChanInvitationDmDiscussionEventCreateOrConnectWithoutDmDiscussionEventInput
    connect?: ChanInvitationDmDiscussionEventWhereUniqueInput
  }

  export type DmDiscussionElementCreateNestedOneWithoutEventInput = {
    create?: XOR<DmDiscussionElementCreateWithoutEventInput, DmDiscussionElementUncheckedCreateWithoutEventInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutEventInput
    connect?: DmDiscussionElementWhereUniqueInput
  }

  export type DmDiscussionElementUncheckedCreateNestedOneWithoutEventInput = {
    create?: XOR<DmDiscussionElementCreateWithoutEventInput, DmDiscussionElementUncheckedCreateWithoutEventInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutEventInput
    connect?: DmDiscussionElementWhereUniqueInput
  }

  export type ClassicDmDiscussionEventUpdateOneWithoutDmDiscussionEventNestedInput = {
    create?: XOR<ClassicDmDiscussionEventCreateWithoutDmDiscussionEventInput, ClassicDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput>
    connectOrCreate?: ClassicDmDiscussionEventCreateOrConnectWithoutDmDiscussionEventInput
    upsert?: ClassicDmDiscussionEventUpsertWithoutDmDiscussionEventInput
    disconnect?: ClassicDmDiscussionEventWhereInput | boolean
    delete?: ClassicDmDiscussionEventWhereInput | boolean
    connect?: ClassicDmDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ClassicDmDiscussionEventUpdateToOneWithWhereWithoutDmDiscussionEventInput, ClassicDmDiscussionEventUpdateWithoutDmDiscussionEventInput>, ClassicDmDiscussionEventUncheckedUpdateWithoutDmDiscussionEventInput>
  }

  export type ChanInvitationDmDiscussionEventUpdateOneWithoutDmDiscussionEventNestedInput = {
    create?: XOR<ChanInvitationDmDiscussionEventCreateWithoutDmDiscussionEventInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput>
    connectOrCreate?: ChanInvitationDmDiscussionEventCreateOrConnectWithoutDmDiscussionEventInput
    upsert?: ChanInvitationDmDiscussionEventUpsertWithoutDmDiscussionEventInput
    disconnect?: ChanInvitationDmDiscussionEventWhereInput | boolean
    delete?: ChanInvitationDmDiscussionEventWhereInput | boolean
    connect?: ChanInvitationDmDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanInvitationDmDiscussionEventUpdateToOneWithWhereWithoutDmDiscussionEventInput, ChanInvitationDmDiscussionEventUpdateWithoutDmDiscussionEventInput>, ChanInvitationDmDiscussionEventUncheckedUpdateWithoutDmDiscussionEventInput>
  }

  export type DmDiscussionElementUpdateOneWithoutEventNestedInput = {
    create?: XOR<DmDiscussionElementCreateWithoutEventInput, DmDiscussionElementUncheckedCreateWithoutEventInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutEventInput
    upsert?: DmDiscussionElementUpsertWithoutEventInput
    disconnect?: DmDiscussionElementWhereInput | boolean
    delete?: DmDiscussionElementWhereInput | boolean
    connect?: DmDiscussionElementWhereUniqueInput
    update?: XOR<XOR<DmDiscussionElementUpdateToOneWithWhereWithoutEventInput, DmDiscussionElementUpdateWithoutEventInput>, DmDiscussionElementUncheckedUpdateWithoutEventInput>
  }

  export type DmDiscussionElementUncheckedUpdateOneWithoutEventNestedInput = {
    create?: XOR<DmDiscussionElementCreateWithoutEventInput, DmDiscussionElementUncheckedCreateWithoutEventInput>
    connectOrCreate?: DmDiscussionElementCreateOrConnectWithoutEventInput
    upsert?: DmDiscussionElementUpsertWithoutEventInput
    disconnect?: DmDiscussionElementWhereInput | boolean
    delete?: DmDiscussionElementWhereInput | boolean
    connect?: DmDiscussionElementWhereUniqueInput
    update?: XOR<XOR<DmDiscussionElementUpdateToOneWithWhereWithoutEventInput, DmDiscussionElementUpdateWithoutEventInput>, DmDiscussionElementUncheckedUpdateWithoutEventInput>
  }

  export type ChanInvitationCreateNestedOneWithoutDiscussionEventInput = {
    create?: XOR<ChanInvitationCreateWithoutDiscussionEventInput, ChanInvitationUncheckedCreateWithoutDiscussionEventInput>
    connectOrCreate?: ChanInvitationCreateOrConnectWithoutDiscussionEventInput
    connect?: ChanInvitationWhereUniqueInput
  }

  export type DmDiscussionEventCreateNestedOneWithoutChanInvitationDmDiscussionEventInput = {
    create?: XOR<DmDiscussionEventCreateWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutChanInvitationDmDiscussionEventInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutChanInvitationDmDiscussionEventInput
    connect?: DmDiscussionEventWhereUniqueInput
  }

  export type DmDiscussionEventUncheckedCreateNestedOneWithoutChanInvitationDmDiscussionEventInput = {
    create?: XOR<DmDiscussionEventCreateWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutChanInvitationDmDiscussionEventInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutChanInvitationDmDiscussionEventInput
    connect?: DmDiscussionEventWhereUniqueInput
  }

  export type ChanInvitationUpdateOneRequiredWithoutDiscussionEventNestedInput = {
    create?: XOR<ChanInvitationCreateWithoutDiscussionEventInput, ChanInvitationUncheckedCreateWithoutDiscussionEventInput>
    connectOrCreate?: ChanInvitationCreateOrConnectWithoutDiscussionEventInput
    upsert?: ChanInvitationUpsertWithoutDiscussionEventInput
    connect?: ChanInvitationWhereUniqueInput
    update?: XOR<XOR<ChanInvitationUpdateToOneWithWhereWithoutDiscussionEventInput, ChanInvitationUpdateWithoutDiscussionEventInput>, ChanInvitationUncheckedUpdateWithoutDiscussionEventInput>
  }

  export type DmDiscussionEventUpdateOneWithoutChanInvitationDmDiscussionEventNestedInput = {
    create?: XOR<DmDiscussionEventCreateWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutChanInvitationDmDiscussionEventInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutChanInvitationDmDiscussionEventInput
    upsert?: DmDiscussionEventUpsertWithoutChanInvitationDmDiscussionEventInput
    disconnect?: DmDiscussionEventWhereInput | boolean
    delete?: DmDiscussionEventWhereInput | boolean
    connect?: DmDiscussionEventWhereUniqueInput
    update?: XOR<XOR<DmDiscussionEventUpdateToOneWithWhereWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUpdateWithoutChanInvitationDmDiscussionEventInput>, DmDiscussionEventUncheckedUpdateWithoutChanInvitationDmDiscussionEventInput>
  }

  export type DmDiscussionEventUncheckedUpdateOneWithoutChanInvitationDmDiscussionEventNestedInput = {
    create?: XOR<DmDiscussionEventCreateWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutChanInvitationDmDiscussionEventInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutChanInvitationDmDiscussionEventInput
    upsert?: DmDiscussionEventUpsertWithoutChanInvitationDmDiscussionEventInput
    disconnect?: DmDiscussionEventWhereInput | boolean
    delete?: DmDiscussionEventWhereInput | boolean
    connect?: DmDiscussionEventWhereUniqueInput
    update?: XOR<XOR<DmDiscussionEventUpdateToOneWithWhereWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUpdateWithoutChanInvitationDmDiscussionEventInput>, DmDiscussionEventUncheckedUpdateWithoutChanInvitationDmDiscussionEventInput>
  }

  export type DmDiscussionEventCreateNestedOneWithoutClassicDmDiscussionEventInput = {
    create?: XOR<DmDiscussionEventCreateWithoutClassicDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutClassicDmDiscussionEventInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutClassicDmDiscussionEventInput
    connect?: DmDiscussionEventWhereUniqueInput
  }

  export type DmDiscussionEventUncheckedCreateNestedOneWithoutClassicDmDiscussionEventInput = {
    create?: XOR<DmDiscussionEventCreateWithoutClassicDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutClassicDmDiscussionEventInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutClassicDmDiscussionEventInput
    connect?: DmDiscussionEventWhereUniqueInput
  }

  export type EnumClassicDmEventTypeFieldUpdateOperationsInput = {
    set?: ClassicDmEventType
  }

  export type DmDiscussionEventUpdateOneWithoutClassicDmDiscussionEventNestedInput = {
    create?: XOR<DmDiscussionEventCreateWithoutClassicDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutClassicDmDiscussionEventInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutClassicDmDiscussionEventInput
    upsert?: DmDiscussionEventUpsertWithoutClassicDmDiscussionEventInput
    disconnect?: DmDiscussionEventWhereInput | boolean
    delete?: DmDiscussionEventWhereInput | boolean
    connect?: DmDiscussionEventWhereUniqueInput
    update?: XOR<XOR<DmDiscussionEventUpdateToOneWithWhereWithoutClassicDmDiscussionEventInput, DmDiscussionEventUpdateWithoutClassicDmDiscussionEventInput>, DmDiscussionEventUncheckedUpdateWithoutClassicDmDiscussionEventInput>
  }

  export type DmDiscussionEventUncheckedUpdateOneWithoutClassicDmDiscussionEventNestedInput = {
    create?: XOR<DmDiscussionEventCreateWithoutClassicDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutClassicDmDiscussionEventInput>
    connectOrCreate?: DmDiscussionEventCreateOrConnectWithoutClassicDmDiscussionEventInput
    upsert?: DmDiscussionEventUpsertWithoutClassicDmDiscussionEventInput
    disconnect?: DmDiscussionEventWhereInput | boolean
    delete?: DmDiscussionEventWhereInput | boolean
    connect?: DmDiscussionEventWhereUniqueInput
    update?: XOR<XOR<DmDiscussionEventUpdateToOneWithWhereWithoutClassicDmDiscussionEventInput, DmDiscussionEventUpdateWithoutClassicDmDiscussionEventInput>, DmDiscussionEventUncheckedUpdateWithoutClassicDmDiscussionEventInput>
  }

  export type UserCreateNestedManyWithoutChansInput = {
    create?: XOR<Enumerable<UserCreateWithoutChansInput>, Enumerable<UserUncheckedCreateWithoutChansInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutChansInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type RoleCreateNestedManyWithoutChanInput = {
    create?: XOR<Enumerable<RoleCreateWithoutChanInput>, Enumerable<RoleUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutChanInput>
    createMany?: RoleCreateManyChanInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutOwnedChansInput = {
    create?: XOR<UserCreateWithoutOwnedChansInput, UserUncheckedCreateWithoutOwnedChansInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedChansInput
    connect?: UserWhereUniqueInput
  }

  export type MutedUserChanCreateNestedManyWithoutChanInput = {
    create?: XOR<Enumerable<MutedUserChanCreateWithoutChanInput>, Enumerable<MutedUserChanUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<MutedUserChanCreateOrConnectWithoutChanInput>
    createMany?: MutedUserChanCreateManyChanInputEnvelope
    connect?: Enumerable<MutedUserChanWhereUniqueInput>
  }

  export type ChanInvitationCreateNestedManyWithoutChanInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutChanInput>, Enumerable<ChanInvitationUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutChanInput>
    createMany?: ChanInvitationCreateManyChanInputEnvelope
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
  }

  export type ChanDiscussionElementCreateNestedManyWithoutChanInput = {
    create?: XOR<Enumerable<ChanDiscussionElementCreateWithoutChanInput>, Enumerable<ChanDiscussionElementUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<ChanDiscussionElementCreateOrConnectWithoutChanInput>
    createMany?: ChanDiscussionElementCreateManyChanInputEnvelope
    connect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutChansInput = {
    create?: XOR<Enumerable<UserCreateWithoutChansInput>, Enumerable<UserUncheckedCreateWithoutChansInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutChansInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedManyWithoutChanInput = {
    create?: XOR<Enumerable<RoleCreateWithoutChanInput>, Enumerable<RoleUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutChanInput>
    createMany?: RoleCreateManyChanInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type MutedUserChanUncheckedCreateNestedManyWithoutChanInput = {
    create?: XOR<Enumerable<MutedUserChanCreateWithoutChanInput>, Enumerable<MutedUserChanUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<MutedUserChanCreateOrConnectWithoutChanInput>
    createMany?: MutedUserChanCreateManyChanInputEnvelope
    connect?: Enumerable<MutedUserChanWhereUniqueInput>
  }

  export type ChanInvitationUncheckedCreateNestedManyWithoutChanInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutChanInput>, Enumerable<ChanInvitationUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutChanInput>
    createMany?: ChanInvitationCreateManyChanInputEnvelope
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
  }

  export type ChanDiscussionElementUncheckedCreateNestedManyWithoutChanInput = {
    create?: XOR<Enumerable<ChanDiscussionElementCreateWithoutChanInput>, Enumerable<ChanDiscussionElementUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<ChanDiscussionElementCreateOrConnectWithoutChanInput>
    createMany?: ChanDiscussionElementCreateManyChanInputEnvelope
    connect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
  }

  export type EnumChanTypeFieldUpdateOperationsInput = {
    set?: ChanType
  }

  export type UserUpdateManyWithoutChansNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutChansInput>, Enumerable<UserUncheckedCreateWithoutChansInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutChansInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutChansInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutChansInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutChansInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type RoleUpdateManyWithoutChanNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutChanInput>, Enumerable<RoleUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutChanInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutChanInput>
    createMany?: RoleCreateManyChanInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutChanInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutChanInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedChansNestedInput = {
    create?: XOR<UserCreateWithoutOwnedChansInput, UserUncheckedCreateWithoutOwnedChansInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedChansInput
    upsert?: UserUpsertWithoutOwnedChansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedChansInput, UserUpdateWithoutOwnedChansInput>, UserUncheckedUpdateWithoutOwnedChansInput>
  }

  export type MutedUserChanUpdateManyWithoutChanNestedInput = {
    create?: XOR<Enumerable<MutedUserChanCreateWithoutChanInput>, Enumerable<MutedUserChanUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<MutedUserChanCreateOrConnectWithoutChanInput>
    upsert?: Enumerable<MutedUserChanUpsertWithWhereUniqueWithoutChanInput>
    createMany?: MutedUserChanCreateManyChanInputEnvelope
    set?: Enumerable<MutedUserChanWhereUniqueInput>
    disconnect?: Enumerable<MutedUserChanWhereUniqueInput>
    delete?: Enumerable<MutedUserChanWhereUniqueInput>
    connect?: Enumerable<MutedUserChanWhereUniqueInput>
    update?: Enumerable<MutedUserChanUpdateWithWhereUniqueWithoutChanInput>
    updateMany?: Enumerable<MutedUserChanUpdateManyWithWhereWithoutChanInput>
    deleteMany?: Enumerable<MutedUserChanScalarWhereInput>
  }

  export type ChanInvitationUpdateManyWithoutChanNestedInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutChanInput>, Enumerable<ChanInvitationUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutChanInput>
    upsert?: Enumerable<ChanInvitationUpsertWithWhereUniqueWithoutChanInput>
    createMany?: ChanInvitationCreateManyChanInputEnvelope
    set?: Enumerable<ChanInvitationWhereUniqueInput>
    disconnect?: Enumerable<ChanInvitationWhereUniqueInput>
    delete?: Enumerable<ChanInvitationWhereUniqueInput>
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
    update?: Enumerable<ChanInvitationUpdateWithWhereUniqueWithoutChanInput>
    updateMany?: Enumerable<ChanInvitationUpdateManyWithWhereWithoutChanInput>
    deleteMany?: Enumerable<ChanInvitationScalarWhereInput>
  }

  export type ChanDiscussionElementUpdateManyWithoutChanNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionElementCreateWithoutChanInput>, Enumerable<ChanDiscussionElementUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<ChanDiscussionElementCreateOrConnectWithoutChanInput>
    upsert?: Enumerable<ChanDiscussionElementUpsertWithWhereUniqueWithoutChanInput>
    createMany?: ChanDiscussionElementCreateManyChanInputEnvelope
    set?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    update?: Enumerable<ChanDiscussionElementUpdateWithWhereUniqueWithoutChanInput>
    updateMany?: Enumerable<ChanDiscussionElementUpdateManyWithWhereWithoutChanInput>
    deleteMany?: Enumerable<ChanDiscussionElementScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutChansNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutChansInput>, Enumerable<UserUncheckedCreateWithoutChansInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutChansInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutChansInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutChansInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutChansInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type RoleUncheckedUpdateManyWithoutChanNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutChanInput>, Enumerable<RoleUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutChanInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutChanInput>
    createMany?: RoleCreateManyChanInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutChanInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutChanInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type MutedUserChanUncheckedUpdateManyWithoutChanNestedInput = {
    create?: XOR<Enumerable<MutedUserChanCreateWithoutChanInput>, Enumerable<MutedUserChanUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<MutedUserChanCreateOrConnectWithoutChanInput>
    upsert?: Enumerable<MutedUserChanUpsertWithWhereUniqueWithoutChanInput>
    createMany?: MutedUserChanCreateManyChanInputEnvelope
    set?: Enumerable<MutedUserChanWhereUniqueInput>
    disconnect?: Enumerable<MutedUserChanWhereUniqueInput>
    delete?: Enumerable<MutedUserChanWhereUniqueInput>
    connect?: Enumerable<MutedUserChanWhereUniqueInput>
    update?: Enumerable<MutedUserChanUpdateWithWhereUniqueWithoutChanInput>
    updateMany?: Enumerable<MutedUserChanUpdateManyWithWhereWithoutChanInput>
    deleteMany?: Enumerable<MutedUserChanScalarWhereInput>
  }

  export type ChanInvitationUncheckedUpdateManyWithoutChanNestedInput = {
    create?: XOR<Enumerable<ChanInvitationCreateWithoutChanInput>, Enumerable<ChanInvitationUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<ChanInvitationCreateOrConnectWithoutChanInput>
    upsert?: Enumerable<ChanInvitationUpsertWithWhereUniqueWithoutChanInput>
    createMany?: ChanInvitationCreateManyChanInputEnvelope
    set?: Enumerable<ChanInvitationWhereUniqueInput>
    disconnect?: Enumerable<ChanInvitationWhereUniqueInput>
    delete?: Enumerable<ChanInvitationWhereUniqueInput>
    connect?: Enumerable<ChanInvitationWhereUniqueInput>
    update?: Enumerable<ChanInvitationUpdateWithWhereUniqueWithoutChanInput>
    updateMany?: Enumerable<ChanInvitationUpdateManyWithWhereWithoutChanInput>
    deleteMany?: Enumerable<ChanInvitationScalarWhereInput>
  }

  export type ChanDiscussionElementUncheckedUpdateManyWithoutChanNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionElementCreateWithoutChanInput>, Enumerable<ChanDiscussionElementUncheckedCreateWithoutChanInput>>
    connectOrCreate?: Enumerable<ChanDiscussionElementCreateOrConnectWithoutChanInput>
    upsert?: Enumerable<ChanDiscussionElementUpsertWithWhereUniqueWithoutChanInput>
    createMany?: ChanDiscussionElementCreateManyChanInputEnvelope
    set?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionElementWhereUniqueInput>
    update?: Enumerable<ChanDiscussionElementUpdateWithWhereUniqueWithoutChanInput>
    updateMany?: Enumerable<ChanDiscussionElementUpdateManyWithWhereWithoutChanInput>
    deleteMany?: Enumerable<ChanDiscussionElementScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutMutedUserChanInput = {
    create?: XOR<UserCreateWithoutMutedUserChanInput, UserUncheckedCreateWithoutMutedUserChanInput>
    connectOrCreate?: UserCreateOrConnectWithoutMutedUserChanInput
    connect?: UserWhereUniqueInput
  }

  export type ChanCreateNestedOneWithoutMutedUsersInput = {
    create?: XOR<ChanCreateWithoutMutedUsersInput, ChanUncheckedCreateWithoutMutedUsersInput>
    connectOrCreate?: ChanCreateOrConnectWithoutMutedUsersInput
    connect?: ChanWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMutedUserChanNestedInput = {
    create?: XOR<UserCreateWithoutMutedUserChanInput, UserUncheckedCreateWithoutMutedUserChanInput>
    connectOrCreate?: UserCreateOrConnectWithoutMutedUserChanInput
    upsert?: UserUpsertWithoutMutedUserChanInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMutedUserChanInput, UserUpdateWithoutMutedUserChanInput>, UserUncheckedUpdateWithoutMutedUserChanInput>
  }

  export type ChanUpdateOneRequiredWithoutMutedUsersNestedInput = {
    create?: XOR<ChanCreateWithoutMutedUsersInput, ChanUncheckedCreateWithoutMutedUsersInput>
    connectOrCreate?: ChanCreateOrConnectWithoutMutedUsersInput
    upsert?: ChanUpsertWithoutMutedUsersInput
    connect?: ChanWhereUniqueInput
    update?: XOR<XOR<ChanUpdateToOneWithWhereWithoutMutedUsersInput, ChanUpdateWithoutMutedUsersInput>, ChanUncheckedUpdateWithoutMutedUsersInput>
  }

  export type ChanDiscussionMessageCreateNestedOneWithoutDiscussionElementInput = {
    create?: XOR<ChanDiscussionMessageCreateWithoutDiscussionElementInput, ChanDiscussionMessageUncheckedCreateWithoutDiscussionElementInput>
    connectOrCreate?: ChanDiscussionMessageCreateOrConnectWithoutDiscussionElementInput
    connect?: ChanDiscussionMessageWhereUniqueInput
  }

  export type ChanDiscussionEventCreateNestedOneWithoutDiscussionElementInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutDiscussionElementInput, ChanDiscussionEventUncheckedCreateWithoutDiscussionElementInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutDiscussionElementInput
    connect?: ChanDiscussionEventWhereUniqueInput
  }

  export type ChanDiscussionMessageCreateNestedManyWithoutRelatedInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedInput>
    createMany?: ChanDiscussionMessageCreateManyRelatedInputEnvelope
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutChanDiscussionElementInput = {
    create?: XOR<UserCreateWithoutChanDiscussionElementInput, UserUncheckedCreateWithoutChanDiscussionElementInput>
    connectOrCreate?: UserCreateOrConnectWithoutChanDiscussionElementInput
    connect?: UserWhereUniqueInput
  }

  export type ChanCreateNestedOneWithoutElementsInput = {
    create?: XOR<ChanCreateWithoutElementsInput, ChanUncheckedCreateWithoutElementsInput>
    connectOrCreate?: ChanCreateOrConnectWithoutElementsInput
    connect?: ChanWhereUniqueInput
  }

  export type ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedInput>
    createMany?: ChanDiscussionMessageCreateManyRelatedInputEnvelope
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
  }

  export type ChanDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput = {
    create?: XOR<ChanDiscussionMessageCreateWithoutDiscussionElementInput, ChanDiscussionMessageUncheckedCreateWithoutDiscussionElementInput>
    connectOrCreate?: ChanDiscussionMessageCreateOrConnectWithoutDiscussionElementInput
    upsert?: ChanDiscussionMessageUpsertWithoutDiscussionElementInput
    disconnect?: ChanDiscussionMessageWhereInput | boolean
    delete?: ChanDiscussionMessageWhereInput | boolean
    connect?: ChanDiscussionMessageWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionMessageUpdateToOneWithWhereWithoutDiscussionElementInput, ChanDiscussionMessageUpdateWithoutDiscussionElementInput>, ChanDiscussionMessageUncheckedUpdateWithoutDiscussionElementInput>
  }

  export type ChanDiscussionEventUpdateOneWithoutDiscussionElementNestedInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutDiscussionElementInput, ChanDiscussionEventUncheckedCreateWithoutDiscussionElementInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutDiscussionElementInput
    upsert?: ChanDiscussionEventUpsertWithoutDiscussionElementInput
    disconnect?: ChanDiscussionEventWhereInput | boolean
    delete?: ChanDiscussionEventWhereInput | boolean
    connect?: ChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionEventUpdateToOneWithWhereWithoutDiscussionElementInput, ChanDiscussionEventUpdateWithoutDiscussionElementInput>, ChanDiscussionEventUncheckedUpdateWithoutDiscussionElementInput>
  }

  export type ChanDiscussionMessageUpdateManyWithoutRelatedNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedInput>
    upsert?: Enumerable<ChanDiscussionMessageUpsertWithWhereUniqueWithoutRelatedInput>
    createMany?: ChanDiscussionMessageCreateManyRelatedInputEnvelope
    set?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    update?: Enumerable<ChanDiscussionMessageUpdateWithWhereUniqueWithoutRelatedInput>
    updateMany?: Enumerable<ChanDiscussionMessageUpdateManyWithWhereWithoutRelatedInput>
    deleteMany?: Enumerable<ChanDiscussionMessageScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutChanDiscussionElementNestedInput = {
    create?: XOR<UserCreateWithoutChanDiscussionElementInput, UserUncheckedCreateWithoutChanDiscussionElementInput>
    connectOrCreate?: UserCreateOrConnectWithoutChanDiscussionElementInput
    upsert?: UserUpsertWithoutChanDiscussionElementInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChanDiscussionElementInput, UserUpdateWithoutChanDiscussionElementInput>, UserUncheckedUpdateWithoutChanDiscussionElementInput>
  }

  export type ChanUpdateOneRequiredWithoutElementsNestedInput = {
    create?: XOR<ChanCreateWithoutElementsInput, ChanUncheckedCreateWithoutElementsInput>
    connectOrCreate?: ChanCreateOrConnectWithoutElementsInput
    upsert?: ChanUpsertWithoutElementsInput
    connect?: ChanWhereUniqueInput
    update?: XOR<XOR<ChanUpdateToOneWithWhereWithoutElementsInput, ChanUpdateWithoutElementsInput>, ChanUncheckedUpdateWithoutElementsInput>
  }

  export type ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput = {
    create?: XOR<Enumerable<ChanDiscussionMessageCreateWithoutRelatedInput>, Enumerable<ChanDiscussionMessageUncheckedCreateWithoutRelatedInput>>
    connectOrCreate?: Enumerable<ChanDiscussionMessageCreateOrConnectWithoutRelatedInput>
    upsert?: Enumerable<ChanDiscussionMessageUpsertWithWhereUniqueWithoutRelatedInput>
    createMany?: ChanDiscussionMessageCreateManyRelatedInputEnvelope
    set?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    disconnect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    delete?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    connect?: Enumerable<ChanDiscussionMessageWhereUniqueInput>
    update?: Enumerable<ChanDiscussionMessageUpdateWithWhereUniqueWithoutRelatedInput>
    updateMany?: Enumerable<ChanDiscussionMessageUpdateManyWithWhereWithoutRelatedInput>
    deleteMany?: Enumerable<ChanDiscussionMessageScalarWhereInput>
  }

  export type UserCreateNestedManyWithoutChanDiscussionMessageInput = {
    create?: XOR<Enumerable<UserCreateWithoutChanDiscussionMessageInput>, Enumerable<UserUncheckedCreateWithoutChanDiscussionMessageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutChanDiscussionMessageInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type RoleCreateNestedManyWithoutRelatedDiscussionMessageInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRelatedDiscussionMessageInput>, Enumerable<RoleUncheckedCreateWithoutRelatedDiscussionMessageInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRelatedDiscussionMessageInput>
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type ChanDiscussionElementCreateNestedOneWithoutRelatedOfInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutRelatedOfInput, ChanDiscussionElementUncheckedCreateWithoutRelatedOfInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutRelatedOfInput
    connect?: ChanDiscussionElementWhereUniqueInput
  }

  export type ChanDiscussionElementCreateNestedOneWithoutMessageInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutMessageInput, ChanDiscussionElementUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutMessageInput
    connect?: ChanDiscussionElementWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutChanDiscussionMessageInput = {
    create?: XOR<Enumerable<UserCreateWithoutChanDiscussionMessageInput>, Enumerable<UserUncheckedCreateWithoutChanDiscussionMessageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutChanDiscussionMessageInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedManyWithoutRelatedDiscussionMessageInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRelatedDiscussionMessageInput>, Enumerable<RoleUncheckedCreateWithoutRelatedDiscussionMessageInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRelatedDiscussionMessageInput>
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type ChanDiscussionElementUncheckedCreateNestedOneWithoutMessageInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutMessageInput, ChanDiscussionElementUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutMessageInput
    connect?: ChanDiscussionElementWhereUniqueInput
  }

  export type UserUpdateManyWithoutChanDiscussionMessageNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutChanDiscussionMessageInput>, Enumerable<UserUncheckedCreateWithoutChanDiscussionMessageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutChanDiscussionMessageInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutChanDiscussionMessageInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutChanDiscussionMessageInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutChanDiscussionMessageInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type RoleUpdateManyWithoutRelatedDiscussionMessageNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRelatedDiscussionMessageInput>, Enumerable<RoleUncheckedCreateWithoutRelatedDiscussionMessageInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRelatedDiscussionMessageInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutRelatedDiscussionMessageInput>
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutRelatedDiscussionMessageInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutRelatedDiscussionMessageInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type ChanDiscussionElementUpdateOneWithoutRelatedOfNestedInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutRelatedOfInput, ChanDiscussionElementUncheckedCreateWithoutRelatedOfInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutRelatedOfInput
    upsert?: ChanDiscussionElementUpsertWithoutRelatedOfInput
    disconnect?: ChanDiscussionElementWhereInput | boolean
    delete?: ChanDiscussionElementWhereInput | boolean
    connect?: ChanDiscussionElementWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionElementUpdateToOneWithWhereWithoutRelatedOfInput, ChanDiscussionElementUpdateWithoutRelatedOfInput>, ChanDiscussionElementUncheckedUpdateWithoutRelatedOfInput>
  }

  export type ChanDiscussionElementUpdateOneWithoutMessageNestedInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutMessageInput, ChanDiscussionElementUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutMessageInput
    upsert?: ChanDiscussionElementUpsertWithoutMessageInput
    disconnect?: ChanDiscussionElementWhereInput | boolean
    delete?: ChanDiscussionElementWhereInput | boolean
    connect?: ChanDiscussionElementWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionElementUpdateToOneWithWhereWithoutMessageInput, ChanDiscussionElementUpdateWithoutMessageInput>, ChanDiscussionElementUncheckedUpdateWithoutMessageInput>
  }

  export type UserUncheckedUpdateManyWithoutChanDiscussionMessageNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutChanDiscussionMessageInput>, Enumerable<UserUncheckedCreateWithoutChanDiscussionMessageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutChanDiscussionMessageInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutChanDiscussionMessageInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutChanDiscussionMessageInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutChanDiscussionMessageInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type RoleUncheckedUpdateManyWithoutRelatedDiscussionMessageNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutRelatedDiscussionMessageInput>, Enumerable<RoleUncheckedCreateWithoutRelatedDiscussionMessageInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutRelatedDiscussionMessageInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutRelatedDiscussionMessageInput>
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutRelatedDiscussionMessageInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutRelatedDiscussionMessageInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type ChanDiscussionElementUncheckedUpdateOneWithoutMessageNestedInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutMessageInput, ChanDiscussionElementUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutMessageInput
    upsert?: ChanDiscussionElementUpsertWithoutMessageInput
    disconnect?: ChanDiscussionElementWhereInput | boolean
    delete?: ChanDiscussionElementWhereInput | boolean
    connect?: ChanDiscussionElementWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionElementUpdateToOneWithWhereWithoutMessageInput, ChanDiscussionElementUpdateWithoutMessageInput>, ChanDiscussionElementUncheckedUpdateWithoutMessageInput>
  }

  export type UserCreateNestedOneWithoutChanDiscussionEventInput = {
    create?: XOR<UserCreateWithoutChanDiscussionEventInput, UserUncheckedCreateWithoutChanDiscussionEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutChanDiscussionEventInput
    connect?: UserWhereUniqueInput
  }

  export type ClassicChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput = {
    create?: XOR<ClassicChanDiscussionEventCreateWithoutChanDiscussionEventInput, ClassicChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
    connectOrCreate?: ClassicChanDiscussionEventCreateOrConnectWithoutChanDiscussionEventInput
    connect?: ClassicChanDiscussionEventWhereUniqueInput
  }

  export type ChangedTitleChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput = {
    create?: XOR<ChangedTitleChanDiscussionEventCreateWithoutChanDiscussionEventInput, ChangedTitleChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
    connectOrCreate?: ChangedTitleChanDiscussionEventCreateOrConnectWithoutChanDiscussionEventInput
    connect?: ChangedTitleChanDiscussionEventWhereUniqueInput
  }

  export type DeletedMessageChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput = {
    create?: XOR<DeletedMessageChanDiscussionEventCreateWithoutChanDiscussionEventInput, DeletedMessageChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
    connectOrCreate?: DeletedMessageChanDiscussionEventCreateOrConnectWithoutChanDiscussionEventInput
    connect?: DeletedMessageChanDiscussionEventWhereUniqueInput
  }

  export type ChanDiscussionElementCreateNestedOneWithoutEventInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutEventInput, ChanDiscussionElementUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutEventInput
    connect?: ChanDiscussionElementWhereUniqueInput
  }

  export type ChanDiscussionElementUncheckedCreateNestedOneWithoutEventInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutEventInput, ChanDiscussionElementUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutEventInput
    connect?: ChanDiscussionElementWhereUniqueInput
  }

  export type UserUpdateOneWithoutChanDiscussionEventNestedInput = {
    create?: XOR<UserCreateWithoutChanDiscussionEventInput, UserUncheckedCreateWithoutChanDiscussionEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutChanDiscussionEventInput
    upsert?: UserUpsertWithoutChanDiscussionEventInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChanDiscussionEventInput, UserUpdateWithoutChanDiscussionEventInput>, UserUncheckedUpdateWithoutChanDiscussionEventInput>
  }

  export type ClassicChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput = {
    create?: XOR<ClassicChanDiscussionEventCreateWithoutChanDiscussionEventInput, ClassicChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
    connectOrCreate?: ClassicChanDiscussionEventCreateOrConnectWithoutChanDiscussionEventInput
    upsert?: ClassicChanDiscussionEventUpsertWithoutChanDiscussionEventInput
    disconnect?: ClassicChanDiscussionEventWhereInput | boolean
    delete?: ClassicChanDiscussionEventWhereInput | boolean
    connect?: ClassicChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ClassicChanDiscussionEventUpdateToOneWithWhereWithoutChanDiscussionEventInput, ClassicChanDiscussionEventUpdateWithoutChanDiscussionEventInput>, ClassicChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput>
  }

  export type ChangedTitleChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput = {
    create?: XOR<ChangedTitleChanDiscussionEventCreateWithoutChanDiscussionEventInput, ChangedTitleChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
    connectOrCreate?: ChangedTitleChanDiscussionEventCreateOrConnectWithoutChanDiscussionEventInput
    upsert?: ChangedTitleChanDiscussionEventUpsertWithoutChanDiscussionEventInput
    disconnect?: ChangedTitleChanDiscussionEventWhereInput | boolean
    delete?: ChangedTitleChanDiscussionEventWhereInput | boolean
    connect?: ChangedTitleChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChangedTitleChanDiscussionEventUpdateToOneWithWhereWithoutChanDiscussionEventInput, ChangedTitleChanDiscussionEventUpdateWithoutChanDiscussionEventInput>, ChangedTitleChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput>
  }

  export type DeletedMessageChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput = {
    create?: XOR<DeletedMessageChanDiscussionEventCreateWithoutChanDiscussionEventInput, DeletedMessageChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
    connectOrCreate?: DeletedMessageChanDiscussionEventCreateOrConnectWithoutChanDiscussionEventInput
    upsert?: DeletedMessageChanDiscussionEventUpsertWithoutChanDiscussionEventInput
    disconnect?: DeletedMessageChanDiscussionEventWhereInput | boolean
    delete?: DeletedMessageChanDiscussionEventWhereInput | boolean
    connect?: DeletedMessageChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<DeletedMessageChanDiscussionEventUpdateToOneWithWhereWithoutChanDiscussionEventInput, DeletedMessageChanDiscussionEventUpdateWithoutChanDiscussionEventInput>, DeletedMessageChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput>
  }

  export type ChanDiscussionElementUpdateOneWithoutEventNestedInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutEventInput, ChanDiscussionElementUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutEventInput
    upsert?: ChanDiscussionElementUpsertWithoutEventInput
    disconnect?: ChanDiscussionElementWhereInput | boolean
    delete?: ChanDiscussionElementWhereInput | boolean
    connect?: ChanDiscussionElementWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionElementUpdateToOneWithWhereWithoutEventInput, ChanDiscussionElementUpdateWithoutEventInput>, ChanDiscussionElementUncheckedUpdateWithoutEventInput>
  }

  export type ChanDiscussionElementUncheckedUpdateOneWithoutEventNestedInput = {
    create?: XOR<ChanDiscussionElementCreateWithoutEventInput, ChanDiscussionElementUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChanDiscussionElementCreateOrConnectWithoutEventInput
    upsert?: ChanDiscussionElementUpsertWithoutEventInput
    disconnect?: ChanDiscussionElementWhereInput | boolean
    delete?: ChanDiscussionElementWhereInput | boolean
    connect?: ChanDiscussionElementWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionElementUpdateToOneWithWhereWithoutEventInput, ChanDiscussionElementUpdateWithoutEventInput>, ChanDiscussionElementUncheckedUpdateWithoutEventInput>
  }

  export type ChanDiscussionEventCreateNestedOneWithoutChangedTitleChanDiscussionEventInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutChangedTitleChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutChangedTitleChanDiscussionEventInput
    connect?: ChanDiscussionEventWhereUniqueInput
  }

  export type ChanDiscussionEventUncheckedCreateNestedOneWithoutChangedTitleChanDiscussionEventInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutChangedTitleChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutChangedTitleChanDiscussionEventInput
    connect?: ChanDiscussionEventWhereUniqueInput
  }

  export type ChanDiscussionEventUpdateOneWithoutChangedTitleChanDiscussionEventNestedInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutChangedTitleChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutChangedTitleChanDiscussionEventInput
    upsert?: ChanDiscussionEventUpsertWithoutChangedTitleChanDiscussionEventInput
    disconnect?: ChanDiscussionEventWhereInput | boolean
    delete?: ChanDiscussionEventWhereInput | boolean
    connect?: ChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionEventUpdateToOneWithWhereWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUpdateWithoutChangedTitleChanDiscussionEventInput>, ChanDiscussionEventUncheckedUpdateWithoutChangedTitleChanDiscussionEventInput>
  }

  export type ChanDiscussionEventUncheckedUpdateOneWithoutChangedTitleChanDiscussionEventNestedInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutChangedTitleChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutChangedTitleChanDiscussionEventInput
    upsert?: ChanDiscussionEventUpsertWithoutChangedTitleChanDiscussionEventInput
    disconnect?: ChanDiscussionEventWhereInput | boolean
    delete?: ChanDiscussionEventWhereInput | boolean
    connect?: ChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionEventUpdateToOneWithWhereWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUpdateWithoutChangedTitleChanDiscussionEventInput>, ChanDiscussionEventUncheckedUpdateWithoutChangedTitleChanDiscussionEventInput>
  }

  export type UserCreateNestedOneWithoutDeletedMessageChanDiscussionEventInput = {
    create?: XOR<UserCreateWithoutDeletedMessageChanDiscussionEventInput, UserUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedMessageChanDiscussionEventInput
    connect?: UserWhereUniqueInput
  }

  export type ChanDiscussionEventCreateNestedOneWithoutDeletedMessageChanDiscussionEventInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutDeletedMessageChanDiscussionEventInput
    connect?: ChanDiscussionEventWhereUniqueInput
  }

  export type ChanDiscussionEventUncheckedCreateNestedOneWithoutDeletedMessageChanDiscussionEventInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutDeletedMessageChanDiscussionEventInput
    connect?: ChanDiscussionEventWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeletedMessageChanDiscussionEventNestedInput = {
    create?: XOR<UserCreateWithoutDeletedMessageChanDiscussionEventInput, UserUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedMessageChanDiscussionEventInput
    upsert?: UserUpsertWithoutDeletedMessageChanDiscussionEventInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeletedMessageChanDiscussionEventInput, UserUpdateWithoutDeletedMessageChanDiscussionEventInput>, UserUncheckedUpdateWithoutDeletedMessageChanDiscussionEventInput>
  }

  export type ChanDiscussionEventUpdateOneWithoutDeletedMessageChanDiscussionEventNestedInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutDeletedMessageChanDiscussionEventInput
    upsert?: ChanDiscussionEventUpsertWithoutDeletedMessageChanDiscussionEventInput
    disconnect?: ChanDiscussionEventWhereInput | boolean
    delete?: ChanDiscussionEventWhereInput | boolean
    connect?: ChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionEventUpdateToOneWithWhereWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUpdateWithoutDeletedMessageChanDiscussionEventInput>, ChanDiscussionEventUncheckedUpdateWithoutDeletedMessageChanDiscussionEventInput>
  }

  export type ChanDiscussionEventUncheckedUpdateOneWithoutDeletedMessageChanDiscussionEventNestedInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutDeletedMessageChanDiscussionEventInput
    upsert?: ChanDiscussionEventUpsertWithoutDeletedMessageChanDiscussionEventInput
    disconnect?: ChanDiscussionEventWhereInput | boolean
    delete?: ChanDiscussionEventWhereInput | boolean
    connect?: ChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionEventUpdateToOneWithWhereWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUpdateWithoutDeletedMessageChanDiscussionEventInput>, ChanDiscussionEventUncheckedUpdateWithoutDeletedMessageChanDiscussionEventInput>
  }

  export type ChanDiscussionEventCreateNestedOneWithoutClassicChanDiscussionEventInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutClassicChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutClassicChanDiscussionEventInput
    connect?: ChanDiscussionEventWhereUniqueInput
  }

  export type ChanDiscussionEventUncheckedCreateNestedOneWithoutClassicChanDiscussionEventInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutClassicChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutClassicChanDiscussionEventInput
    connect?: ChanDiscussionEventWhereUniqueInput
  }

  export type EnumClassicChanEventTypeFieldUpdateOperationsInput = {
    set?: ClassicChanEventType
  }

  export type ChanDiscussionEventUpdateOneWithoutClassicChanDiscussionEventNestedInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutClassicChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutClassicChanDiscussionEventInput
    upsert?: ChanDiscussionEventUpsertWithoutClassicChanDiscussionEventInput
    disconnect?: ChanDiscussionEventWhereInput | boolean
    delete?: ChanDiscussionEventWhereInput | boolean
    connect?: ChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionEventUpdateToOneWithWhereWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUpdateWithoutClassicChanDiscussionEventInput>, ChanDiscussionEventUncheckedUpdateWithoutClassicChanDiscussionEventInput>
  }

  export type ChanDiscussionEventUncheckedUpdateOneWithoutClassicChanDiscussionEventNestedInput = {
    create?: XOR<ChanDiscussionEventCreateWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutClassicChanDiscussionEventInput>
    connectOrCreate?: ChanDiscussionEventCreateOrConnectWithoutClassicChanDiscussionEventInput
    upsert?: ChanDiscussionEventUpsertWithoutClassicChanDiscussionEventInput
    disconnect?: ChanDiscussionEventWhereInput | boolean
    delete?: ChanDiscussionEventWhereInput | boolean
    connect?: ChanDiscussionEventWhereUniqueInput
    update?: XOR<XOR<ChanDiscussionEventUpdateToOneWithWhereWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUpdateWithoutClassicChanDiscussionEventInput>, ChanDiscussionEventUncheckedUpdateWithoutClassicChanDiscussionEventInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumRoleApplyingTypeFilter = {
    equals?: RoleApplyingType
    in?: Enumerable<RoleApplyingType>
    notIn?: Enumerable<RoleApplyingType>
    not?: NestedEnumRoleApplyingTypeFilter | RoleApplyingType
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedEnumRoleApplyingTypeWithAggregatesFilter = {
    equals?: RoleApplyingType
    in?: Enumerable<RoleApplyingType>
    notIn?: Enumerable<RoleApplyingType>
    not?: NestedEnumRoleApplyingTypeWithAggregatesFilter | RoleApplyingType
    _count?: NestedIntFilter
    _min?: NestedEnumRoleApplyingTypeFilter
    _max?: NestedEnumRoleApplyingTypeFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumFriendInvitationStatusFilter = {
    equals?: FriendInvitationStatus
    in?: Enumerable<FriendInvitationStatus>
    notIn?: Enumerable<FriendInvitationStatus>
    not?: NestedEnumFriendInvitationStatusFilter | FriendInvitationStatus
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumFriendInvitationStatusWithAggregatesFilter = {
    equals?: FriendInvitationStatus
    in?: Enumerable<FriendInvitationStatus>
    notIn?: Enumerable<FriendInvitationStatus>
    not?: NestedEnumFriendInvitationStatusWithAggregatesFilter | FriendInvitationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumFriendInvitationStatusFilter
    _max?: NestedEnumFriendInvitationStatusFilter
  }

  export type NestedEnumChanInvitationStatusFilter = {
    equals?: ChanInvitationStatus
    in?: Enumerable<ChanInvitationStatus>
    notIn?: Enumerable<ChanInvitationStatus>
    not?: NestedEnumChanInvitationStatusFilter | ChanInvitationStatus
  }

  export type NestedEnumChanInvitationStatusWithAggregatesFilter = {
    equals?: ChanInvitationStatus
    in?: Enumerable<ChanInvitationStatus>
    notIn?: Enumerable<ChanInvitationStatus>
    not?: NestedEnumChanInvitationStatusWithAggregatesFilter | ChanInvitationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumChanInvitationStatusFilter
    _max?: NestedEnumChanInvitationStatusFilter
  }

  export type NestedEnumdmPolicyLevelTypeFilter = {
    equals?: dmPolicyLevelType
    in?: Enumerable<dmPolicyLevelType>
    notIn?: Enumerable<dmPolicyLevelType>
    not?: NestedEnumdmPolicyLevelTypeFilter | dmPolicyLevelType
  }

  export type NestedEnumdmPolicyLevelTypeWithAggregatesFilter = {
    equals?: dmPolicyLevelType
    in?: Enumerable<dmPolicyLevelType>
    notIn?: Enumerable<dmPolicyLevelType>
    not?: NestedEnumdmPolicyLevelTypeWithAggregatesFilter | dmPolicyLevelType
    _count?: NestedIntFilter
    _min?: NestedEnumdmPolicyLevelTypeFilter
    _max?: NestedEnumdmPolicyLevelTypeFilter
  }

  export type NestedEnumDirectMessageUserStatusFilter = {
    equals?: DirectMessageUserStatus
    in?: Enumerable<DirectMessageUserStatus>
    notIn?: Enumerable<DirectMessageUserStatus>
    not?: NestedEnumDirectMessageUserStatusFilter | DirectMessageUserStatus
  }

  export type NestedEnumDirectMessageStatusFilter = {
    equals?: DirectMessageStatus
    in?: Enumerable<DirectMessageStatus>
    notIn?: Enumerable<DirectMessageStatus>
    not?: NestedEnumDirectMessageStatusFilter | DirectMessageStatus
  }

  export type NestedEnumDirectMessageUserStatusWithAggregatesFilter = {
    equals?: DirectMessageUserStatus
    in?: Enumerable<DirectMessageUserStatus>
    notIn?: Enumerable<DirectMessageUserStatus>
    not?: NestedEnumDirectMessageUserStatusWithAggregatesFilter | DirectMessageUserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumDirectMessageUserStatusFilter
    _max?: NestedEnumDirectMessageUserStatusFilter
  }

  export type NestedEnumDirectMessageStatusWithAggregatesFilter = {
    equals?: DirectMessageStatus
    in?: Enumerable<DirectMessageStatus>
    notIn?: Enumerable<DirectMessageStatus>
    not?: NestedEnumDirectMessageStatusWithAggregatesFilter | DirectMessageStatus
    _count?: NestedIntFilter
    _min?: NestedEnumDirectMessageStatusFilter
    _max?: NestedEnumDirectMessageStatusFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumClassicDmEventTypeFilter = {
    equals?: ClassicDmEventType
    in?: Enumerable<ClassicDmEventType>
    notIn?: Enumerable<ClassicDmEventType>
    not?: NestedEnumClassicDmEventTypeFilter | ClassicDmEventType
  }

  export type NestedEnumClassicDmEventTypeWithAggregatesFilter = {
    equals?: ClassicDmEventType
    in?: Enumerable<ClassicDmEventType>
    notIn?: Enumerable<ClassicDmEventType>
    not?: NestedEnumClassicDmEventTypeWithAggregatesFilter | ClassicDmEventType
    _count?: NestedIntFilter
    _min?: NestedEnumClassicDmEventTypeFilter
    _max?: NestedEnumClassicDmEventTypeFilter
  }

  export type NestedEnumChanTypeFilter = {
    equals?: ChanType
    in?: Enumerable<ChanType>
    notIn?: Enumerable<ChanType>
    not?: NestedEnumChanTypeFilter | ChanType
  }

  export type NestedEnumChanTypeWithAggregatesFilter = {
    equals?: ChanType
    in?: Enumerable<ChanType>
    notIn?: Enumerable<ChanType>
    not?: NestedEnumChanTypeWithAggregatesFilter | ChanType
    _count?: NestedIntFilter
    _min?: NestedEnumChanTypeFilter
    _max?: NestedEnumChanTypeFilter
  }

  export type NestedEnumClassicChanEventTypeFilter = {
    equals?: ClassicChanEventType
    in?: Enumerable<ClassicChanEventType>
    notIn?: Enumerable<ClassicChanEventType>
    not?: NestedEnumClassicChanEventTypeFilter | ClassicChanEventType
  }

  export type NestedEnumClassicChanEventTypeWithAggregatesFilter = {
    equals?: ClassicChanEventType
    in?: Enumerable<ClassicChanEventType>
    notIn?: Enumerable<ClassicChanEventType>
    not?: NestedEnumClassicChanEventTypeWithAggregatesFilter | ClassicChanEventType
    _count?: NestedIntFilter
    _min?: NestedEnumClassicChanEventTypeFilter
    _max?: NestedEnumClassicChanEventTypeFilter
  }

  export type RoleCreateWithoutRolesSymInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    roles?: RoleCreateNestedManyWithoutRolesSymInput
    users?: UserCreateNestedManyWithoutRolesInput
    chan: ChanCreateNestedOneWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleUncheckedCreateWithoutRolesSymInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    chanId: string
    roles?: RoleUncheckedCreateNestedManyWithoutRolesSymInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleCreateOrConnectWithoutRolesSymInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolesSymInput, RoleUncheckedCreateWithoutRolesSymInput>
  }

  export type RoleCreateWithoutRolesInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    rolesSym?: RoleCreateNestedManyWithoutRolesInput
    users?: UserCreateNestedManyWithoutRolesInput
    chan: ChanCreateNestedOneWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    chanId: string
    rolesSym?: RoleUncheckedCreateNestedManyWithoutRolesInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleCreateOrConnectWithoutRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolesInput, RoleUncheckedCreateWithoutRolesInput>
  }

  export type UserCreateWithoutRolesInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type ChanCreateWithoutRolesInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    users?: UserCreateNestedManyWithoutChansInput
    owner: UserCreateNestedOneWithoutOwnedChansInput
    mutedUsers?: MutedUserChanCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementCreateNestedManyWithoutChanInput
  }

  export type ChanUncheckedCreateWithoutRolesInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    ownerName: string
    users?: UserUncheckedCreateNestedManyWithoutChansInput
    mutedUsers?: MutedUserChanUncheckedCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationUncheckedCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementUncheckedCreateNestedManyWithoutChanInput
  }

  export type ChanCreateOrConnectWithoutRolesInput = {
    where: ChanWhereUniqueInput
    create: XOR<ChanCreateWithoutRolesInput, ChanUncheckedCreateWithoutRolesInput>
  }

  export type ChanDiscussionMessageCreateWithoutRelatedRolesInput = {
    id?: string
    content: string
    relatedUsers?: UserCreateNestedManyWithoutChanDiscussionMessageInput
    related?: ChanDiscussionElementCreateNestedOneWithoutRelatedOfInput
    discussionElement?: ChanDiscussionElementCreateNestedOneWithoutMessageInput
  }

  export type ChanDiscussionMessageUncheckedCreateWithoutRelatedRolesInput = {
    id?: string
    content: string
    relatedTo?: string | null
    relatedUsers?: UserUncheckedCreateNestedManyWithoutChanDiscussionMessageInput
    discussionElement?: ChanDiscussionElementUncheckedCreateNestedOneWithoutMessageInput
  }

  export type ChanDiscussionMessageCreateOrConnectWithoutRelatedRolesInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    create: XOR<ChanDiscussionMessageCreateWithoutRelatedRolesInput, ChanDiscussionMessageUncheckedCreateWithoutRelatedRolesInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutRolesSymInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutRolesSymInput, RoleUncheckedUpdateWithoutRolesSymInput>
    create: XOR<RoleCreateWithoutRolesSymInput, RoleUncheckedCreateWithoutRolesSymInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutRolesSymInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutRolesSymInput, RoleUncheckedUpdateWithoutRolesSymInput>
  }

  export type RoleUpdateManyWithWhereWithoutRolesSymInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRolesInput>
  }

  export type RoleScalarWhereInput = {
    AND?: Enumerable<RoleScalarWhereInput>
    OR?: Enumerable<RoleScalarWhereInput>
    NOT?: Enumerable<RoleScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    permissions?: EnumPermissionListNullableListFilter
    roleApplyOn?: EnumRoleApplyingTypeFilter | RoleApplyingType
    chanId?: StringFilter | string
  }

  export type RoleUpsertWithWhereUniqueWithoutRolesInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutRolesInput, RoleUncheckedUpdateWithoutRolesInput>
    create: XOR<RoleCreateWithoutRolesInput, RoleUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutRolesInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutRolesInput, RoleUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateManyWithWhereWithoutRolesInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRolesSymInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateManyWithWhereWithoutRolesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    name?: StringFilter | string
    password?: StringFilter | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFilter | dmPolicyLevelType
  }

  export type ChanUpsertWithoutRolesInput = {
    update: XOR<ChanUpdateWithoutRolesInput, ChanUncheckedUpdateWithoutRolesInput>
    create: XOR<ChanCreateWithoutRolesInput, ChanUncheckedCreateWithoutRolesInput>
    where?: ChanWhereInput
  }

  export type ChanUpdateToOneWithWhereWithoutRolesInput = {
    where?: ChanWhereInput
    data: XOR<ChanUpdateWithoutRolesInput, ChanUncheckedUpdateWithoutRolesInput>
  }

  export type ChanUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutChansNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedChansNestedInput
    mutedUsers?: MutedUserChanUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUpdateManyWithoutChanNestedInput
  }

  export type ChanUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerName?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutChansNestedInput
    mutedUsers?: MutedUserChanUncheckedUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUncheckedUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUncheckedUpdateManyWithoutChanNestedInput
  }

  export type ChanDiscussionMessageUpsertWithWhereUniqueWithoutRelatedRolesInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    update: XOR<ChanDiscussionMessageUpdateWithoutRelatedRolesInput, ChanDiscussionMessageUncheckedUpdateWithoutRelatedRolesInput>
    create: XOR<ChanDiscussionMessageCreateWithoutRelatedRolesInput, ChanDiscussionMessageUncheckedCreateWithoutRelatedRolesInput>
  }

  export type ChanDiscussionMessageUpdateWithWhereUniqueWithoutRelatedRolesInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    data: XOR<ChanDiscussionMessageUpdateWithoutRelatedRolesInput, ChanDiscussionMessageUncheckedUpdateWithoutRelatedRolesInput>
  }

  export type ChanDiscussionMessageUpdateManyWithWhereWithoutRelatedRolesInput = {
    where: ChanDiscussionMessageScalarWhereInput
    data: XOR<ChanDiscussionMessageUpdateManyMutationInput, ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedDiscussionMessageInput>
  }

  export type ChanDiscussionMessageScalarWhereInput = {
    AND?: Enumerable<ChanDiscussionMessageScalarWhereInput>
    OR?: Enumerable<ChanDiscussionMessageScalarWhereInput>
    NOT?: Enumerable<ChanDiscussionMessageScalarWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    relatedTo?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutOutcomingFriendInvitationInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutOutcomingFriendInvitationInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutOutcomingFriendInvitationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOutcomingFriendInvitationInput, UserUncheckedCreateWithoutOutcomingFriendInvitationInput>
  }

  export type UserCreateWithoutIncomingFriendInvitationInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutIncomingFriendInvitationInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutIncomingFriendInvitationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIncomingFriendInvitationInput, UserUncheckedCreateWithoutIncomingFriendInvitationInput>
  }

  export type UserUpsertWithoutOutcomingFriendInvitationInput = {
    update: XOR<UserUpdateWithoutOutcomingFriendInvitationInput, UserUncheckedUpdateWithoutOutcomingFriendInvitationInput>
    create: XOR<UserCreateWithoutOutcomingFriendInvitationInput, UserUncheckedCreateWithoutOutcomingFriendInvitationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOutcomingFriendInvitationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOutcomingFriendInvitationInput, UserUncheckedUpdateWithoutOutcomingFriendInvitationInput>
  }

  export type UserUpdateWithoutOutcomingFriendInvitationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOutcomingFriendInvitationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUpsertWithoutIncomingFriendInvitationInput = {
    update: XOR<UserUpdateWithoutIncomingFriendInvitationInput, UserUncheckedUpdateWithoutIncomingFriendInvitationInput>
    create: XOR<UserCreateWithoutIncomingFriendInvitationInput, UserUncheckedCreateWithoutIncomingFriendInvitationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIncomingFriendInvitationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIncomingFriendInvitationInput, UserUncheckedUpdateWithoutIncomingFriendInvitationInput>
  }

  export type UserUpdateWithoutIncomingFriendInvitationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIncomingFriendInvitationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type ChanCreateWithoutInvitationsInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    users?: UserCreateNestedManyWithoutChansInput
    roles?: RoleCreateNestedManyWithoutChanInput
    owner: UserCreateNestedOneWithoutOwnedChansInput
    mutedUsers?: MutedUserChanCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementCreateNestedManyWithoutChanInput
  }

  export type ChanUncheckedCreateWithoutInvitationsInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    ownerName: string
    users?: UserUncheckedCreateNestedManyWithoutChansInput
    roles?: RoleUncheckedCreateNestedManyWithoutChanInput
    mutedUsers?: MutedUserChanUncheckedCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementUncheckedCreateNestedManyWithoutChanInput
  }

  export type ChanCreateOrConnectWithoutInvitationsInput = {
    where: ChanWhereUniqueInput
    create: XOR<ChanCreateWithoutInvitationsInput, ChanUncheckedCreateWithoutInvitationsInput>
  }

  export type ChanInvitationDmDiscussionEventCreateWithoutChanInvitationInput = {
    id?: string
    dmDiscussionEvent?: DmDiscussionEventCreateNestedOneWithoutChanInvitationDmDiscussionEventInput
  }

  export type ChanInvitationDmDiscussionEventUncheckedCreateWithoutChanInvitationInput = {
    id?: string
    dmDiscussionEvent?: DmDiscussionEventUncheckedCreateNestedOneWithoutChanInvitationDmDiscussionEventInput
  }

  export type ChanInvitationDmDiscussionEventCreateOrConnectWithoutChanInvitationInput = {
    where: ChanInvitationDmDiscussionEventWhereUniqueInput
    create: XOR<ChanInvitationDmDiscussionEventCreateWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutChanInvitationInput>
  }

  export type UserCreateWithoutOutcomingChanInvitationInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutOutcomingChanInvitationInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutOutcomingChanInvitationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOutcomingChanInvitationInput, UserUncheckedCreateWithoutOutcomingChanInvitationInput>
  }

  export type UserCreateWithoutIncomingChanInvitationInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutIncomingChanInvitationInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutIncomingChanInvitationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIncomingChanInvitationInput, UserUncheckedCreateWithoutIncomingChanInvitationInput>
  }

  export type ChanUpsertWithoutInvitationsInput = {
    update: XOR<ChanUpdateWithoutInvitationsInput, ChanUncheckedUpdateWithoutInvitationsInput>
    create: XOR<ChanCreateWithoutInvitationsInput, ChanUncheckedCreateWithoutInvitationsInput>
    where?: ChanWhereInput
  }

  export type ChanUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: ChanWhereInput
    data: XOR<ChanUpdateWithoutInvitationsInput, ChanUncheckedUpdateWithoutInvitationsInput>
  }

  export type ChanUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutChansNestedInput
    roles?: RoleUpdateManyWithoutChanNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedChansNestedInput
    mutedUsers?: MutedUserChanUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUpdateManyWithoutChanNestedInput
  }

  export type ChanUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerName?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutChansNestedInput
    roles?: RoleUncheckedUpdateManyWithoutChanNestedInput
    mutedUsers?: MutedUserChanUncheckedUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUncheckedUpdateManyWithoutChanNestedInput
  }

  export type ChanInvitationDmDiscussionEventUpsertWithoutChanInvitationInput = {
    update: XOR<ChanInvitationDmDiscussionEventUpdateWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUncheckedUpdateWithoutChanInvitationInput>
    create: XOR<ChanInvitationDmDiscussionEventCreateWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutChanInvitationInput>
    where?: ChanInvitationDmDiscussionEventWhereInput
  }

  export type ChanInvitationDmDiscussionEventUpdateToOneWithWhereWithoutChanInvitationInput = {
    where?: ChanInvitationDmDiscussionEventWhereInput
    data: XOR<ChanInvitationDmDiscussionEventUpdateWithoutChanInvitationInput, ChanInvitationDmDiscussionEventUncheckedUpdateWithoutChanInvitationInput>
  }

  export type ChanInvitationDmDiscussionEventUpdateWithoutChanInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dmDiscussionEvent?: DmDiscussionEventUpdateOneWithoutChanInvitationDmDiscussionEventNestedInput
  }

  export type ChanInvitationDmDiscussionEventUncheckedUpdateWithoutChanInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dmDiscussionEvent?: DmDiscussionEventUncheckedUpdateOneWithoutChanInvitationDmDiscussionEventNestedInput
  }

  export type UserUpsertWithoutOutcomingChanInvitationInput = {
    update: XOR<UserUpdateWithoutOutcomingChanInvitationInput, UserUncheckedUpdateWithoutOutcomingChanInvitationInput>
    create: XOR<UserCreateWithoutOutcomingChanInvitationInput, UserUncheckedCreateWithoutOutcomingChanInvitationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOutcomingChanInvitationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOutcomingChanInvitationInput, UserUncheckedUpdateWithoutOutcomingChanInvitationInput>
  }

  export type UserUpdateWithoutOutcomingChanInvitationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOutcomingChanInvitationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUpsertWithoutIncomingChanInvitationInput = {
    update: XOR<UserUpdateWithoutIncomingChanInvitationInput, UserUncheckedUpdateWithoutIncomingChanInvitationInput>
    create: XOR<UserCreateWithoutIncomingChanInvitationInput, UserUncheckedCreateWithoutIncomingChanInvitationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIncomingChanInvitationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIncomingChanInvitationInput, UserUncheckedUpdateWithoutIncomingChanInvitationInput>
  }

  export type UserUpdateWithoutIncomingChanInvitationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIncomingChanInvitationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserCreateWithoutFriendInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutFriendInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutFriendInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendInput, UserUncheckedCreateWithoutFriendInput>
  }

  export type UserCreateWithoutFriendOfInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutFriendOfInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutFriendOfInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendOfInput, UserUncheckedCreateWithoutFriendOfInput>
  }

  export type UserUpsertWithoutFriendInput = {
    update: XOR<UserUpdateWithoutFriendInput, UserUncheckedUpdateWithoutFriendInput>
    create: XOR<UserCreateWithoutFriendInput, UserUncheckedCreateWithoutFriendInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendInput, UserUncheckedUpdateWithoutFriendInput>
  }

  export type UserUpdateWithoutFriendInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUpsertWithoutFriendOfInput = {
    update: XOR<UserUpdateWithoutFriendOfInput, UserUncheckedUpdateWithoutFriendOfInput>
    create: XOR<UserCreateWithoutFriendOfInput, UserUncheckedCreateWithoutFriendOfInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendOfInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendOfInput, UserUncheckedUpdateWithoutFriendOfInput>
  }

  export type UserUpdateWithoutFriendOfInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendOfInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserCreateWithoutBlockedUserInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutBlockedUserInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutBlockedUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedUserInput, UserUncheckedCreateWithoutBlockedUserInput>
  }

  export type UserCreateWithoutBlockedByUserInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutBlockedByUserInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutBlockedByUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedByUserInput, UserUncheckedCreateWithoutBlockedByUserInput>
  }

  export type UserUpsertWithoutBlockedUserInput = {
    update: XOR<UserUpdateWithoutBlockedUserInput, UserUncheckedUpdateWithoutBlockedUserInput>
    create: XOR<UserCreateWithoutBlockedUserInput, UserUncheckedCreateWithoutBlockedUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedUserInput, UserUncheckedUpdateWithoutBlockedUserInput>
  }

  export type UserUpdateWithoutBlockedUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUpsertWithoutBlockedByUserInput = {
    update: XOR<UserUpdateWithoutBlockedByUserInput, UserUncheckedUpdateWithoutBlockedByUserInput>
    create: XOR<UserCreateWithoutBlockedByUserInput, UserUncheckedCreateWithoutBlockedByUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedByUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedByUserInput, UserUncheckedUpdateWithoutBlockedByUserInput>
  }

  export type UserUpdateWithoutBlockedByUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedByUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    roles?: RoleCreateNestedManyWithoutRolesSymInput
    rolesSym?: RoleCreateNestedManyWithoutRolesInput
    chan: ChanCreateNestedOneWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    chanId: string
    roles?: RoleUncheckedCreateNestedManyWithoutRolesSymInput
    rolesSym?: RoleUncheckedCreateNestedManyWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type DirectMessageCreateWithoutRequestingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
    requestedUser: UserCreateNestedOneWithoutDirectMessageOfInput
    elements?: DmDiscussionElementCreateNestedManyWithoutDirectMessageInput
  }

  export type DirectMessageUncheckedCreateWithoutRequestingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserName: string
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
    elements?: DmDiscussionElementUncheckedCreateNestedManyWithoutDirectMessageInput
  }

  export type DirectMessageCreateOrConnectWithoutRequestingUserInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutRequestingUserInput, DirectMessageUncheckedCreateWithoutRequestingUserInput>
  }

  export type DirectMessageCreateManyRequestingUserInputEnvelope = {
    data: Enumerable<DirectMessageCreateManyRequestingUserInput>
    skipDuplicates?: boolean
  }

  export type DirectMessageCreateWithoutRequestedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
    requestingUser: UserCreateNestedOneWithoutDirectMessageInput
    elements?: DmDiscussionElementCreateNestedManyWithoutDirectMessageInput
  }

  export type DirectMessageUncheckedCreateWithoutRequestedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserName: string
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
    elements?: DmDiscussionElementUncheckedCreateNestedManyWithoutDirectMessageInput
  }

  export type DirectMessageCreateOrConnectWithoutRequestedUserInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutRequestedUserInput, DirectMessageUncheckedCreateWithoutRequestedUserInput>
  }

  export type DirectMessageCreateManyRequestedUserInputEnvelope = {
    data: Enumerable<DirectMessageCreateManyRequestedUserInput>
    skipDuplicates?: boolean
  }

  export type ChanCreateWithoutUsersInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    roles?: RoleCreateNestedManyWithoutChanInput
    owner: UserCreateNestedOneWithoutOwnedChansInput
    mutedUsers?: MutedUserChanCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementCreateNestedManyWithoutChanInput
  }

  export type ChanUncheckedCreateWithoutUsersInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    ownerName: string
    roles?: RoleUncheckedCreateNestedManyWithoutChanInput
    mutedUsers?: MutedUserChanUncheckedCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationUncheckedCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementUncheckedCreateNestedManyWithoutChanInput
  }

  export type ChanCreateOrConnectWithoutUsersInput = {
    where: ChanWhereUniqueInput
    create: XOR<ChanCreateWithoutUsersInput, ChanUncheckedCreateWithoutUsersInput>
  }

  export type ChanCreateWithoutOwnerInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    users?: UserCreateNestedManyWithoutChansInput
    roles?: RoleCreateNestedManyWithoutChanInput
    mutedUsers?: MutedUserChanCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementCreateNestedManyWithoutChanInput
  }

  export type ChanUncheckedCreateWithoutOwnerInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutChansInput
    roles?: RoleUncheckedCreateNestedManyWithoutChanInput
    mutedUsers?: MutedUserChanUncheckedCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationUncheckedCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementUncheckedCreateNestedManyWithoutChanInput
  }

  export type ChanCreateOrConnectWithoutOwnerInput = {
    where: ChanWhereUniqueInput
    create: XOR<ChanCreateWithoutOwnerInput, ChanUncheckedCreateWithoutOwnerInput>
  }

  export type ChanCreateManyOwnerInputEnvelope = {
    data: Enumerable<ChanCreateManyOwnerInput>
    skipDuplicates?: boolean
  }

  export type FriendShipCreateWithoutRequestingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestedUser: UserCreateNestedOneWithoutFriendOfInput
  }

  export type FriendShipUncheckedCreateWithoutRequestingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestedUserName: string
  }

  export type FriendShipCreateOrConnectWithoutRequestingUserInput = {
    where: FriendShipWhereUniqueInput
    create: XOR<FriendShipCreateWithoutRequestingUserInput, FriendShipUncheckedCreateWithoutRequestingUserInput>
  }

  export type FriendShipCreateManyRequestingUserInputEnvelope = {
    data: Enumerable<FriendShipCreateManyRequestingUserInput>
    skipDuplicates?: boolean
  }

  export type FriendShipCreateWithoutRequestedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUser: UserCreateNestedOneWithoutFriendInput
  }

  export type FriendShipUncheckedCreateWithoutRequestedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserName: string
  }

  export type FriendShipCreateOrConnectWithoutRequestedUserInput = {
    where: FriendShipWhereUniqueInput
    create: XOR<FriendShipCreateWithoutRequestedUserInput, FriendShipUncheckedCreateWithoutRequestedUserInput>
  }

  export type FriendShipCreateManyRequestedUserInputEnvelope = {
    data: Enumerable<FriendShipCreateManyRequestedUserInput>
    skipDuplicates?: boolean
  }

  export type FriendInvitationCreateWithoutInvitingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    status?: FriendInvitationStatus
    invitedUser: UserCreateNestedOneWithoutIncomingFriendInvitationInput
  }

  export type FriendInvitationUncheckedCreateWithoutInvitingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    invitedUserName: string
    status?: FriendInvitationStatus
  }

  export type FriendInvitationCreateOrConnectWithoutInvitingUserInput = {
    where: FriendInvitationWhereUniqueInput
    create: XOR<FriendInvitationCreateWithoutInvitingUserInput, FriendInvitationUncheckedCreateWithoutInvitingUserInput>
  }

  export type FriendInvitationCreateManyInvitingUserInputEnvelope = {
    data: Enumerable<FriendInvitationCreateManyInvitingUserInput>
    skipDuplicates?: boolean
  }

  export type FriendInvitationCreateWithoutInvitedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    status?: FriendInvitationStatus
    invitingUser: UserCreateNestedOneWithoutOutcomingFriendInvitationInput
  }

  export type FriendInvitationUncheckedCreateWithoutInvitedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    invitingUserName: string
    status?: FriendInvitationStatus
  }

  export type FriendInvitationCreateOrConnectWithoutInvitedUserInput = {
    where: FriendInvitationWhereUniqueInput
    create: XOR<FriendInvitationCreateWithoutInvitedUserInput, FriendInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type FriendInvitationCreateManyInvitedUserInputEnvelope = {
    data: Enumerable<FriendInvitationCreateManyInvitedUserInput>
    skipDuplicates?: boolean
  }

  export type ChanInvitationCreateWithoutInvitingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    status?: ChanInvitationStatus
    chan: ChanCreateNestedOneWithoutInvitationsInput
    discussionEvent?: ChanInvitationDmDiscussionEventCreateNestedOneWithoutChanInvitationInput
    invitedUser: UserCreateNestedOneWithoutIncomingChanInvitationInput
  }

  export type ChanInvitationUncheckedCreateWithoutInvitingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    chanTitle: string
    invitedUserName: string
    status?: ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventUncheckedCreateNestedOneWithoutChanInvitationInput
  }

  export type ChanInvitationCreateOrConnectWithoutInvitingUserInput = {
    where: ChanInvitationWhereUniqueInput
    create: XOR<ChanInvitationCreateWithoutInvitingUserInput, ChanInvitationUncheckedCreateWithoutInvitingUserInput>
  }

  export type ChanInvitationCreateManyInvitingUserInputEnvelope = {
    data: Enumerable<ChanInvitationCreateManyInvitingUserInput>
    skipDuplicates?: boolean
  }

  export type ChanInvitationCreateWithoutInvitedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    status?: ChanInvitationStatus
    chan: ChanCreateNestedOneWithoutInvitationsInput
    discussionEvent?: ChanInvitationDmDiscussionEventCreateNestedOneWithoutChanInvitationInput
    invitingUser: UserCreateNestedOneWithoutOutcomingChanInvitationInput
  }

  export type ChanInvitationUncheckedCreateWithoutInvitedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    chanTitle: string
    invitingUserName: string
    status?: ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventUncheckedCreateNestedOneWithoutChanInvitationInput
  }

  export type ChanInvitationCreateOrConnectWithoutInvitedUserInput = {
    where: ChanInvitationWhereUniqueInput
    create: XOR<ChanInvitationCreateWithoutInvitedUserInput, ChanInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type ChanInvitationCreateManyInvitedUserInputEnvelope = {
    data: Enumerable<ChanInvitationCreateManyInvitedUserInput>
    skipDuplicates?: boolean
  }

  export type BlockedShipCreateWithoutBlockingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    blockedUser: UserCreateNestedOneWithoutBlockedByUserInput
  }

  export type BlockedShipUncheckedCreateWithoutBlockingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    blockedUserName: string
  }

  export type BlockedShipCreateOrConnectWithoutBlockingUserInput = {
    where: BlockedShipWhereUniqueInput
    create: XOR<BlockedShipCreateWithoutBlockingUserInput, BlockedShipUncheckedCreateWithoutBlockingUserInput>
  }

  export type BlockedShipCreateManyBlockingUserInputEnvelope = {
    data: Enumerable<BlockedShipCreateManyBlockingUserInput>
    skipDuplicates?: boolean
  }

  export type BlockedShipCreateWithoutBlockedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    blockingUser: UserCreateNestedOneWithoutBlockedUserInput
  }

  export type BlockedShipUncheckedCreateWithoutBlockedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    blockingUserName: string
  }

  export type BlockedShipCreateOrConnectWithoutBlockedUserInput = {
    where: BlockedShipWhereUniqueInput
    create: XOR<BlockedShipCreateWithoutBlockedUserInput, BlockedShipUncheckedCreateWithoutBlockedUserInput>
  }

  export type BlockedShipCreateManyBlockedUserInputEnvelope = {
    data: Enumerable<BlockedShipCreateManyBlockedUserInput>
    skipDuplicates?: boolean
  }

  export type ChanDiscussionElementCreateWithoutAuthorInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: ChanDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    event?: ChanDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: ChanDiscussionMessageCreateNestedManyWithoutRelatedInput
    chan: ChanCreateNestedOneWithoutElementsInput
  }

  export type ChanDiscussionElementUncheckedCreateWithoutAuthorInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    relatedOf?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type ChanDiscussionElementCreateOrConnectWithoutAuthorInput = {
    where: ChanDiscussionElementWhereUniqueInput
    create: XOR<ChanDiscussionElementCreateWithoutAuthorInput, ChanDiscussionElementUncheckedCreateWithoutAuthorInput>
  }

  export type ChanDiscussionElementCreateManyAuthorInputEnvelope = {
    data: Enumerable<ChanDiscussionElementCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type ChanDiscussionEventCreateWithoutConcernedUserInput = {
    id?: string
    classicChanDiscussionEvent?: ClassicChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    discussionElement?: ChanDiscussionElementCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventUncheckedCreateWithoutConcernedUserInput = {
    id?: string
    classicChanDiscussionEventId?: string | null
    changedTitleChanDiscussionEventId?: string | null
    deletedMessageChanDiscussionEventId?: string | null
    discussionElement?: ChanDiscussionElementUncheckedCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventCreateOrConnectWithoutConcernedUserInput = {
    where: ChanDiscussionEventWhereUniqueInput
    create: XOR<ChanDiscussionEventCreateWithoutConcernedUserInput, ChanDiscussionEventUncheckedCreateWithoutConcernedUserInput>
  }

  export type ChanDiscussionEventCreateManyConcernedUserInputEnvelope = {
    data: Enumerable<ChanDiscussionEventCreateManyConcernedUserInput>
    skipDuplicates?: boolean
  }

  export type DeletedMessageChanDiscussionEventCreateWithoutDeletingUsersInput = {
    id?: string
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedOneWithoutDeletedMessageChanDiscussionEventInput
  }

  export type DeletedMessageChanDiscussionEventUncheckedCreateWithoutDeletingUsersInput = {
    id?: string
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedOneWithoutDeletedMessageChanDiscussionEventInput
  }

  export type DeletedMessageChanDiscussionEventCreateOrConnectWithoutDeletingUsersInput = {
    where: DeletedMessageChanDiscussionEventWhereUniqueInput
    create: XOR<DeletedMessageChanDiscussionEventCreateWithoutDeletingUsersInput, DeletedMessageChanDiscussionEventUncheckedCreateWithoutDeletingUsersInput>
  }

  export type DeletedMessageChanDiscussionEventCreateManyDeletingUsersInputEnvelope = {
    data: Enumerable<DeletedMessageChanDiscussionEventCreateManyDeletingUsersInput>
    skipDuplicates?: boolean
  }

  export type ChanDiscussionMessageCreateWithoutRelatedUsersInput = {
    id?: string
    content: string
    relatedRoles?: RoleCreateNestedManyWithoutRelatedDiscussionMessageInput
    related?: ChanDiscussionElementCreateNestedOneWithoutRelatedOfInput
    discussionElement?: ChanDiscussionElementCreateNestedOneWithoutMessageInput
  }

  export type ChanDiscussionMessageUncheckedCreateWithoutRelatedUsersInput = {
    id?: string
    content: string
    relatedTo?: string | null
    relatedRoles?: RoleUncheckedCreateNestedManyWithoutRelatedDiscussionMessageInput
    discussionElement?: ChanDiscussionElementUncheckedCreateNestedOneWithoutMessageInput
  }

  export type ChanDiscussionMessageCreateOrConnectWithoutRelatedUsersInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    create: XOR<ChanDiscussionMessageCreateWithoutRelatedUsersInput, ChanDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>
  }

  export type DmDiscussionElementCreateWithoutAuthorRelationInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: DmDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    event?: DmDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: DmDiscussionMessageCreateNestedManyWithoutRelatedInput
    directMessage: DirectMessageCreateNestedOneWithoutElementsInput
  }

  export type DmDiscussionElementUncheckedCreateWithoutAuthorRelationInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    directMessageId: string
    relatedOf?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type DmDiscussionElementCreateOrConnectWithoutAuthorRelationInput = {
    where: DmDiscussionElementWhereUniqueInput
    create: XOR<DmDiscussionElementCreateWithoutAuthorRelationInput, DmDiscussionElementUncheckedCreateWithoutAuthorRelationInput>
  }

  export type DmDiscussionElementCreateManyAuthorRelationInputEnvelope = {
    data: Enumerable<DmDiscussionElementCreateManyAuthorRelationInput>
    skipDuplicates?: boolean
  }

  export type DmDiscussionMessageCreateWithoutRelatedUsersInput = {
    id?: string
    content: string
    related?: DmDiscussionElementCreateNestedOneWithoutRelatedOfInput
    discussionElement?: DmDiscussionElementCreateNestedOneWithoutMessageInput
  }

  export type DmDiscussionMessageUncheckedCreateWithoutRelatedUsersInput = {
    id?: string
    content: string
    relatedTo?: string | null
    discussionElement?: DmDiscussionElementUncheckedCreateNestedOneWithoutMessageInput
  }

  export type DmDiscussionMessageCreateOrConnectWithoutRelatedUsersInput = {
    where: DmDiscussionMessageWhereUniqueInput
    create: XOR<DmDiscussionMessageCreateWithoutRelatedUsersInput, DmDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>
  }

  export type MutedUserChanCreateWithoutMutedUserInput = {
    id?: string
    creationDate?: Date | string
    untilDate?: Date | string | null
    chan: ChanCreateNestedOneWithoutMutedUsersInput
  }

  export type MutedUserChanUncheckedCreateWithoutMutedUserInput = {
    id?: string
    creationDate?: Date | string
    untilDate?: Date | string | null
    chanId: string
  }

  export type MutedUserChanCreateOrConnectWithoutMutedUserInput = {
    where: MutedUserChanWhereUniqueInput
    create: XOR<MutedUserChanCreateWithoutMutedUserInput, MutedUserChanUncheckedCreateWithoutMutedUserInput>
  }

  export type MutedUserChanCreateManyMutedUserInputEnvelope = {
    data: Enumerable<MutedUserChanCreateManyMutedUserInput>
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateManyWithWhereWithoutUsersInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRolesInput>
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutRequestingUserInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutRequestingUserInput, DirectMessageUncheckedUpdateWithoutRequestingUserInput>
    create: XOR<DirectMessageCreateWithoutRequestingUserInput, DirectMessageUncheckedCreateWithoutRequestingUserInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutRequestingUserInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutRequestingUserInput, DirectMessageUncheckedUpdateWithoutRequestingUserInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutRequestingUserInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutDirectMessageInput>
  }

  export type DirectMessageScalarWhereInput = {
    AND?: Enumerable<DirectMessageScalarWhereInput>
    OR?: Enumerable<DirectMessageScalarWhereInput>
    NOT?: Enumerable<DirectMessageScalarWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    requestingUserName?: StringFilter | string
    requestingUserStatus?: EnumDirectMessageUserStatusFilter | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: DateTimeNullableFilter | Date | string | null
    requestedUserName?: StringFilter | string
    requestedUserStatus?: EnumDirectMessageUserStatusFilter | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: DateTimeNullableFilter | Date | string | null
    status?: EnumDirectMessageStatusFilter | DirectMessageStatus
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutRequestedUserInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutRequestedUserInput, DirectMessageUncheckedUpdateWithoutRequestedUserInput>
    create: XOR<DirectMessageCreateWithoutRequestedUserInput, DirectMessageUncheckedCreateWithoutRequestedUserInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutRequestedUserInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutRequestedUserInput, DirectMessageUncheckedUpdateWithoutRequestedUserInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutRequestedUserInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutDirectMessageOfInput>
  }

  export type ChanUpsertWithWhereUniqueWithoutUsersInput = {
    where: ChanWhereUniqueInput
    update: XOR<ChanUpdateWithoutUsersInput, ChanUncheckedUpdateWithoutUsersInput>
    create: XOR<ChanCreateWithoutUsersInput, ChanUncheckedCreateWithoutUsersInput>
  }

  export type ChanUpdateWithWhereUniqueWithoutUsersInput = {
    where: ChanWhereUniqueInput
    data: XOR<ChanUpdateWithoutUsersInput, ChanUncheckedUpdateWithoutUsersInput>
  }

  export type ChanUpdateManyWithWhereWithoutUsersInput = {
    where: ChanScalarWhereInput
    data: XOR<ChanUpdateManyMutationInput, ChanUncheckedUpdateManyWithoutChansInput>
  }

  export type ChanScalarWhereInput = {
    AND?: Enumerable<ChanScalarWhereInput>
    OR?: Enumerable<ChanScalarWhereInput>
    NOT?: Enumerable<ChanScalarWhereInput>
    id?: StringFilter | string
    type?: EnumChanTypeFilter | ChanType
    title?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    ownerName?: StringFilter | string
  }

  export type ChanUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ChanWhereUniqueInput
    update: XOR<ChanUpdateWithoutOwnerInput, ChanUncheckedUpdateWithoutOwnerInput>
    create: XOR<ChanCreateWithoutOwnerInput, ChanUncheckedCreateWithoutOwnerInput>
  }

  export type ChanUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ChanWhereUniqueInput
    data: XOR<ChanUpdateWithoutOwnerInput, ChanUncheckedUpdateWithoutOwnerInput>
  }

  export type ChanUpdateManyWithWhereWithoutOwnerInput = {
    where: ChanScalarWhereInput
    data: XOR<ChanUpdateManyMutationInput, ChanUncheckedUpdateManyWithoutOwnedChansInput>
  }

  export type FriendShipUpsertWithWhereUniqueWithoutRequestingUserInput = {
    where: FriendShipWhereUniqueInput
    update: XOR<FriendShipUpdateWithoutRequestingUserInput, FriendShipUncheckedUpdateWithoutRequestingUserInput>
    create: XOR<FriendShipCreateWithoutRequestingUserInput, FriendShipUncheckedCreateWithoutRequestingUserInput>
  }

  export type FriendShipUpdateWithWhereUniqueWithoutRequestingUserInput = {
    where: FriendShipWhereUniqueInput
    data: XOR<FriendShipUpdateWithoutRequestingUserInput, FriendShipUncheckedUpdateWithoutRequestingUserInput>
  }

  export type FriendShipUpdateManyWithWhereWithoutRequestingUserInput = {
    where: FriendShipScalarWhereInput
    data: XOR<FriendShipUpdateManyMutationInput, FriendShipUncheckedUpdateManyWithoutFriendInput>
  }

  export type FriendShipScalarWhereInput = {
    AND?: Enumerable<FriendShipScalarWhereInput>
    OR?: Enumerable<FriendShipScalarWhereInput>
    NOT?: Enumerable<FriendShipScalarWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    requestingUserName?: StringFilter | string
    requestedUserName?: StringFilter | string
  }

  export type FriendShipUpsertWithWhereUniqueWithoutRequestedUserInput = {
    where: FriendShipWhereUniqueInput
    update: XOR<FriendShipUpdateWithoutRequestedUserInput, FriendShipUncheckedUpdateWithoutRequestedUserInput>
    create: XOR<FriendShipCreateWithoutRequestedUserInput, FriendShipUncheckedCreateWithoutRequestedUserInput>
  }

  export type FriendShipUpdateWithWhereUniqueWithoutRequestedUserInput = {
    where: FriendShipWhereUniqueInput
    data: XOR<FriendShipUpdateWithoutRequestedUserInput, FriendShipUncheckedUpdateWithoutRequestedUserInput>
  }

  export type FriendShipUpdateManyWithWhereWithoutRequestedUserInput = {
    where: FriendShipScalarWhereInput
    data: XOR<FriendShipUpdateManyMutationInput, FriendShipUncheckedUpdateManyWithoutFriendOfInput>
  }

  export type FriendInvitationUpsertWithWhereUniqueWithoutInvitingUserInput = {
    where: FriendInvitationWhereUniqueInput
    update: XOR<FriendInvitationUpdateWithoutInvitingUserInput, FriendInvitationUncheckedUpdateWithoutInvitingUserInput>
    create: XOR<FriendInvitationCreateWithoutInvitingUserInput, FriendInvitationUncheckedCreateWithoutInvitingUserInput>
  }

  export type FriendInvitationUpdateWithWhereUniqueWithoutInvitingUserInput = {
    where: FriendInvitationWhereUniqueInput
    data: XOR<FriendInvitationUpdateWithoutInvitingUserInput, FriendInvitationUncheckedUpdateWithoutInvitingUserInput>
  }

  export type FriendInvitationUpdateManyWithWhereWithoutInvitingUserInput = {
    where: FriendInvitationScalarWhereInput
    data: XOR<FriendInvitationUpdateManyMutationInput, FriendInvitationUncheckedUpdateManyWithoutOutcomingFriendInvitationInput>
  }

  export type FriendInvitationScalarWhereInput = {
    AND?: Enumerable<FriendInvitationScalarWhereInput>
    OR?: Enumerable<FriendInvitationScalarWhereInput>
    NOT?: Enumerable<FriendInvitationScalarWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    invitingUserName?: StringFilter | string
    invitedUserName?: StringFilter | string
    status?: EnumFriendInvitationStatusFilter | FriendInvitationStatus
  }

  export type FriendInvitationUpsertWithWhereUniqueWithoutInvitedUserInput = {
    where: FriendInvitationWhereUniqueInput
    update: XOR<FriendInvitationUpdateWithoutInvitedUserInput, FriendInvitationUncheckedUpdateWithoutInvitedUserInput>
    create: XOR<FriendInvitationCreateWithoutInvitedUserInput, FriendInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type FriendInvitationUpdateWithWhereUniqueWithoutInvitedUserInput = {
    where: FriendInvitationWhereUniqueInput
    data: XOR<FriendInvitationUpdateWithoutInvitedUserInput, FriendInvitationUncheckedUpdateWithoutInvitedUserInput>
  }

  export type FriendInvitationUpdateManyWithWhereWithoutInvitedUserInput = {
    where: FriendInvitationScalarWhereInput
    data: XOR<FriendInvitationUpdateManyMutationInput, FriendInvitationUncheckedUpdateManyWithoutIncomingFriendInvitationInput>
  }

  export type ChanInvitationUpsertWithWhereUniqueWithoutInvitingUserInput = {
    where: ChanInvitationWhereUniqueInput
    update: XOR<ChanInvitationUpdateWithoutInvitingUserInput, ChanInvitationUncheckedUpdateWithoutInvitingUserInput>
    create: XOR<ChanInvitationCreateWithoutInvitingUserInput, ChanInvitationUncheckedCreateWithoutInvitingUserInput>
  }

  export type ChanInvitationUpdateWithWhereUniqueWithoutInvitingUserInput = {
    where: ChanInvitationWhereUniqueInput
    data: XOR<ChanInvitationUpdateWithoutInvitingUserInput, ChanInvitationUncheckedUpdateWithoutInvitingUserInput>
  }

  export type ChanInvitationUpdateManyWithWhereWithoutInvitingUserInput = {
    where: ChanInvitationScalarWhereInput
    data: XOR<ChanInvitationUpdateManyMutationInput, ChanInvitationUncheckedUpdateManyWithoutOutcomingChanInvitationInput>
  }

  export type ChanInvitationScalarWhereInput = {
    AND?: Enumerable<ChanInvitationScalarWhereInput>
    OR?: Enumerable<ChanInvitationScalarWhereInput>
    NOT?: Enumerable<ChanInvitationScalarWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    chanId?: StringFilter | string
    chanTitle?: StringFilter | string
    invitingUserName?: StringFilter | string
    invitedUserName?: StringFilter | string
    status?: EnumChanInvitationStatusFilter | ChanInvitationStatus
  }

  export type ChanInvitationUpsertWithWhereUniqueWithoutInvitedUserInput = {
    where: ChanInvitationWhereUniqueInput
    update: XOR<ChanInvitationUpdateWithoutInvitedUserInput, ChanInvitationUncheckedUpdateWithoutInvitedUserInput>
    create: XOR<ChanInvitationCreateWithoutInvitedUserInput, ChanInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type ChanInvitationUpdateWithWhereUniqueWithoutInvitedUserInput = {
    where: ChanInvitationWhereUniqueInput
    data: XOR<ChanInvitationUpdateWithoutInvitedUserInput, ChanInvitationUncheckedUpdateWithoutInvitedUserInput>
  }

  export type ChanInvitationUpdateManyWithWhereWithoutInvitedUserInput = {
    where: ChanInvitationScalarWhereInput
    data: XOR<ChanInvitationUpdateManyMutationInput, ChanInvitationUncheckedUpdateManyWithoutIncomingChanInvitationInput>
  }

  export type BlockedShipUpsertWithWhereUniqueWithoutBlockingUserInput = {
    where: BlockedShipWhereUniqueInput
    update: XOR<BlockedShipUpdateWithoutBlockingUserInput, BlockedShipUncheckedUpdateWithoutBlockingUserInput>
    create: XOR<BlockedShipCreateWithoutBlockingUserInput, BlockedShipUncheckedCreateWithoutBlockingUserInput>
  }

  export type BlockedShipUpdateWithWhereUniqueWithoutBlockingUserInput = {
    where: BlockedShipWhereUniqueInput
    data: XOR<BlockedShipUpdateWithoutBlockingUserInput, BlockedShipUncheckedUpdateWithoutBlockingUserInput>
  }

  export type BlockedShipUpdateManyWithWhereWithoutBlockingUserInput = {
    where: BlockedShipScalarWhereInput
    data: XOR<BlockedShipUpdateManyMutationInput, BlockedShipUncheckedUpdateManyWithoutBlockedUserInput>
  }

  export type BlockedShipScalarWhereInput = {
    AND?: Enumerable<BlockedShipScalarWhereInput>
    OR?: Enumerable<BlockedShipScalarWhereInput>
    NOT?: Enumerable<BlockedShipScalarWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    blockingUserName?: StringFilter | string
    blockedUserName?: StringFilter | string
  }

  export type BlockedShipUpsertWithWhereUniqueWithoutBlockedUserInput = {
    where: BlockedShipWhereUniqueInput
    update: XOR<BlockedShipUpdateWithoutBlockedUserInput, BlockedShipUncheckedUpdateWithoutBlockedUserInput>
    create: XOR<BlockedShipCreateWithoutBlockedUserInput, BlockedShipUncheckedCreateWithoutBlockedUserInput>
  }

  export type BlockedShipUpdateWithWhereUniqueWithoutBlockedUserInput = {
    where: BlockedShipWhereUniqueInput
    data: XOR<BlockedShipUpdateWithoutBlockedUserInput, BlockedShipUncheckedUpdateWithoutBlockedUserInput>
  }

  export type BlockedShipUpdateManyWithWhereWithoutBlockedUserInput = {
    where: BlockedShipScalarWhereInput
    data: XOR<BlockedShipUpdateManyMutationInput, BlockedShipUncheckedUpdateManyWithoutBlockedByUserInput>
  }

  export type ChanDiscussionElementUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ChanDiscussionElementWhereUniqueInput
    update: XOR<ChanDiscussionElementUpdateWithoutAuthorInput, ChanDiscussionElementUncheckedUpdateWithoutAuthorInput>
    create: XOR<ChanDiscussionElementCreateWithoutAuthorInput, ChanDiscussionElementUncheckedCreateWithoutAuthorInput>
  }

  export type ChanDiscussionElementUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ChanDiscussionElementWhereUniqueInput
    data: XOR<ChanDiscussionElementUpdateWithoutAuthorInput, ChanDiscussionElementUncheckedUpdateWithoutAuthorInput>
  }

  export type ChanDiscussionElementUpdateManyWithWhereWithoutAuthorInput = {
    where: ChanDiscussionElementScalarWhereInput
    data: XOR<ChanDiscussionElementUpdateManyMutationInput, ChanDiscussionElementUncheckedUpdateManyWithoutChanDiscussionElementInput>
  }

  export type ChanDiscussionElementScalarWhereInput = {
    AND?: Enumerable<ChanDiscussionElementScalarWhereInput>
    OR?: Enumerable<ChanDiscussionElementScalarWhereInput>
    NOT?: Enumerable<ChanDiscussionElementScalarWhereInput>
    id?: StringFilter | string
    messageId?: StringNullableFilter | string | null
    eventId?: StringNullableFilter | string | null
    authorName?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    chanId?: StringFilter | string
  }

  export type ChanDiscussionEventUpsertWithWhereUniqueWithoutConcernedUserInput = {
    where: ChanDiscussionEventWhereUniqueInput
    update: XOR<ChanDiscussionEventUpdateWithoutConcernedUserInput, ChanDiscussionEventUncheckedUpdateWithoutConcernedUserInput>
    create: XOR<ChanDiscussionEventCreateWithoutConcernedUserInput, ChanDiscussionEventUncheckedCreateWithoutConcernedUserInput>
  }

  export type ChanDiscussionEventUpdateWithWhereUniqueWithoutConcernedUserInput = {
    where: ChanDiscussionEventWhereUniqueInput
    data: XOR<ChanDiscussionEventUpdateWithoutConcernedUserInput, ChanDiscussionEventUncheckedUpdateWithoutConcernedUserInput>
  }

  export type ChanDiscussionEventUpdateManyWithWhereWithoutConcernedUserInput = {
    where: ChanDiscussionEventScalarWhereInput
    data: XOR<ChanDiscussionEventUpdateManyMutationInput, ChanDiscussionEventUncheckedUpdateManyWithoutChanDiscussionEventInput>
  }

  export type ChanDiscussionEventScalarWhereInput = {
    AND?: Enumerable<ChanDiscussionEventScalarWhereInput>
    OR?: Enumerable<ChanDiscussionEventScalarWhereInput>
    NOT?: Enumerable<ChanDiscussionEventScalarWhereInput>
    id?: StringFilter | string
    concernedUserName?: StringNullableFilter | string | null
    classicChanDiscussionEventId?: StringNullableFilter | string | null
    changedTitleChanDiscussionEventId?: StringNullableFilter | string | null
    deletedMessageChanDiscussionEventId?: StringNullableFilter | string | null
  }

  export type DeletedMessageChanDiscussionEventUpsertWithWhereUniqueWithoutDeletingUsersInput = {
    where: DeletedMessageChanDiscussionEventWhereUniqueInput
    update: XOR<DeletedMessageChanDiscussionEventUpdateWithoutDeletingUsersInput, DeletedMessageChanDiscussionEventUncheckedUpdateWithoutDeletingUsersInput>
    create: XOR<DeletedMessageChanDiscussionEventCreateWithoutDeletingUsersInput, DeletedMessageChanDiscussionEventUncheckedCreateWithoutDeletingUsersInput>
  }

  export type DeletedMessageChanDiscussionEventUpdateWithWhereUniqueWithoutDeletingUsersInput = {
    where: DeletedMessageChanDiscussionEventWhereUniqueInput
    data: XOR<DeletedMessageChanDiscussionEventUpdateWithoutDeletingUsersInput, DeletedMessageChanDiscussionEventUncheckedUpdateWithoutDeletingUsersInput>
  }

  export type DeletedMessageChanDiscussionEventUpdateManyWithWhereWithoutDeletingUsersInput = {
    where: DeletedMessageChanDiscussionEventScalarWhereInput
    data: XOR<DeletedMessageChanDiscussionEventUpdateManyMutationInput, DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletedMessageChanDiscussionEventInput>
  }

  export type DeletedMessageChanDiscussionEventScalarWhereInput = {
    AND?: Enumerable<DeletedMessageChanDiscussionEventScalarWhereInput>
    OR?: Enumerable<DeletedMessageChanDiscussionEventScalarWhereInput>
    NOT?: Enumerable<DeletedMessageChanDiscussionEventScalarWhereInput>
    id?: StringFilter | string
    deletingUserName?: StringFilter | string
  }

  export type ChanDiscussionMessageUpsertWithWhereUniqueWithoutRelatedUsersInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    update: XOR<ChanDiscussionMessageUpdateWithoutRelatedUsersInput, ChanDiscussionMessageUncheckedUpdateWithoutRelatedUsersInput>
    create: XOR<ChanDiscussionMessageCreateWithoutRelatedUsersInput, ChanDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>
  }

  export type ChanDiscussionMessageUpdateWithWhereUniqueWithoutRelatedUsersInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    data: XOR<ChanDiscussionMessageUpdateWithoutRelatedUsersInput, ChanDiscussionMessageUncheckedUpdateWithoutRelatedUsersInput>
  }

  export type ChanDiscussionMessageUpdateManyWithWhereWithoutRelatedUsersInput = {
    where: ChanDiscussionMessageScalarWhereInput
    data: XOR<ChanDiscussionMessageUpdateManyMutationInput, ChanDiscussionMessageUncheckedUpdateManyWithoutChanDiscussionMessageInput>
  }

  export type DmDiscussionElementUpsertWithWhereUniqueWithoutAuthorRelationInput = {
    where: DmDiscussionElementWhereUniqueInput
    update: XOR<DmDiscussionElementUpdateWithoutAuthorRelationInput, DmDiscussionElementUncheckedUpdateWithoutAuthorRelationInput>
    create: XOR<DmDiscussionElementCreateWithoutAuthorRelationInput, DmDiscussionElementUncheckedCreateWithoutAuthorRelationInput>
  }

  export type DmDiscussionElementUpdateWithWhereUniqueWithoutAuthorRelationInput = {
    where: DmDiscussionElementWhereUniqueInput
    data: XOR<DmDiscussionElementUpdateWithoutAuthorRelationInput, DmDiscussionElementUncheckedUpdateWithoutAuthorRelationInput>
  }

  export type DmDiscussionElementUpdateManyWithWhereWithoutAuthorRelationInput = {
    where: DmDiscussionElementScalarWhereInput
    data: XOR<DmDiscussionElementUpdateManyMutationInput, DmDiscussionElementUncheckedUpdateManyWithoutDmDiscussionElementInput>
  }

  export type DmDiscussionElementScalarWhereInput = {
    AND?: Enumerable<DmDiscussionElementScalarWhereInput>
    OR?: Enumerable<DmDiscussionElementScalarWhereInput>
    NOT?: Enumerable<DmDiscussionElementScalarWhereInput>
    id?: StringFilter | string
    messageId?: StringNullableFilter | string | null
    eventId?: StringNullableFilter | string | null
    author?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    modificationDate?: DateTimeNullableFilter | Date | string | null
    directMessageId?: StringFilter | string
  }

  export type DmDiscussionMessageUpsertWithWhereUniqueWithoutRelatedUsersInput = {
    where: DmDiscussionMessageWhereUniqueInput
    update: XOR<DmDiscussionMessageUpdateWithoutRelatedUsersInput, DmDiscussionMessageUncheckedUpdateWithoutRelatedUsersInput>
    create: XOR<DmDiscussionMessageCreateWithoutRelatedUsersInput, DmDiscussionMessageUncheckedCreateWithoutRelatedUsersInput>
  }

  export type DmDiscussionMessageUpdateWithWhereUniqueWithoutRelatedUsersInput = {
    where: DmDiscussionMessageWhereUniqueInput
    data: XOR<DmDiscussionMessageUpdateWithoutRelatedUsersInput, DmDiscussionMessageUncheckedUpdateWithoutRelatedUsersInput>
  }

  export type DmDiscussionMessageUpdateManyWithWhereWithoutRelatedUsersInput = {
    where: DmDiscussionMessageScalarWhereInput
    data: XOR<DmDiscussionMessageUpdateManyMutationInput, DmDiscussionMessageUncheckedUpdateManyWithoutDmDiscussionMessageInput>
  }

  export type DmDiscussionMessageScalarWhereInput = {
    AND?: Enumerable<DmDiscussionMessageScalarWhereInput>
    OR?: Enumerable<DmDiscussionMessageScalarWhereInput>
    NOT?: Enumerable<DmDiscussionMessageScalarWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    relatedTo?: StringNullableFilter | string | null
  }

  export type MutedUserChanUpsertWithWhereUniqueWithoutMutedUserInput = {
    where: MutedUserChanWhereUniqueInput
    update: XOR<MutedUserChanUpdateWithoutMutedUserInput, MutedUserChanUncheckedUpdateWithoutMutedUserInput>
    create: XOR<MutedUserChanCreateWithoutMutedUserInput, MutedUserChanUncheckedCreateWithoutMutedUserInput>
  }

  export type MutedUserChanUpdateWithWhereUniqueWithoutMutedUserInput = {
    where: MutedUserChanWhereUniqueInput
    data: XOR<MutedUserChanUpdateWithoutMutedUserInput, MutedUserChanUncheckedUpdateWithoutMutedUserInput>
  }

  export type MutedUserChanUpdateManyWithWhereWithoutMutedUserInput = {
    where: MutedUserChanScalarWhereInput
    data: XOR<MutedUserChanUpdateManyMutationInput, MutedUserChanUncheckedUpdateManyWithoutMutedUserChanInput>
  }

  export type MutedUserChanScalarWhereInput = {
    AND?: Enumerable<MutedUserChanScalarWhereInput>
    OR?: Enumerable<MutedUserChanScalarWhereInput>
    NOT?: Enumerable<MutedUserChanScalarWhereInput>
    id?: StringFilter | string
    creationDate?: DateTimeFilter | Date | string
    untilDate?: DateTimeNullableFilter | Date | string | null
    mutedUserName?: StringFilter | string
    chanId?: StringFilter | string
  }

  export type UserCreateWithoutDirectMessageInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutDirectMessageInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutDirectMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDirectMessageInput, UserUncheckedCreateWithoutDirectMessageInput>
  }

  export type UserCreateWithoutDirectMessageOfInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutDirectMessageOfInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutDirectMessageOfInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDirectMessageOfInput, UserUncheckedCreateWithoutDirectMessageOfInput>
  }

  export type DmDiscussionElementCreateWithoutDirectMessageInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: DmDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    event?: DmDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: DmDiscussionMessageCreateNestedManyWithoutRelatedInput
    authorRelation: UserCreateNestedOneWithoutDmDiscussionElementInput
  }

  export type DmDiscussionElementUncheckedCreateWithoutDirectMessageInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    author: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    relatedOf?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type DmDiscussionElementCreateOrConnectWithoutDirectMessageInput = {
    where: DmDiscussionElementWhereUniqueInput
    create: XOR<DmDiscussionElementCreateWithoutDirectMessageInput, DmDiscussionElementUncheckedCreateWithoutDirectMessageInput>
  }

  export type DmDiscussionElementCreateManyDirectMessageInputEnvelope = {
    data: Enumerable<DmDiscussionElementCreateManyDirectMessageInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDirectMessageInput = {
    update: XOR<UserUpdateWithoutDirectMessageInput, UserUncheckedUpdateWithoutDirectMessageInput>
    create: XOR<UserCreateWithoutDirectMessageInput, UserUncheckedCreateWithoutDirectMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDirectMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDirectMessageInput, UserUncheckedUpdateWithoutDirectMessageInput>
  }

  export type UserUpdateWithoutDirectMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDirectMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUpsertWithoutDirectMessageOfInput = {
    update: XOR<UserUpdateWithoutDirectMessageOfInput, UserUncheckedUpdateWithoutDirectMessageOfInput>
    create: XOR<UserCreateWithoutDirectMessageOfInput, UserUncheckedCreateWithoutDirectMessageOfInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDirectMessageOfInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDirectMessageOfInput, UserUncheckedUpdateWithoutDirectMessageOfInput>
  }

  export type UserUpdateWithoutDirectMessageOfInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDirectMessageOfInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type DmDiscussionElementUpsertWithWhereUniqueWithoutDirectMessageInput = {
    where: DmDiscussionElementWhereUniqueInput
    update: XOR<DmDiscussionElementUpdateWithoutDirectMessageInput, DmDiscussionElementUncheckedUpdateWithoutDirectMessageInput>
    create: XOR<DmDiscussionElementCreateWithoutDirectMessageInput, DmDiscussionElementUncheckedCreateWithoutDirectMessageInput>
  }

  export type DmDiscussionElementUpdateWithWhereUniqueWithoutDirectMessageInput = {
    where: DmDiscussionElementWhereUniqueInput
    data: XOR<DmDiscussionElementUpdateWithoutDirectMessageInput, DmDiscussionElementUncheckedUpdateWithoutDirectMessageInput>
  }

  export type DmDiscussionElementUpdateManyWithWhereWithoutDirectMessageInput = {
    where: DmDiscussionElementScalarWhereInput
    data: XOR<DmDiscussionElementUpdateManyMutationInput, DmDiscussionElementUncheckedUpdateManyWithoutElementsInput>
  }

  export type DmDiscussionMessageCreateWithoutDiscussionElementInput = {
    id?: string
    content: string
    relatedUsers?: UserCreateNestedManyWithoutDmDiscussionMessageInput
    related?: DmDiscussionElementCreateNestedOneWithoutRelatedOfInput
  }

  export type DmDiscussionMessageUncheckedCreateWithoutDiscussionElementInput = {
    id?: string
    content: string
    relatedTo?: string | null
    relatedUsers?: UserUncheckedCreateNestedManyWithoutDmDiscussionMessageInput
  }

  export type DmDiscussionMessageCreateOrConnectWithoutDiscussionElementInput = {
    where: DmDiscussionMessageWhereUniqueInput
    create: XOR<DmDiscussionMessageCreateWithoutDiscussionElementInput, DmDiscussionMessageUncheckedCreateWithoutDiscussionElementInput>
  }

  export type DmDiscussionEventCreateWithoutDiscussionElementInput = {
    id?: string
    classicDmDiscussionEvent?: ClassicDmDiscussionEventCreateNestedOneWithoutDmDiscussionEventInput
    chanInvitationDmDiscussionEvent?: ChanInvitationDmDiscussionEventCreateNestedOneWithoutDmDiscussionEventInput
  }

  export type DmDiscussionEventUncheckedCreateWithoutDiscussionElementInput = {
    id?: string
    classicDmDiscussionEventId?: string | null
    chanInvitationDmDiscussionEventId?: string | null
  }

  export type DmDiscussionEventCreateOrConnectWithoutDiscussionElementInput = {
    where: DmDiscussionEventWhereUniqueInput
    create: XOR<DmDiscussionEventCreateWithoutDiscussionElementInput, DmDiscussionEventUncheckedCreateWithoutDiscussionElementInput>
  }

  export type DmDiscussionMessageCreateWithoutRelatedInput = {
    id?: string
    content: string
    relatedUsers?: UserCreateNestedManyWithoutDmDiscussionMessageInput
    discussionElement?: DmDiscussionElementCreateNestedOneWithoutMessageInput
  }

  export type DmDiscussionMessageUncheckedCreateWithoutRelatedInput = {
    id?: string
    content: string
    relatedUsers?: UserUncheckedCreateNestedManyWithoutDmDiscussionMessageInput
    discussionElement?: DmDiscussionElementUncheckedCreateNestedOneWithoutMessageInput
  }

  export type DmDiscussionMessageCreateOrConnectWithoutRelatedInput = {
    where: DmDiscussionMessageWhereUniqueInput
    create: XOR<DmDiscussionMessageCreateWithoutRelatedInput, DmDiscussionMessageUncheckedCreateWithoutRelatedInput>
  }

  export type DmDiscussionMessageCreateManyRelatedInputEnvelope = {
    data: Enumerable<DmDiscussionMessageCreateManyRelatedInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDmDiscussionElementInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutDmDiscussionElementInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutDmDiscussionElementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDmDiscussionElementInput, UserUncheckedCreateWithoutDmDiscussionElementInput>
  }

  export type DirectMessageCreateWithoutElementsInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
    requestingUser: UserCreateNestedOneWithoutDirectMessageInput
    requestedUser: UserCreateNestedOneWithoutDirectMessageOfInput
  }

  export type DirectMessageUncheckedCreateWithoutElementsInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserName: string
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserName: string
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
  }

  export type DirectMessageCreateOrConnectWithoutElementsInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutElementsInput, DirectMessageUncheckedCreateWithoutElementsInput>
  }

  export type DmDiscussionMessageUpsertWithoutDiscussionElementInput = {
    update: XOR<DmDiscussionMessageUpdateWithoutDiscussionElementInput, DmDiscussionMessageUncheckedUpdateWithoutDiscussionElementInput>
    create: XOR<DmDiscussionMessageCreateWithoutDiscussionElementInput, DmDiscussionMessageUncheckedCreateWithoutDiscussionElementInput>
    where?: DmDiscussionMessageWhereInput
  }

  export type DmDiscussionMessageUpdateToOneWithWhereWithoutDiscussionElementInput = {
    where?: DmDiscussionMessageWhereInput
    data: XOR<DmDiscussionMessageUpdateWithoutDiscussionElementInput, DmDiscussionMessageUncheckedUpdateWithoutDiscussionElementInput>
  }

  export type DmDiscussionMessageUpdateWithoutDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedUsers?: UserUpdateManyWithoutDmDiscussionMessageNestedInput
    related?: DmDiscussionElementUpdateOneWithoutRelatedOfNestedInput
  }

  export type DmDiscussionMessageUncheckedUpdateWithoutDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsers?: UserUncheckedUpdateManyWithoutDmDiscussionMessageNestedInput
  }

  export type DmDiscussionEventUpsertWithoutDiscussionElementInput = {
    update: XOR<DmDiscussionEventUpdateWithoutDiscussionElementInput, DmDiscussionEventUncheckedUpdateWithoutDiscussionElementInput>
    create: XOR<DmDiscussionEventCreateWithoutDiscussionElementInput, DmDiscussionEventUncheckedCreateWithoutDiscussionElementInput>
    where?: DmDiscussionEventWhereInput
  }

  export type DmDiscussionEventUpdateToOneWithWhereWithoutDiscussionElementInput = {
    where?: DmDiscussionEventWhereInput
    data: XOR<DmDiscussionEventUpdateWithoutDiscussionElementInput, DmDiscussionEventUncheckedUpdateWithoutDiscussionElementInput>
  }

  export type DmDiscussionEventUpdateWithoutDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicDmDiscussionEvent?: ClassicDmDiscussionEventUpdateOneWithoutDmDiscussionEventNestedInput
    chanInvitationDmDiscussionEvent?: ChanInvitationDmDiscussionEventUpdateOneWithoutDmDiscussionEventNestedInput
  }

  export type DmDiscussionEventUncheckedUpdateWithoutDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicDmDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    chanInvitationDmDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DmDiscussionMessageUpsertWithWhereUniqueWithoutRelatedInput = {
    where: DmDiscussionMessageWhereUniqueInput
    update: XOR<DmDiscussionMessageUpdateWithoutRelatedInput, DmDiscussionMessageUncheckedUpdateWithoutRelatedInput>
    create: XOR<DmDiscussionMessageCreateWithoutRelatedInput, DmDiscussionMessageUncheckedCreateWithoutRelatedInput>
  }

  export type DmDiscussionMessageUpdateWithWhereUniqueWithoutRelatedInput = {
    where: DmDiscussionMessageWhereUniqueInput
    data: XOR<DmDiscussionMessageUpdateWithoutRelatedInput, DmDiscussionMessageUncheckedUpdateWithoutRelatedInput>
  }

  export type DmDiscussionMessageUpdateManyWithWhereWithoutRelatedInput = {
    where: DmDiscussionMessageScalarWhereInput
    data: XOR<DmDiscussionMessageUpdateManyMutationInput, DmDiscussionMessageUncheckedUpdateManyWithoutRelatedOfInput>
  }

  export type UserUpsertWithoutDmDiscussionElementInput = {
    update: XOR<UserUpdateWithoutDmDiscussionElementInput, UserUncheckedUpdateWithoutDmDiscussionElementInput>
    create: XOR<UserCreateWithoutDmDiscussionElementInput, UserUncheckedCreateWithoutDmDiscussionElementInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDmDiscussionElementInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDmDiscussionElementInput, UserUncheckedUpdateWithoutDmDiscussionElementInput>
  }

  export type UserUpdateWithoutDmDiscussionElementInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDmDiscussionElementInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type DirectMessageUpsertWithoutElementsInput = {
    update: XOR<DirectMessageUpdateWithoutElementsInput, DirectMessageUncheckedUpdateWithoutElementsInput>
    create: XOR<DirectMessageCreateWithoutElementsInput, DirectMessageUncheckedCreateWithoutElementsInput>
    where?: DirectMessageWhereInput
  }

  export type DirectMessageUpdateToOneWithWhereWithoutElementsInput = {
    where?: DirectMessageWhereInput
    data: XOR<DirectMessageUpdateWithoutElementsInput, DirectMessageUncheckedUpdateWithoutElementsInput>
  }

  export type DirectMessageUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
    requestingUser?: UserUpdateOneRequiredWithoutDirectMessageNestedInput
    requestedUser?: UserUpdateOneRequiredWithoutDirectMessageOfNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserName?: StringFieldUpdateOperationsInput | string
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserName?: StringFieldUpdateOperationsInput | string
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
  }

  export type UserCreateWithoutDmDiscussionMessageInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutDmDiscussionMessageInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutDmDiscussionMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDmDiscussionMessageInput, UserUncheckedCreateWithoutDmDiscussionMessageInput>
  }

  export type DmDiscussionElementCreateWithoutRelatedOfInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: DmDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    event?: DmDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    authorRelation: UserCreateNestedOneWithoutDmDiscussionElementInput
    directMessage: DirectMessageCreateNestedOneWithoutElementsInput
  }

  export type DmDiscussionElementUncheckedCreateWithoutRelatedOfInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    author: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    directMessageId: string
  }

  export type DmDiscussionElementCreateOrConnectWithoutRelatedOfInput = {
    where: DmDiscussionElementWhereUniqueInput
    create: XOR<DmDiscussionElementCreateWithoutRelatedOfInput, DmDiscussionElementUncheckedCreateWithoutRelatedOfInput>
  }

  export type DmDiscussionElementCreateWithoutMessageInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    event?: DmDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: DmDiscussionMessageCreateNestedManyWithoutRelatedInput
    authorRelation: UserCreateNestedOneWithoutDmDiscussionElementInput
    directMessage: DirectMessageCreateNestedOneWithoutElementsInput
  }

  export type DmDiscussionElementUncheckedCreateWithoutMessageInput = {
    id?: string
    eventId?: string | null
    author: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    directMessageId: string
    relatedOf?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type DmDiscussionElementCreateOrConnectWithoutMessageInput = {
    where: DmDiscussionElementWhereUniqueInput
    create: XOR<DmDiscussionElementCreateWithoutMessageInput, DmDiscussionElementUncheckedCreateWithoutMessageInput>
  }

  export type UserUpsertWithWhereUniqueWithoutDmDiscussionMessageInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDmDiscussionMessageInput, UserUncheckedUpdateWithoutDmDiscussionMessageInput>
    create: XOR<UserCreateWithoutDmDiscussionMessageInput, UserUncheckedCreateWithoutDmDiscussionMessageInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDmDiscussionMessageInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDmDiscussionMessageInput, UserUncheckedUpdateWithoutDmDiscussionMessageInput>
  }

  export type UserUpdateManyWithWhereWithoutDmDiscussionMessageInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRelatedUsersInput>
  }

  export type DmDiscussionElementUpsertWithoutRelatedOfInput = {
    update: XOR<DmDiscussionElementUpdateWithoutRelatedOfInput, DmDiscussionElementUncheckedUpdateWithoutRelatedOfInput>
    create: XOR<DmDiscussionElementCreateWithoutRelatedOfInput, DmDiscussionElementUncheckedCreateWithoutRelatedOfInput>
    where?: DmDiscussionElementWhereInput
  }

  export type DmDiscussionElementUpdateToOneWithWhereWithoutRelatedOfInput = {
    where?: DmDiscussionElementWhereInput
    data: XOR<DmDiscussionElementUpdateWithoutRelatedOfInput, DmDiscussionElementUncheckedUpdateWithoutRelatedOfInput>
  }

  export type DmDiscussionElementUpdateWithoutRelatedOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: DmDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    event?: DmDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    authorRelation?: UserUpdateOneRequiredWithoutDmDiscussionElementNestedInput
    directMessage?: DirectMessageUpdateOneRequiredWithoutElementsNestedInput
  }

  export type DmDiscussionElementUncheckedUpdateWithoutRelatedOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    author?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directMessageId?: StringFieldUpdateOperationsInput | string
  }

  export type DmDiscussionElementUpsertWithoutMessageInput = {
    update: XOR<DmDiscussionElementUpdateWithoutMessageInput, DmDiscussionElementUncheckedUpdateWithoutMessageInput>
    create: XOR<DmDiscussionElementCreateWithoutMessageInput, DmDiscussionElementUncheckedCreateWithoutMessageInput>
    where?: DmDiscussionElementWhereInput
  }

  export type DmDiscussionElementUpdateToOneWithWhereWithoutMessageInput = {
    where?: DmDiscussionElementWhereInput
    data: XOR<DmDiscussionElementUpdateWithoutMessageInput, DmDiscussionElementUncheckedUpdateWithoutMessageInput>
  }

  export type DmDiscussionElementUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: DmDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: DmDiscussionMessageUpdateManyWithoutRelatedNestedInput
    authorRelation?: UserUpdateOneRequiredWithoutDmDiscussionElementNestedInput
    directMessage?: DirectMessageUpdateOneRequiredWithoutElementsNestedInput
  }

  export type DmDiscussionElementUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    author?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directMessageId?: StringFieldUpdateOperationsInput | string
    relatedOf?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type ClassicDmDiscussionEventCreateWithoutDmDiscussionEventInput = {
    id?: string
    eventType: ClassicDmEventType
  }

  export type ClassicDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput = {
    id?: string
    eventType: ClassicDmEventType
  }

  export type ClassicDmDiscussionEventCreateOrConnectWithoutDmDiscussionEventInput = {
    where: ClassicDmDiscussionEventWhereUniqueInput
    create: XOR<ClassicDmDiscussionEventCreateWithoutDmDiscussionEventInput, ClassicDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput>
  }

  export type ChanInvitationDmDiscussionEventCreateWithoutDmDiscussionEventInput = {
    id?: string
    chanInvitation: ChanInvitationCreateNestedOneWithoutDiscussionEventInput
  }

  export type ChanInvitationDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput = {
    id?: string
    chanInvitationId: string
  }

  export type ChanInvitationDmDiscussionEventCreateOrConnectWithoutDmDiscussionEventInput = {
    where: ChanInvitationDmDiscussionEventWhereUniqueInput
    create: XOR<ChanInvitationDmDiscussionEventCreateWithoutDmDiscussionEventInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput>
  }

  export type DmDiscussionElementCreateWithoutEventInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: DmDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: DmDiscussionMessageCreateNestedManyWithoutRelatedInput
    authorRelation: UserCreateNestedOneWithoutDmDiscussionElementInput
    directMessage: DirectMessageCreateNestedOneWithoutElementsInput
  }

  export type DmDiscussionElementUncheckedCreateWithoutEventInput = {
    id?: string
    messageId?: string | null
    author: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    directMessageId: string
    relatedOf?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type DmDiscussionElementCreateOrConnectWithoutEventInput = {
    where: DmDiscussionElementWhereUniqueInput
    create: XOR<DmDiscussionElementCreateWithoutEventInput, DmDiscussionElementUncheckedCreateWithoutEventInput>
  }

  export type ClassicDmDiscussionEventUpsertWithoutDmDiscussionEventInput = {
    update: XOR<ClassicDmDiscussionEventUpdateWithoutDmDiscussionEventInput, ClassicDmDiscussionEventUncheckedUpdateWithoutDmDiscussionEventInput>
    create: XOR<ClassicDmDiscussionEventCreateWithoutDmDiscussionEventInput, ClassicDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput>
    where?: ClassicDmDiscussionEventWhereInput
  }

  export type ClassicDmDiscussionEventUpdateToOneWithWhereWithoutDmDiscussionEventInput = {
    where?: ClassicDmDiscussionEventWhereInput
    data: XOR<ClassicDmDiscussionEventUpdateWithoutDmDiscussionEventInput, ClassicDmDiscussionEventUncheckedUpdateWithoutDmDiscussionEventInput>
  }

  export type ClassicDmDiscussionEventUpdateWithoutDmDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicDmEventTypeFieldUpdateOperationsInput | ClassicDmEventType
  }

  export type ClassicDmDiscussionEventUncheckedUpdateWithoutDmDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicDmEventTypeFieldUpdateOperationsInput | ClassicDmEventType
  }

  export type ChanInvitationDmDiscussionEventUpsertWithoutDmDiscussionEventInput = {
    update: XOR<ChanInvitationDmDiscussionEventUpdateWithoutDmDiscussionEventInput, ChanInvitationDmDiscussionEventUncheckedUpdateWithoutDmDiscussionEventInput>
    create: XOR<ChanInvitationDmDiscussionEventCreateWithoutDmDiscussionEventInput, ChanInvitationDmDiscussionEventUncheckedCreateWithoutDmDiscussionEventInput>
    where?: ChanInvitationDmDiscussionEventWhereInput
  }

  export type ChanInvitationDmDiscussionEventUpdateToOneWithWhereWithoutDmDiscussionEventInput = {
    where?: ChanInvitationDmDiscussionEventWhereInput
    data: XOR<ChanInvitationDmDiscussionEventUpdateWithoutDmDiscussionEventInput, ChanInvitationDmDiscussionEventUncheckedUpdateWithoutDmDiscussionEventInput>
  }

  export type ChanInvitationDmDiscussionEventUpdateWithoutDmDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    chanInvitation?: ChanInvitationUpdateOneRequiredWithoutDiscussionEventNestedInput
  }

  export type ChanInvitationDmDiscussionEventUncheckedUpdateWithoutDmDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    chanInvitationId?: StringFieldUpdateOperationsInput | string
  }

  export type DmDiscussionElementUpsertWithoutEventInput = {
    update: XOR<DmDiscussionElementUpdateWithoutEventInput, DmDiscussionElementUncheckedUpdateWithoutEventInput>
    create: XOR<DmDiscussionElementCreateWithoutEventInput, DmDiscussionElementUncheckedCreateWithoutEventInput>
    where?: DmDiscussionElementWhereInput
  }

  export type DmDiscussionElementUpdateToOneWithWhereWithoutEventInput = {
    where?: DmDiscussionElementWhereInput
    data: XOR<DmDiscussionElementUpdateWithoutEventInput, DmDiscussionElementUncheckedUpdateWithoutEventInput>
  }

  export type DmDiscussionElementUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: DmDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: DmDiscussionMessageUpdateManyWithoutRelatedNestedInput
    authorRelation?: UserUpdateOneRequiredWithoutDmDiscussionElementNestedInput
    directMessage?: DirectMessageUpdateOneRequiredWithoutElementsNestedInput
  }

  export type DmDiscussionElementUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    author?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directMessageId?: StringFieldUpdateOperationsInput | string
    relatedOf?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type ChanInvitationCreateWithoutDiscussionEventInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    status?: ChanInvitationStatus
    chan: ChanCreateNestedOneWithoutInvitationsInput
    invitingUser: UserCreateNestedOneWithoutOutcomingChanInvitationInput
    invitedUser: UserCreateNestedOneWithoutIncomingChanInvitationInput
  }

  export type ChanInvitationUncheckedCreateWithoutDiscussionEventInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    chanTitle: string
    invitingUserName: string
    invitedUserName: string
    status?: ChanInvitationStatus
  }

  export type ChanInvitationCreateOrConnectWithoutDiscussionEventInput = {
    where: ChanInvitationWhereUniqueInput
    create: XOR<ChanInvitationCreateWithoutDiscussionEventInput, ChanInvitationUncheckedCreateWithoutDiscussionEventInput>
  }

  export type DmDiscussionEventCreateWithoutChanInvitationDmDiscussionEventInput = {
    id?: string
    classicDmDiscussionEvent?: ClassicDmDiscussionEventCreateNestedOneWithoutDmDiscussionEventInput
    discussionElement?: DmDiscussionElementCreateNestedOneWithoutEventInput
  }

  export type DmDiscussionEventUncheckedCreateWithoutChanInvitationDmDiscussionEventInput = {
    id?: string
    classicDmDiscussionEventId?: string | null
    discussionElement?: DmDiscussionElementUncheckedCreateNestedOneWithoutEventInput
  }

  export type DmDiscussionEventCreateOrConnectWithoutChanInvitationDmDiscussionEventInput = {
    where: DmDiscussionEventWhereUniqueInput
    create: XOR<DmDiscussionEventCreateWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutChanInvitationDmDiscussionEventInput>
  }

  export type ChanInvitationUpsertWithoutDiscussionEventInput = {
    update: XOR<ChanInvitationUpdateWithoutDiscussionEventInput, ChanInvitationUncheckedUpdateWithoutDiscussionEventInput>
    create: XOR<ChanInvitationCreateWithoutDiscussionEventInput, ChanInvitationUncheckedCreateWithoutDiscussionEventInput>
    where?: ChanInvitationWhereInput
  }

  export type ChanInvitationUpdateToOneWithWhereWithoutDiscussionEventInput = {
    where?: ChanInvitationWhereInput
    data: XOR<ChanInvitationUpdateWithoutDiscussionEventInput, ChanInvitationUncheckedUpdateWithoutDiscussionEventInput>
  }

  export type ChanInvitationUpdateWithoutDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
    chan?: ChanUpdateOneRequiredWithoutInvitationsNestedInput
    invitingUser?: UserUpdateOneRequiredWithoutOutcomingChanInvitationNestedInput
    invitedUser?: UserUpdateOneRequiredWithoutIncomingChanInvitationNestedInput
  }

  export type ChanInvitationUncheckedUpdateWithoutDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    chanTitle?: StringFieldUpdateOperationsInput | string
    invitingUserName?: StringFieldUpdateOperationsInput | string
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
  }

  export type DmDiscussionEventUpsertWithoutChanInvitationDmDiscussionEventInput = {
    update: XOR<DmDiscussionEventUpdateWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUncheckedUpdateWithoutChanInvitationDmDiscussionEventInput>
    create: XOR<DmDiscussionEventCreateWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutChanInvitationDmDiscussionEventInput>
    where?: DmDiscussionEventWhereInput
  }

  export type DmDiscussionEventUpdateToOneWithWhereWithoutChanInvitationDmDiscussionEventInput = {
    where?: DmDiscussionEventWhereInput
    data: XOR<DmDiscussionEventUpdateWithoutChanInvitationDmDiscussionEventInput, DmDiscussionEventUncheckedUpdateWithoutChanInvitationDmDiscussionEventInput>
  }

  export type DmDiscussionEventUpdateWithoutChanInvitationDmDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicDmDiscussionEvent?: ClassicDmDiscussionEventUpdateOneWithoutDmDiscussionEventNestedInput
    discussionElement?: DmDiscussionElementUpdateOneWithoutEventNestedInput
  }

  export type DmDiscussionEventUncheckedUpdateWithoutChanInvitationDmDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicDmDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    discussionElement?: DmDiscussionElementUncheckedUpdateOneWithoutEventNestedInput
  }

  export type DmDiscussionEventCreateWithoutClassicDmDiscussionEventInput = {
    id?: string
    chanInvitationDmDiscussionEvent?: ChanInvitationDmDiscussionEventCreateNestedOneWithoutDmDiscussionEventInput
    discussionElement?: DmDiscussionElementCreateNestedOneWithoutEventInput
  }

  export type DmDiscussionEventUncheckedCreateWithoutClassicDmDiscussionEventInput = {
    id?: string
    chanInvitationDmDiscussionEventId?: string | null
    discussionElement?: DmDiscussionElementUncheckedCreateNestedOneWithoutEventInput
  }

  export type DmDiscussionEventCreateOrConnectWithoutClassicDmDiscussionEventInput = {
    where: DmDiscussionEventWhereUniqueInput
    create: XOR<DmDiscussionEventCreateWithoutClassicDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutClassicDmDiscussionEventInput>
  }

  export type DmDiscussionEventUpsertWithoutClassicDmDiscussionEventInput = {
    update: XOR<DmDiscussionEventUpdateWithoutClassicDmDiscussionEventInput, DmDiscussionEventUncheckedUpdateWithoutClassicDmDiscussionEventInput>
    create: XOR<DmDiscussionEventCreateWithoutClassicDmDiscussionEventInput, DmDiscussionEventUncheckedCreateWithoutClassicDmDiscussionEventInput>
    where?: DmDiscussionEventWhereInput
  }

  export type DmDiscussionEventUpdateToOneWithWhereWithoutClassicDmDiscussionEventInput = {
    where?: DmDiscussionEventWhereInput
    data: XOR<DmDiscussionEventUpdateWithoutClassicDmDiscussionEventInput, DmDiscussionEventUncheckedUpdateWithoutClassicDmDiscussionEventInput>
  }

  export type DmDiscussionEventUpdateWithoutClassicDmDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    chanInvitationDmDiscussionEvent?: ChanInvitationDmDiscussionEventUpdateOneWithoutDmDiscussionEventNestedInput
    discussionElement?: DmDiscussionElementUpdateOneWithoutEventNestedInput
  }

  export type DmDiscussionEventUncheckedUpdateWithoutClassicDmDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    chanInvitationDmDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    discussionElement?: DmDiscussionElementUncheckedUpdateOneWithoutEventNestedInput
  }

  export type UserCreateWithoutChansInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutChansInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutChansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChansInput, UserUncheckedCreateWithoutChansInput>
  }

  export type RoleCreateWithoutChanInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    roles?: RoleCreateNestedManyWithoutRolesSymInput
    rolesSym?: RoleCreateNestedManyWithoutRolesInput
    users?: UserCreateNestedManyWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleUncheckedCreateWithoutChanInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    roles?: RoleUncheckedCreateNestedManyWithoutRolesSymInput
    rolesSym?: RoleUncheckedCreateNestedManyWithoutRolesInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedRolesInput
  }

  export type RoleCreateOrConnectWithoutChanInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutChanInput, RoleUncheckedCreateWithoutChanInput>
  }

  export type RoleCreateManyChanInputEnvelope = {
    data: Enumerable<RoleCreateManyChanInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOwnedChansInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutOwnedChansInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutOwnedChansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedChansInput, UserUncheckedCreateWithoutOwnedChansInput>
  }

  export type MutedUserChanCreateWithoutChanInput = {
    id?: string
    creationDate?: Date | string
    untilDate?: Date | string | null
    mutedUser: UserCreateNestedOneWithoutMutedUserChanInput
  }

  export type MutedUserChanUncheckedCreateWithoutChanInput = {
    id?: string
    creationDate?: Date | string
    untilDate?: Date | string | null
    mutedUserName: string
  }

  export type MutedUserChanCreateOrConnectWithoutChanInput = {
    where: MutedUserChanWhereUniqueInput
    create: XOR<MutedUserChanCreateWithoutChanInput, MutedUserChanUncheckedCreateWithoutChanInput>
  }

  export type MutedUserChanCreateManyChanInputEnvelope = {
    data: Enumerable<MutedUserChanCreateManyChanInput>
    skipDuplicates?: boolean
  }

  export type ChanInvitationCreateWithoutChanInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    status?: ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventCreateNestedOneWithoutChanInvitationInput
    invitingUser: UserCreateNestedOneWithoutOutcomingChanInvitationInput
    invitedUser: UserCreateNestedOneWithoutIncomingChanInvitationInput
  }

  export type ChanInvitationUncheckedCreateWithoutChanInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    invitingUserName: string
    invitedUserName: string
    status?: ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventUncheckedCreateNestedOneWithoutChanInvitationInput
  }

  export type ChanInvitationCreateOrConnectWithoutChanInput = {
    where: ChanInvitationWhereUniqueInput
    create: XOR<ChanInvitationCreateWithoutChanInput, ChanInvitationUncheckedCreateWithoutChanInput>
  }

  export type ChanInvitationCreateManyChanInputEnvelope = {
    data: Enumerable<ChanInvitationCreateManyChanInput>
    skipDuplicates?: boolean
  }

  export type ChanDiscussionElementCreateWithoutChanInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: ChanDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    event?: ChanDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: ChanDiscussionMessageCreateNestedManyWithoutRelatedInput
    author: UserCreateNestedOneWithoutChanDiscussionElementInput
  }

  export type ChanDiscussionElementUncheckedCreateWithoutChanInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    authorName: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    relatedOf?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type ChanDiscussionElementCreateOrConnectWithoutChanInput = {
    where: ChanDiscussionElementWhereUniqueInput
    create: XOR<ChanDiscussionElementCreateWithoutChanInput, ChanDiscussionElementUncheckedCreateWithoutChanInput>
  }

  export type ChanDiscussionElementCreateManyChanInputEnvelope = {
    data: Enumerable<ChanDiscussionElementCreateManyChanInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutChansInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutChansInput, UserUncheckedUpdateWithoutChansInput>
    create: XOR<UserCreateWithoutChansInput, UserUncheckedCreateWithoutChansInput>
  }

  export type UserUpdateWithWhereUniqueWithoutChansInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutChansInput, UserUncheckedUpdateWithoutChansInput>
  }

  export type UserUpdateManyWithWhereWithoutChansInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutChanInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutChanInput, RoleUncheckedUpdateWithoutChanInput>
    create: XOR<RoleCreateWithoutChanInput, RoleUncheckedCreateWithoutChanInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutChanInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutChanInput, RoleUncheckedUpdateWithoutChanInput>
  }

  export type RoleUpdateManyWithWhereWithoutChanInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRolesInput>
  }

  export type UserUpsertWithoutOwnedChansInput = {
    update: XOR<UserUpdateWithoutOwnedChansInput, UserUncheckedUpdateWithoutOwnedChansInput>
    create: XOR<UserCreateWithoutOwnedChansInput, UserUncheckedCreateWithoutOwnedChansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedChansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedChansInput, UserUncheckedUpdateWithoutOwnedChansInput>
  }

  export type UserUpdateWithoutOwnedChansInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedChansInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type MutedUserChanUpsertWithWhereUniqueWithoutChanInput = {
    where: MutedUserChanWhereUniqueInput
    update: XOR<MutedUserChanUpdateWithoutChanInput, MutedUserChanUncheckedUpdateWithoutChanInput>
    create: XOR<MutedUserChanCreateWithoutChanInput, MutedUserChanUncheckedCreateWithoutChanInput>
  }

  export type MutedUserChanUpdateWithWhereUniqueWithoutChanInput = {
    where: MutedUserChanWhereUniqueInput
    data: XOR<MutedUserChanUpdateWithoutChanInput, MutedUserChanUncheckedUpdateWithoutChanInput>
  }

  export type MutedUserChanUpdateManyWithWhereWithoutChanInput = {
    where: MutedUserChanScalarWhereInput
    data: XOR<MutedUserChanUpdateManyMutationInput, MutedUserChanUncheckedUpdateManyWithoutMutedUsersInput>
  }

  export type ChanInvitationUpsertWithWhereUniqueWithoutChanInput = {
    where: ChanInvitationWhereUniqueInput
    update: XOR<ChanInvitationUpdateWithoutChanInput, ChanInvitationUncheckedUpdateWithoutChanInput>
    create: XOR<ChanInvitationCreateWithoutChanInput, ChanInvitationUncheckedCreateWithoutChanInput>
  }

  export type ChanInvitationUpdateWithWhereUniqueWithoutChanInput = {
    where: ChanInvitationWhereUniqueInput
    data: XOR<ChanInvitationUpdateWithoutChanInput, ChanInvitationUncheckedUpdateWithoutChanInput>
  }

  export type ChanInvitationUpdateManyWithWhereWithoutChanInput = {
    where: ChanInvitationScalarWhereInput
    data: XOR<ChanInvitationUpdateManyMutationInput, ChanInvitationUncheckedUpdateManyWithoutInvitationsInput>
  }

  export type ChanDiscussionElementUpsertWithWhereUniqueWithoutChanInput = {
    where: ChanDiscussionElementWhereUniqueInput
    update: XOR<ChanDiscussionElementUpdateWithoutChanInput, ChanDiscussionElementUncheckedUpdateWithoutChanInput>
    create: XOR<ChanDiscussionElementCreateWithoutChanInput, ChanDiscussionElementUncheckedCreateWithoutChanInput>
  }

  export type ChanDiscussionElementUpdateWithWhereUniqueWithoutChanInput = {
    where: ChanDiscussionElementWhereUniqueInput
    data: XOR<ChanDiscussionElementUpdateWithoutChanInput, ChanDiscussionElementUncheckedUpdateWithoutChanInput>
  }

  export type ChanDiscussionElementUpdateManyWithWhereWithoutChanInput = {
    where: ChanDiscussionElementScalarWhereInput
    data: XOR<ChanDiscussionElementUpdateManyMutationInput, ChanDiscussionElementUncheckedUpdateManyWithoutElementsInput>
  }

  export type UserCreateWithoutMutedUserChanInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
  }

  export type UserUncheckedCreateWithoutMutedUserChanInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
  }

  export type UserCreateOrConnectWithoutMutedUserChanInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMutedUserChanInput, UserUncheckedCreateWithoutMutedUserChanInput>
  }

  export type ChanCreateWithoutMutedUsersInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    users?: UserCreateNestedManyWithoutChansInput
    roles?: RoleCreateNestedManyWithoutChanInput
    owner: UserCreateNestedOneWithoutOwnedChansInput
    invitations?: ChanInvitationCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementCreateNestedManyWithoutChanInput
  }

  export type ChanUncheckedCreateWithoutMutedUsersInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    ownerName: string
    users?: UserUncheckedCreateNestedManyWithoutChansInput
    roles?: RoleUncheckedCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationUncheckedCreateNestedManyWithoutChanInput
    elements?: ChanDiscussionElementUncheckedCreateNestedManyWithoutChanInput
  }

  export type ChanCreateOrConnectWithoutMutedUsersInput = {
    where: ChanWhereUniqueInput
    create: XOR<ChanCreateWithoutMutedUsersInput, ChanUncheckedCreateWithoutMutedUsersInput>
  }

  export type UserUpsertWithoutMutedUserChanInput = {
    update: XOR<UserUpdateWithoutMutedUserChanInput, UserUncheckedUpdateWithoutMutedUserChanInput>
    create: XOR<UserCreateWithoutMutedUserChanInput, UserUncheckedCreateWithoutMutedUserChanInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMutedUserChanInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMutedUserChanInput, UserUncheckedUpdateWithoutMutedUserChanInput>
  }

  export type UserUpdateWithoutMutedUserChanInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutMutedUserChanInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
  }

  export type ChanUpsertWithoutMutedUsersInput = {
    update: XOR<ChanUpdateWithoutMutedUsersInput, ChanUncheckedUpdateWithoutMutedUsersInput>
    create: XOR<ChanCreateWithoutMutedUsersInput, ChanUncheckedCreateWithoutMutedUsersInput>
    where?: ChanWhereInput
  }

  export type ChanUpdateToOneWithWhereWithoutMutedUsersInput = {
    where?: ChanWhereInput
    data: XOR<ChanUpdateWithoutMutedUsersInput, ChanUncheckedUpdateWithoutMutedUsersInput>
  }

  export type ChanUpdateWithoutMutedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutChansNestedInput
    roles?: RoleUpdateManyWithoutChanNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedChansNestedInput
    invitations?: ChanInvitationUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUpdateManyWithoutChanNestedInput
  }

  export type ChanUncheckedUpdateWithoutMutedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerName?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutChansNestedInput
    roles?: RoleUncheckedUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUncheckedUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUncheckedUpdateManyWithoutChanNestedInput
  }

  export type ChanDiscussionMessageCreateWithoutDiscussionElementInput = {
    id?: string
    content: string
    relatedUsers?: UserCreateNestedManyWithoutChanDiscussionMessageInput
    relatedRoles?: RoleCreateNestedManyWithoutRelatedDiscussionMessageInput
    related?: ChanDiscussionElementCreateNestedOneWithoutRelatedOfInput
  }

  export type ChanDiscussionMessageUncheckedCreateWithoutDiscussionElementInput = {
    id?: string
    content: string
    relatedTo?: string | null
    relatedUsers?: UserUncheckedCreateNestedManyWithoutChanDiscussionMessageInput
    relatedRoles?: RoleUncheckedCreateNestedManyWithoutRelatedDiscussionMessageInput
  }

  export type ChanDiscussionMessageCreateOrConnectWithoutDiscussionElementInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    create: XOR<ChanDiscussionMessageCreateWithoutDiscussionElementInput, ChanDiscussionMessageUncheckedCreateWithoutDiscussionElementInput>
  }

  export type ChanDiscussionEventCreateWithoutDiscussionElementInput = {
    id?: string
    concernedUser?: UserCreateNestedOneWithoutChanDiscussionEventInput
    classicChanDiscussionEvent?: ClassicChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
  }

  export type ChanDiscussionEventUncheckedCreateWithoutDiscussionElementInput = {
    id?: string
    concernedUserName?: string | null
    classicChanDiscussionEventId?: string | null
    changedTitleChanDiscussionEventId?: string | null
    deletedMessageChanDiscussionEventId?: string | null
  }

  export type ChanDiscussionEventCreateOrConnectWithoutDiscussionElementInput = {
    where: ChanDiscussionEventWhereUniqueInput
    create: XOR<ChanDiscussionEventCreateWithoutDiscussionElementInput, ChanDiscussionEventUncheckedCreateWithoutDiscussionElementInput>
  }

  export type ChanDiscussionMessageCreateWithoutRelatedInput = {
    id?: string
    content: string
    relatedUsers?: UserCreateNestedManyWithoutChanDiscussionMessageInput
    relatedRoles?: RoleCreateNestedManyWithoutRelatedDiscussionMessageInput
    discussionElement?: ChanDiscussionElementCreateNestedOneWithoutMessageInput
  }

  export type ChanDiscussionMessageUncheckedCreateWithoutRelatedInput = {
    id?: string
    content: string
    relatedUsers?: UserUncheckedCreateNestedManyWithoutChanDiscussionMessageInput
    relatedRoles?: RoleUncheckedCreateNestedManyWithoutRelatedDiscussionMessageInput
    discussionElement?: ChanDiscussionElementUncheckedCreateNestedOneWithoutMessageInput
  }

  export type ChanDiscussionMessageCreateOrConnectWithoutRelatedInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    create: XOR<ChanDiscussionMessageCreateWithoutRelatedInput, ChanDiscussionMessageUncheckedCreateWithoutRelatedInput>
  }

  export type ChanDiscussionMessageCreateManyRelatedInputEnvelope = {
    data: Enumerable<ChanDiscussionMessageCreateManyRelatedInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutChanDiscussionElementInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutChanDiscussionElementInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutChanDiscussionElementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChanDiscussionElementInput, UserUncheckedCreateWithoutChanDiscussionElementInput>
  }

  export type ChanCreateWithoutElementsInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    users?: UserCreateNestedManyWithoutChansInput
    roles?: RoleCreateNestedManyWithoutChanInput
    owner: UserCreateNestedOneWithoutOwnedChansInput
    mutedUsers?: MutedUserChanCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationCreateNestedManyWithoutChanInput
  }

  export type ChanUncheckedCreateWithoutElementsInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    ownerName: string
    users?: UserUncheckedCreateNestedManyWithoutChansInput
    roles?: RoleUncheckedCreateNestedManyWithoutChanInput
    mutedUsers?: MutedUserChanUncheckedCreateNestedManyWithoutChanInput
    invitations?: ChanInvitationUncheckedCreateNestedManyWithoutChanInput
  }

  export type ChanCreateOrConnectWithoutElementsInput = {
    where: ChanWhereUniqueInput
    create: XOR<ChanCreateWithoutElementsInput, ChanUncheckedCreateWithoutElementsInput>
  }

  export type ChanDiscussionMessageUpsertWithoutDiscussionElementInput = {
    update: XOR<ChanDiscussionMessageUpdateWithoutDiscussionElementInput, ChanDiscussionMessageUncheckedUpdateWithoutDiscussionElementInput>
    create: XOR<ChanDiscussionMessageCreateWithoutDiscussionElementInput, ChanDiscussionMessageUncheckedCreateWithoutDiscussionElementInput>
    where?: ChanDiscussionMessageWhereInput
  }

  export type ChanDiscussionMessageUpdateToOneWithWhereWithoutDiscussionElementInput = {
    where?: ChanDiscussionMessageWhereInput
    data: XOR<ChanDiscussionMessageUpdateWithoutDiscussionElementInput, ChanDiscussionMessageUncheckedUpdateWithoutDiscussionElementInput>
  }

  export type ChanDiscussionMessageUpdateWithoutDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedUsers?: UserUpdateManyWithoutChanDiscussionMessageNestedInput
    relatedRoles?: RoleUpdateManyWithoutRelatedDiscussionMessageNestedInput
    related?: ChanDiscussionElementUpdateOneWithoutRelatedOfNestedInput
  }

  export type ChanDiscussionMessageUncheckedUpdateWithoutDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsers?: UserUncheckedUpdateManyWithoutChanDiscussionMessageNestedInput
    relatedRoles?: RoleUncheckedUpdateManyWithoutRelatedDiscussionMessageNestedInput
  }

  export type ChanDiscussionEventUpsertWithoutDiscussionElementInput = {
    update: XOR<ChanDiscussionEventUpdateWithoutDiscussionElementInput, ChanDiscussionEventUncheckedUpdateWithoutDiscussionElementInput>
    create: XOR<ChanDiscussionEventCreateWithoutDiscussionElementInput, ChanDiscussionEventUncheckedCreateWithoutDiscussionElementInput>
    where?: ChanDiscussionEventWhereInput
  }

  export type ChanDiscussionEventUpdateToOneWithWhereWithoutDiscussionElementInput = {
    where?: ChanDiscussionEventWhereInput
    data: XOR<ChanDiscussionEventUpdateWithoutDiscussionElementInput, ChanDiscussionEventUncheckedUpdateWithoutDiscussionElementInput>
  }

  export type ChanDiscussionEventUpdateWithoutDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUser?: UserUpdateOneWithoutChanDiscussionEventNestedInput
    classicChanDiscussionEvent?: ClassicChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
  }

  export type ChanDiscussionEventUncheckedUpdateWithoutDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    classicChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    changedTitleChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedMessageChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChanDiscussionMessageUpsertWithWhereUniqueWithoutRelatedInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    update: XOR<ChanDiscussionMessageUpdateWithoutRelatedInput, ChanDiscussionMessageUncheckedUpdateWithoutRelatedInput>
    create: XOR<ChanDiscussionMessageCreateWithoutRelatedInput, ChanDiscussionMessageUncheckedCreateWithoutRelatedInput>
  }

  export type ChanDiscussionMessageUpdateWithWhereUniqueWithoutRelatedInput = {
    where: ChanDiscussionMessageWhereUniqueInput
    data: XOR<ChanDiscussionMessageUpdateWithoutRelatedInput, ChanDiscussionMessageUncheckedUpdateWithoutRelatedInput>
  }

  export type ChanDiscussionMessageUpdateManyWithWhereWithoutRelatedInput = {
    where: ChanDiscussionMessageScalarWhereInput
    data: XOR<ChanDiscussionMessageUpdateManyMutationInput, ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedOfInput>
  }

  export type UserUpsertWithoutChanDiscussionElementInput = {
    update: XOR<UserUpdateWithoutChanDiscussionElementInput, UserUncheckedUpdateWithoutChanDiscussionElementInput>
    create: XOR<UserCreateWithoutChanDiscussionElementInput, UserUncheckedCreateWithoutChanDiscussionElementInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChanDiscussionElementInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChanDiscussionElementInput, UserUncheckedUpdateWithoutChanDiscussionElementInput>
  }

  export type UserUpdateWithoutChanDiscussionElementInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChanDiscussionElementInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type ChanUpsertWithoutElementsInput = {
    update: XOR<ChanUpdateWithoutElementsInput, ChanUncheckedUpdateWithoutElementsInput>
    create: XOR<ChanCreateWithoutElementsInput, ChanUncheckedCreateWithoutElementsInput>
    where?: ChanWhereInput
  }

  export type ChanUpdateToOneWithWhereWithoutElementsInput = {
    where?: ChanWhereInput
    data: XOR<ChanUpdateWithoutElementsInput, ChanUncheckedUpdateWithoutElementsInput>
  }

  export type ChanUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutChansNestedInput
    roles?: RoleUpdateManyWithoutChanNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedChansNestedInput
    mutedUsers?: MutedUserChanUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUpdateManyWithoutChanNestedInput
  }

  export type ChanUncheckedUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerName?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutChansNestedInput
    roles?: RoleUncheckedUpdateManyWithoutChanNestedInput
    mutedUsers?: MutedUserChanUncheckedUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUncheckedUpdateManyWithoutChanNestedInput
  }

  export type UserCreateWithoutChanDiscussionMessageInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutChanDiscussionMessageInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutChanDiscussionMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChanDiscussionMessageInput, UserUncheckedCreateWithoutChanDiscussionMessageInput>
  }

  export type RoleCreateWithoutRelatedDiscussionMessageInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    roles?: RoleCreateNestedManyWithoutRolesSymInput
    rolesSym?: RoleCreateNestedManyWithoutRolesInput
    users?: UserCreateNestedManyWithoutRolesInput
    chan: ChanCreateNestedOneWithoutRolesInput
  }

  export type RoleUncheckedCreateWithoutRelatedDiscussionMessageInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
    chanId: string
    roles?: RoleUncheckedCreateNestedManyWithoutRolesSymInput
    rolesSym?: RoleUncheckedCreateNestedManyWithoutRolesInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RoleCreateOrConnectWithoutRelatedDiscussionMessageInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRelatedDiscussionMessageInput, RoleUncheckedCreateWithoutRelatedDiscussionMessageInput>
  }

  export type ChanDiscussionElementCreateWithoutRelatedOfInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: ChanDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    event?: ChanDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    author: UserCreateNestedOneWithoutChanDiscussionElementInput
    chan: ChanCreateNestedOneWithoutElementsInput
  }

  export type ChanDiscussionElementUncheckedCreateWithoutRelatedOfInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    authorName: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
  }

  export type ChanDiscussionElementCreateOrConnectWithoutRelatedOfInput = {
    where: ChanDiscussionElementWhereUniqueInput
    create: XOR<ChanDiscussionElementCreateWithoutRelatedOfInput, ChanDiscussionElementUncheckedCreateWithoutRelatedOfInput>
  }

  export type ChanDiscussionElementCreateWithoutMessageInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    event?: ChanDiscussionEventCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: ChanDiscussionMessageCreateNestedManyWithoutRelatedInput
    author: UserCreateNestedOneWithoutChanDiscussionElementInput
    chan: ChanCreateNestedOneWithoutElementsInput
  }

  export type ChanDiscussionElementUncheckedCreateWithoutMessageInput = {
    id?: string
    eventId?: string | null
    authorName: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    relatedOf?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type ChanDiscussionElementCreateOrConnectWithoutMessageInput = {
    where: ChanDiscussionElementWhereUniqueInput
    create: XOR<ChanDiscussionElementCreateWithoutMessageInput, ChanDiscussionElementUncheckedCreateWithoutMessageInput>
  }

  export type UserUpsertWithWhereUniqueWithoutChanDiscussionMessageInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutChanDiscussionMessageInput, UserUncheckedUpdateWithoutChanDiscussionMessageInput>
    create: XOR<UserCreateWithoutChanDiscussionMessageInput, UserUncheckedCreateWithoutChanDiscussionMessageInput>
  }

  export type UserUpdateWithWhereUniqueWithoutChanDiscussionMessageInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutChanDiscussionMessageInput, UserUncheckedUpdateWithoutChanDiscussionMessageInput>
  }

  export type UserUpdateManyWithWhereWithoutChanDiscussionMessageInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRelatedUsersInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutRelatedDiscussionMessageInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutRelatedDiscussionMessageInput, RoleUncheckedUpdateWithoutRelatedDiscussionMessageInput>
    create: XOR<RoleCreateWithoutRelatedDiscussionMessageInput, RoleUncheckedCreateWithoutRelatedDiscussionMessageInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutRelatedDiscussionMessageInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutRelatedDiscussionMessageInput, RoleUncheckedUpdateWithoutRelatedDiscussionMessageInput>
  }

  export type RoleUpdateManyWithWhereWithoutRelatedDiscussionMessageInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRelatedRolesInput>
  }

  export type ChanDiscussionElementUpsertWithoutRelatedOfInput = {
    update: XOR<ChanDiscussionElementUpdateWithoutRelatedOfInput, ChanDiscussionElementUncheckedUpdateWithoutRelatedOfInput>
    create: XOR<ChanDiscussionElementCreateWithoutRelatedOfInput, ChanDiscussionElementUncheckedCreateWithoutRelatedOfInput>
    where?: ChanDiscussionElementWhereInput
  }

  export type ChanDiscussionElementUpdateToOneWithWhereWithoutRelatedOfInput = {
    where?: ChanDiscussionElementWhereInput
    data: XOR<ChanDiscussionElementUpdateWithoutRelatedOfInput, ChanDiscussionElementUncheckedUpdateWithoutRelatedOfInput>
  }

  export type ChanDiscussionElementUpdateWithoutRelatedOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: ChanDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    event?: ChanDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    author?: UserUpdateOneRequiredWithoutChanDiscussionElementNestedInput
    chan?: ChanUpdateOneRequiredWithoutElementsNestedInput
  }

  export type ChanDiscussionElementUncheckedUpdateWithoutRelatedOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type ChanDiscussionElementUpsertWithoutMessageInput = {
    update: XOR<ChanDiscussionElementUpdateWithoutMessageInput, ChanDiscussionElementUncheckedUpdateWithoutMessageInput>
    create: XOR<ChanDiscussionElementCreateWithoutMessageInput, ChanDiscussionElementUncheckedCreateWithoutMessageInput>
    where?: ChanDiscussionElementWhereInput
  }

  export type ChanDiscussionElementUpdateToOneWithWhereWithoutMessageInput = {
    where?: ChanDiscussionElementWhereInput
    data: XOR<ChanDiscussionElementUpdateWithoutMessageInput, ChanDiscussionElementUncheckedUpdateWithoutMessageInput>
  }

  export type ChanDiscussionElementUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: ChanDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: ChanDiscussionMessageUpdateManyWithoutRelatedNestedInput
    author?: UserUpdateOneRequiredWithoutChanDiscussionElementNestedInput
    chan?: ChanUpdateOneRequiredWithoutElementsNestedInput
  }

  export type ChanDiscussionElementUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    relatedOf?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type UserCreateWithoutChanDiscussionEventInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutChanDiscussionEventInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedCreateNestedManyWithoutDeletingUsersInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutChanDiscussionEventInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChanDiscussionEventInput, UserUncheckedCreateWithoutChanDiscussionEventInput>
  }

  export type ClassicChanDiscussionEventCreateWithoutChanDiscussionEventInput = {
    id?: string
    eventType: ClassicChanEventType
  }

  export type ClassicChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput = {
    id?: string
    eventType: ClassicChanEventType
  }

  export type ClassicChanDiscussionEventCreateOrConnectWithoutChanDiscussionEventInput = {
    where: ClassicChanDiscussionEventWhereUniqueInput
    create: XOR<ClassicChanDiscussionEventCreateWithoutChanDiscussionEventInput, ClassicChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
  }

  export type ChangedTitleChanDiscussionEventCreateWithoutChanDiscussionEventInput = {
    id?: string
    oldTitle: string
    newTitle: string
  }

  export type ChangedTitleChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput = {
    id?: string
    oldTitle: string
    newTitle: string
  }

  export type ChangedTitleChanDiscussionEventCreateOrConnectWithoutChanDiscussionEventInput = {
    where: ChangedTitleChanDiscussionEventWhereUniqueInput
    create: XOR<ChangedTitleChanDiscussionEventCreateWithoutChanDiscussionEventInput, ChangedTitleChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
  }

  export type DeletedMessageChanDiscussionEventCreateWithoutChanDiscussionEventInput = {
    id?: string
    deletingUsers: UserCreateNestedOneWithoutDeletedMessageChanDiscussionEventInput
  }

  export type DeletedMessageChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput = {
    id?: string
    deletingUserName: string
  }

  export type DeletedMessageChanDiscussionEventCreateOrConnectWithoutChanDiscussionEventInput = {
    where: DeletedMessageChanDiscussionEventWhereUniqueInput
    create: XOR<DeletedMessageChanDiscussionEventCreateWithoutChanDiscussionEventInput, DeletedMessageChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
  }

  export type ChanDiscussionElementCreateWithoutEventInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    message?: ChanDiscussionMessageCreateNestedOneWithoutDiscussionElementInput
    relatedOf?: ChanDiscussionMessageCreateNestedManyWithoutRelatedInput
    author: UserCreateNestedOneWithoutChanDiscussionElementInput
    chan: ChanCreateNestedOneWithoutElementsInput
  }

  export type ChanDiscussionElementUncheckedCreateWithoutEventInput = {
    id?: string
    messageId?: string | null
    authorName: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    relatedOf?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedInput
  }

  export type ChanDiscussionElementCreateOrConnectWithoutEventInput = {
    where: ChanDiscussionElementWhereUniqueInput
    create: XOR<ChanDiscussionElementCreateWithoutEventInput, ChanDiscussionElementUncheckedCreateWithoutEventInput>
  }

  export type UserUpsertWithoutChanDiscussionEventInput = {
    update: XOR<UserUpdateWithoutChanDiscussionEventInput, UserUncheckedUpdateWithoutChanDiscussionEventInput>
    create: XOR<UserCreateWithoutChanDiscussionEventInput, UserUncheckedCreateWithoutChanDiscussionEventInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChanDiscussionEventInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChanDiscussionEventInput, UserUncheckedUpdateWithoutChanDiscussionEventInput>
  }

  export type UserUpdateWithoutChanDiscussionEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChanDiscussionEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type ClassicChanDiscussionEventUpsertWithoutChanDiscussionEventInput = {
    update: XOR<ClassicChanDiscussionEventUpdateWithoutChanDiscussionEventInput, ClassicChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput>
    create: XOR<ClassicChanDiscussionEventCreateWithoutChanDiscussionEventInput, ClassicChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
    where?: ClassicChanDiscussionEventWhereInput
  }

  export type ClassicChanDiscussionEventUpdateToOneWithWhereWithoutChanDiscussionEventInput = {
    where?: ClassicChanDiscussionEventWhereInput
    data: XOR<ClassicChanDiscussionEventUpdateWithoutChanDiscussionEventInput, ClassicChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput>
  }

  export type ClassicChanDiscussionEventUpdateWithoutChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicChanEventTypeFieldUpdateOperationsInput | ClassicChanEventType
  }

  export type ClassicChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumClassicChanEventTypeFieldUpdateOperationsInput | ClassicChanEventType
  }

  export type ChangedTitleChanDiscussionEventUpsertWithoutChanDiscussionEventInput = {
    update: XOR<ChangedTitleChanDiscussionEventUpdateWithoutChanDiscussionEventInput, ChangedTitleChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput>
    create: XOR<ChangedTitleChanDiscussionEventCreateWithoutChanDiscussionEventInput, ChangedTitleChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
    where?: ChangedTitleChanDiscussionEventWhereInput
  }

  export type ChangedTitleChanDiscussionEventUpdateToOneWithWhereWithoutChanDiscussionEventInput = {
    where?: ChangedTitleChanDiscussionEventWhereInput
    data: XOR<ChangedTitleChanDiscussionEventUpdateWithoutChanDiscussionEventInput, ChangedTitleChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput>
  }

  export type ChangedTitleChanDiscussionEventUpdateWithoutChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldTitle?: StringFieldUpdateOperationsInput | string
    newTitle?: StringFieldUpdateOperationsInput | string
  }

  export type ChangedTitleChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldTitle?: StringFieldUpdateOperationsInput | string
    newTitle?: StringFieldUpdateOperationsInput | string
  }

  export type DeletedMessageChanDiscussionEventUpsertWithoutChanDiscussionEventInput = {
    update: XOR<DeletedMessageChanDiscussionEventUpdateWithoutChanDiscussionEventInput, DeletedMessageChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput>
    create: XOR<DeletedMessageChanDiscussionEventCreateWithoutChanDiscussionEventInput, DeletedMessageChanDiscussionEventUncheckedCreateWithoutChanDiscussionEventInput>
    where?: DeletedMessageChanDiscussionEventWhereInput
  }

  export type DeletedMessageChanDiscussionEventUpdateToOneWithWhereWithoutChanDiscussionEventInput = {
    where?: DeletedMessageChanDiscussionEventWhereInput
    data: XOR<DeletedMessageChanDiscussionEventUpdateWithoutChanDiscussionEventInput, DeletedMessageChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput>
  }

  export type DeletedMessageChanDiscussionEventUpdateWithoutChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletingUsers?: UserUpdateOneRequiredWithoutDeletedMessageChanDiscussionEventNestedInput
  }

  export type DeletedMessageChanDiscussionEventUncheckedUpdateWithoutChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletingUserName?: StringFieldUpdateOperationsInput | string
  }

  export type ChanDiscussionElementUpsertWithoutEventInput = {
    update: XOR<ChanDiscussionElementUpdateWithoutEventInput, ChanDiscussionElementUncheckedUpdateWithoutEventInput>
    create: XOR<ChanDiscussionElementCreateWithoutEventInput, ChanDiscussionElementUncheckedCreateWithoutEventInput>
    where?: ChanDiscussionElementWhereInput
  }

  export type ChanDiscussionElementUpdateToOneWithWhereWithoutEventInput = {
    where?: ChanDiscussionElementWhereInput
    data: XOR<ChanDiscussionElementUpdateWithoutEventInput, ChanDiscussionElementUncheckedUpdateWithoutEventInput>
  }

  export type ChanDiscussionElementUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: ChanDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: ChanDiscussionMessageUpdateManyWithoutRelatedNestedInput
    author?: UserUpdateOneRequiredWithoutChanDiscussionElementNestedInput
    chan?: ChanUpdateOneRequiredWithoutElementsNestedInput
  }

  export type ChanDiscussionElementUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    relatedOf?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type ChanDiscussionEventCreateWithoutChangedTitleChanDiscussionEventInput = {
    id?: string
    concernedUser?: UserCreateNestedOneWithoutChanDiscussionEventInput
    classicChanDiscussionEvent?: ClassicChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    discussionElement?: ChanDiscussionElementCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventUncheckedCreateWithoutChangedTitleChanDiscussionEventInput = {
    id?: string
    concernedUserName?: string | null
    classicChanDiscussionEventId?: string | null
    deletedMessageChanDiscussionEventId?: string | null
    discussionElement?: ChanDiscussionElementUncheckedCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventCreateOrConnectWithoutChangedTitleChanDiscussionEventInput = {
    where: ChanDiscussionEventWhereUniqueInput
    create: XOR<ChanDiscussionEventCreateWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutChangedTitleChanDiscussionEventInput>
  }

  export type ChanDiscussionEventUpsertWithoutChangedTitleChanDiscussionEventInput = {
    update: XOR<ChanDiscussionEventUpdateWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUncheckedUpdateWithoutChangedTitleChanDiscussionEventInput>
    create: XOR<ChanDiscussionEventCreateWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutChangedTitleChanDiscussionEventInput>
    where?: ChanDiscussionEventWhereInput
  }

  export type ChanDiscussionEventUpdateToOneWithWhereWithoutChangedTitleChanDiscussionEventInput = {
    where?: ChanDiscussionEventWhereInput
    data: XOR<ChanDiscussionEventUpdateWithoutChangedTitleChanDiscussionEventInput, ChanDiscussionEventUncheckedUpdateWithoutChangedTitleChanDiscussionEventInput>
  }

  export type ChanDiscussionEventUpdateWithoutChangedTitleChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUser?: UserUpdateOneWithoutChanDiscussionEventNestedInput
    classicChanDiscussionEvent?: ClassicChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    discussionElement?: ChanDiscussionElementUpdateOneWithoutEventNestedInput
  }

  export type ChanDiscussionEventUncheckedUpdateWithoutChangedTitleChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    classicChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedMessageChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    discussionElement?: ChanDiscussionElementUncheckedUpdateOneWithoutEventNestedInput
  }

  export type UserCreateWithoutDeletedMessageChanDiscussionEventInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageCreateNestedManyWithoutRequestedUserInput
    chans?: ChanCreateNestedManyWithoutUsersInput
    ownedChans?: ChanCreateNestedManyWithoutOwnerInput
    friend?: FriendShipCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventCreateNestedManyWithoutConcernedUserInput
    chanDiscussionMessage?: ChanDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanCreateNestedManyWithoutMutedUserInput
  }

  export type UserUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput = {
    name: string
    password: string
    dmPolicyLevel?: dmPolicyLevelType
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutRequestingUserInput
    directMessageOf?: DirectMessageUncheckedCreateNestedManyWithoutRequestedUserInput
    chans?: ChanUncheckedCreateNestedManyWithoutUsersInput
    ownedChans?: ChanUncheckedCreateNestedManyWithoutOwnerInput
    friend?: FriendShipUncheckedCreateNestedManyWithoutRequestingUserInput
    friendOf?: FriendShipUncheckedCreateNestedManyWithoutRequestedUserInput
    outcomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingFriendInvitation?: FriendInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    outcomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitingUserInput
    incomingChanInvitation?: ChanInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    blockedUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockingUserInput
    blockedByUser?: BlockedShipUncheckedCreateNestedManyWithoutBlockedUserInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedCreateNestedManyWithoutAuthorInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedCreateNestedManyWithoutConcernedUserInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    dmDiscussionElement?: DmDiscussionElementUncheckedCreateNestedManyWithoutAuthorRelationInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedCreateNestedManyWithoutRelatedUsersInput
    mutedUserChan?: MutedUserChanUncheckedCreateNestedManyWithoutMutedUserInput
  }

  export type UserCreateOrConnectWithoutDeletedMessageChanDiscussionEventInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeletedMessageChanDiscussionEventInput, UserUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
  }

  export type ChanDiscussionEventCreateWithoutDeletedMessageChanDiscussionEventInput = {
    id?: string
    concernedUser?: UserCreateNestedOneWithoutChanDiscussionEventInput
    classicChanDiscussionEvent?: ClassicChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    discussionElement?: ChanDiscussionElementCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput = {
    id?: string
    concernedUserName?: string | null
    classicChanDiscussionEventId?: string | null
    changedTitleChanDiscussionEventId?: string | null
    discussionElement?: ChanDiscussionElementUncheckedCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventCreateOrConnectWithoutDeletedMessageChanDiscussionEventInput = {
    where: ChanDiscussionEventWhereUniqueInput
    create: XOR<ChanDiscussionEventCreateWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
  }

  export type UserUpsertWithoutDeletedMessageChanDiscussionEventInput = {
    update: XOR<UserUpdateWithoutDeletedMessageChanDiscussionEventInput, UserUncheckedUpdateWithoutDeletedMessageChanDiscussionEventInput>
    create: XOR<UserCreateWithoutDeletedMessageChanDiscussionEventInput, UserUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeletedMessageChanDiscussionEventInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeletedMessageChanDiscussionEventInput, UserUncheckedUpdateWithoutDeletedMessageChanDiscussionEventInput>
  }

  export type UserUpdateWithoutDeletedMessageChanDiscussionEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeletedMessageChanDiscussionEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type ChanDiscussionEventUpsertWithoutDeletedMessageChanDiscussionEventInput = {
    update: XOR<ChanDiscussionEventUpdateWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUncheckedUpdateWithoutDeletedMessageChanDiscussionEventInput>
    create: XOR<ChanDiscussionEventCreateWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutDeletedMessageChanDiscussionEventInput>
    where?: ChanDiscussionEventWhereInput
  }

  export type ChanDiscussionEventUpdateToOneWithWhereWithoutDeletedMessageChanDiscussionEventInput = {
    where?: ChanDiscussionEventWhereInput
    data: XOR<ChanDiscussionEventUpdateWithoutDeletedMessageChanDiscussionEventInput, ChanDiscussionEventUncheckedUpdateWithoutDeletedMessageChanDiscussionEventInput>
  }

  export type ChanDiscussionEventUpdateWithoutDeletedMessageChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUser?: UserUpdateOneWithoutChanDiscussionEventNestedInput
    classicChanDiscussionEvent?: ClassicChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    discussionElement?: ChanDiscussionElementUpdateOneWithoutEventNestedInput
  }

  export type ChanDiscussionEventUncheckedUpdateWithoutDeletedMessageChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    classicChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    changedTitleChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    discussionElement?: ChanDiscussionElementUncheckedUpdateOneWithoutEventNestedInput
  }

  export type ChanDiscussionEventCreateWithoutClassicChanDiscussionEventInput = {
    id?: string
    concernedUser?: UserCreateNestedOneWithoutChanDiscussionEventInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventCreateNestedOneWithoutChanDiscussionEventInput
    discussionElement?: ChanDiscussionElementCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventUncheckedCreateWithoutClassicChanDiscussionEventInput = {
    id?: string
    concernedUserName?: string | null
    changedTitleChanDiscussionEventId?: string | null
    deletedMessageChanDiscussionEventId?: string | null
    discussionElement?: ChanDiscussionElementUncheckedCreateNestedOneWithoutEventInput
  }

  export type ChanDiscussionEventCreateOrConnectWithoutClassicChanDiscussionEventInput = {
    where: ChanDiscussionEventWhereUniqueInput
    create: XOR<ChanDiscussionEventCreateWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutClassicChanDiscussionEventInput>
  }

  export type ChanDiscussionEventUpsertWithoutClassicChanDiscussionEventInput = {
    update: XOR<ChanDiscussionEventUpdateWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUncheckedUpdateWithoutClassicChanDiscussionEventInput>
    create: XOR<ChanDiscussionEventCreateWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUncheckedCreateWithoutClassicChanDiscussionEventInput>
    where?: ChanDiscussionEventWhereInput
  }

  export type ChanDiscussionEventUpdateToOneWithWhereWithoutClassicChanDiscussionEventInput = {
    where?: ChanDiscussionEventWhereInput
    data: XOR<ChanDiscussionEventUpdateWithoutClassicChanDiscussionEventInput, ChanDiscussionEventUncheckedUpdateWithoutClassicChanDiscussionEventInput>
  }

  export type ChanDiscussionEventUpdateWithoutClassicChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUser?: UserUpdateOneWithoutChanDiscussionEventNestedInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    discussionElement?: ChanDiscussionElementUpdateOneWithoutEventNestedInput
  }

  export type ChanDiscussionEventUncheckedUpdateWithoutClassicChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    concernedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    changedTitleChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedMessageChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    discussionElement?: ChanDiscussionElementUncheckedUpdateOneWithoutEventNestedInput
  }

  export type RoleUpdateWithoutRolesSymInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    roles?: RoleUpdateManyWithoutRolesSymNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
    chan?: ChanUpdateOneRequiredWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolesSymInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    chanId?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutRolesSymNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedRolesNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    rolesSym?: RoleUpdateManyWithoutRolesNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
    chan?: ChanUpdateOneRequiredWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    chanId?: StringFieldUpdateOperationsInput | string
    rolesSym?: RoleUncheckedUpdateManyWithoutRolesNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedRolesNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutRolesSymInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
  }

  export type ChanDiscussionMessageUpdateWithoutRelatedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedUsers?: UserUpdateManyWithoutChanDiscussionMessageNestedInput
    related?: ChanDiscussionElementUpdateOneWithoutRelatedOfNestedInput
    discussionElement?: ChanDiscussionElementUpdateOneWithoutMessageNestedInput
  }

  export type ChanDiscussionMessageUncheckedUpdateWithoutRelatedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsers?: UserUncheckedUpdateManyWithoutChanDiscussionMessageNestedInput
    discussionElement?: ChanDiscussionElementUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedDiscussionMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DirectMessageCreateManyRequestingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserName: string
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
  }

  export type DirectMessageCreateManyRequestedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserName: string
    requestingUserStatus?: DirectMessageUserStatus
    requestingUserStatusMutedUntil?: Date | string | null
    requestedUserStatus?: DirectMessageUserStatus
    requestedUserStatusMutedUntil?: Date | string | null
    status?: DirectMessageStatus
  }

  export type ChanCreateManyOwnerInput = {
    id?: string
    type: ChanType
    title?: string | null
    password?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
  }

  export type FriendShipCreateManyRequestingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestedUserName: string
  }

  export type FriendShipCreateManyRequestedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    requestingUserName: string
  }

  export type FriendInvitationCreateManyInvitingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    invitedUserName: string
    status?: FriendInvitationStatus
  }

  export type FriendInvitationCreateManyInvitedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    invitingUserName: string
    status?: FriendInvitationStatus
  }

  export type ChanInvitationCreateManyInvitingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    chanTitle: string
    invitedUserName: string
    status?: ChanInvitationStatus
  }

  export type ChanInvitationCreateManyInvitedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
    chanTitle: string
    invitingUserName: string
    status?: ChanInvitationStatus
  }

  export type BlockedShipCreateManyBlockingUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    blockedUserName: string
  }

  export type BlockedShipCreateManyBlockedUserInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    blockingUserName: string
  }

  export type ChanDiscussionElementCreateManyAuthorInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    chanId: string
  }

  export type ChanDiscussionEventCreateManyConcernedUserInput = {
    id?: string
    classicChanDiscussionEventId?: string | null
    changedTitleChanDiscussionEventId?: string | null
    deletedMessageChanDiscussionEventId?: string | null
  }

  export type DeletedMessageChanDiscussionEventCreateManyDeletingUsersInput = {
    id?: string
  }

  export type DmDiscussionElementCreateManyAuthorRelationInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    creationDate?: Date | string
    modificationDate?: Date | string | null
    directMessageId: string
  }

  export type MutedUserChanCreateManyMutedUserInput = {
    id?: string
    creationDate?: Date | string
    untilDate?: Date | string | null
    chanId: string
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    roles?: RoleUpdateManyWithoutRolesSymNestedInput
    rolesSym?: RoleUpdateManyWithoutRolesNestedInput
    chan?: ChanUpdateOneRequiredWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    chanId?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutRolesSymNestedInput
    rolesSym?: RoleUncheckedUpdateManyWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedRolesNestedInput
  }

  export type DirectMessageUpdateWithoutRequestingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
    requestedUser?: UserUpdateOneRequiredWithoutDirectMessageOfNestedInput
    elements?: DmDiscussionElementUpdateManyWithoutDirectMessageNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutRequestingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserName?: StringFieldUpdateOperationsInput | string
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
    elements?: DmDiscussionElementUncheckedUpdateManyWithoutDirectMessageNestedInput
  }

  export type DirectMessageUncheckedUpdateManyWithoutDirectMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserName?: StringFieldUpdateOperationsInput | string
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
  }

  export type DirectMessageUpdateWithoutRequestedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
    requestingUser?: UserUpdateOneRequiredWithoutDirectMessageNestedInput
    elements?: DmDiscussionElementUpdateManyWithoutDirectMessageNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutRequestedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserName?: StringFieldUpdateOperationsInput | string
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
    elements?: DmDiscussionElementUncheckedUpdateManyWithoutDirectMessageNestedInput
  }

  export type DirectMessageUncheckedUpdateManyWithoutDirectMessageOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserName?: StringFieldUpdateOperationsInput | string
    requestingUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestingUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserStatus?: EnumDirectMessageUserStatusFieldUpdateOperationsInput | DirectMessageUserStatus
    requestedUserStatusMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumDirectMessageStatusFieldUpdateOperationsInput | DirectMessageStatus
  }

  export type ChanUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: RoleUpdateManyWithoutChanNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedChansNestedInput
    mutedUsers?: MutedUserChanUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUpdateManyWithoutChanNestedInput
  }

  export type ChanUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerName?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutChanNestedInput
    mutedUsers?: MutedUserChanUncheckedUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUncheckedUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUncheckedUpdateManyWithoutChanNestedInput
  }

  export type ChanUncheckedUpdateManyWithoutChansInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerName?: StringFieldUpdateOperationsInput | string
  }

  export type ChanUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutChansNestedInput
    roles?: RoleUpdateManyWithoutChanNestedInput
    mutedUsers?: MutedUserChanUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUpdateManyWithoutChanNestedInput
  }

  export type ChanUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutChansNestedInput
    roles?: RoleUncheckedUpdateManyWithoutChanNestedInput
    mutedUsers?: MutedUserChanUncheckedUpdateManyWithoutChanNestedInput
    invitations?: ChanInvitationUncheckedUpdateManyWithoutChanNestedInput
    elements?: ChanDiscussionElementUncheckedUpdateManyWithoutChanNestedInput
  }

  export type ChanUncheckedUpdateManyWithoutOwnedChansInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChanTypeFieldUpdateOperationsInput | ChanType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FriendShipUpdateWithoutRequestingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUser?: UserUpdateOneRequiredWithoutFriendOfNestedInput
  }

  export type FriendShipUncheckedUpdateWithoutRequestingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type FriendShipUncheckedUpdateManyWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type FriendShipUpdateWithoutRequestedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUser?: UserUpdateOneRequiredWithoutFriendNestedInput
  }

  export type FriendShipUncheckedUpdateWithoutRequestedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserName?: StringFieldUpdateOperationsInput | string
  }

  export type FriendShipUncheckedUpdateManyWithoutFriendOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestingUserName?: StringFieldUpdateOperationsInput | string
  }

  export type FriendInvitationUpdateWithoutInvitingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
    invitedUser?: UserUpdateOneRequiredWithoutIncomingFriendInvitationNestedInput
  }

  export type FriendInvitationUncheckedUpdateWithoutInvitingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
  }

  export type FriendInvitationUncheckedUpdateManyWithoutOutcomingFriendInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
  }

  export type FriendInvitationUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
    invitingUser?: UserUpdateOneRequiredWithoutOutcomingFriendInvitationNestedInput
  }

  export type FriendInvitationUncheckedUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitingUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
  }

  export type FriendInvitationUncheckedUpdateManyWithoutIncomingFriendInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitingUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendInvitationStatusFieldUpdateOperationsInput | FriendInvitationStatus
  }

  export type ChanInvitationUpdateWithoutInvitingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
    chan?: ChanUpdateOneRequiredWithoutInvitationsNestedInput
    discussionEvent?: ChanInvitationDmDiscussionEventUpdateOneWithoutChanInvitationNestedInput
    invitedUser?: UserUpdateOneRequiredWithoutIncomingChanInvitationNestedInput
  }

  export type ChanInvitationUncheckedUpdateWithoutInvitingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    chanTitle?: StringFieldUpdateOperationsInput | string
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventUncheckedUpdateOneWithoutChanInvitationNestedInput
  }

  export type ChanInvitationUncheckedUpdateManyWithoutOutcomingChanInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    chanTitle?: StringFieldUpdateOperationsInput | string
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
  }

  export type ChanInvitationUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
    chan?: ChanUpdateOneRequiredWithoutInvitationsNestedInput
    discussionEvent?: ChanInvitationDmDiscussionEventUpdateOneWithoutChanInvitationNestedInput
    invitingUser?: UserUpdateOneRequiredWithoutOutcomingChanInvitationNestedInput
  }

  export type ChanInvitationUncheckedUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    chanTitle?: StringFieldUpdateOperationsInput | string
    invitingUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventUncheckedUpdateOneWithoutChanInvitationNestedInput
  }

  export type ChanInvitationUncheckedUpdateManyWithoutIncomingChanInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    chanTitle?: StringFieldUpdateOperationsInput | string
    invitingUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
  }

  export type BlockedShipUpdateWithoutBlockingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedUser?: UserUpdateOneRequiredWithoutBlockedByUserNestedInput
  }

  export type BlockedShipUncheckedUpdateWithoutBlockingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type BlockedShipUncheckedUpdateManyWithoutBlockedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type BlockedShipUpdateWithoutBlockedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockingUser?: UserUpdateOneRequiredWithoutBlockedUserNestedInput
  }

  export type BlockedShipUncheckedUpdateWithoutBlockedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockingUserName?: StringFieldUpdateOperationsInput | string
  }

  export type BlockedShipUncheckedUpdateManyWithoutBlockedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockingUserName?: StringFieldUpdateOperationsInput | string
  }

  export type ChanDiscussionElementUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: ChanDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    event?: ChanDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: ChanDiscussionMessageUpdateManyWithoutRelatedNestedInput
    chan?: ChanUpdateOneRequiredWithoutElementsNestedInput
  }

  export type ChanDiscussionElementUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
    relatedOf?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type ChanDiscussionElementUncheckedUpdateManyWithoutChanDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type ChanDiscussionEventUpdateWithoutConcernedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicChanDiscussionEvent?: ClassicChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    changedTitleChanDiscussionEvent?: ChangedTitleChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateOneWithoutChanDiscussionEventNestedInput
    discussionElement?: ChanDiscussionElementUpdateOneWithoutEventNestedInput
  }

  export type ChanDiscussionEventUncheckedUpdateWithoutConcernedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    changedTitleChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedMessageChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    discussionElement?: ChanDiscussionElementUncheckedUpdateOneWithoutEventNestedInput
  }

  export type ChanDiscussionEventUncheckedUpdateManyWithoutChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    classicChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    changedTitleChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedMessageChanDiscussionEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeletedMessageChanDiscussionEventUpdateWithoutDeletingUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    chanDiscussionEvent?: ChanDiscussionEventUpdateOneWithoutDeletedMessageChanDiscussionEventNestedInput
  }

  export type DeletedMessageChanDiscussionEventUncheckedUpdateWithoutDeletingUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateOneWithoutDeletedMessageChanDiscussionEventNestedInput
  }

  export type DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletedMessageChanDiscussionEventInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ChanDiscussionMessageUpdateWithoutRelatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedRoles?: RoleUpdateManyWithoutRelatedDiscussionMessageNestedInput
    related?: ChanDiscussionElementUpdateOneWithoutRelatedOfNestedInput
    discussionElement?: ChanDiscussionElementUpdateOneWithoutMessageNestedInput
  }

  export type ChanDiscussionMessageUncheckedUpdateWithoutRelatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
    relatedRoles?: RoleUncheckedUpdateManyWithoutRelatedDiscussionMessageNestedInput
    discussionElement?: ChanDiscussionElementUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type ChanDiscussionMessageUncheckedUpdateManyWithoutChanDiscussionMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DmDiscussionElementUpdateWithoutAuthorRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: DmDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    event?: DmDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: DmDiscussionMessageUpdateManyWithoutRelatedNestedInput
    directMessage?: DirectMessageUpdateOneRequiredWithoutElementsNestedInput
  }

  export type DmDiscussionElementUncheckedUpdateWithoutAuthorRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directMessageId?: StringFieldUpdateOperationsInput | string
    relatedOf?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type DmDiscussionElementUncheckedUpdateManyWithoutDmDiscussionElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directMessageId?: StringFieldUpdateOperationsInput | string
  }

  export type DmDiscussionMessageUpdateWithoutRelatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    related?: DmDiscussionElementUpdateOneWithoutRelatedOfNestedInput
    discussionElement?: DmDiscussionElementUpdateOneWithoutMessageNestedInput
  }

  export type DmDiscussionMessageUncheckedUpdateWithoutRelatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
    discussionElement?: DmDiscussionElementUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type DmDiscussionMessageUncheckedUpdateManyWithoutDmDiscussionMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MutedUserChanUpdateWithoutMutedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chan?: ChanUpdateOneRequiredWithoutMutedUsersNestedInput
  }

  export type MutedUserChanUncheckedUpdateWithoutMutedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type MutedUserChanUncheckedUpdateManyWithoutMutedUserChanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chanId?: StringFieldUpdateOperationsInput | string
  }

  export type DmDiscussionElementCreateManyDirectMessageInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    author: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
  }

  export type DmDiscussionElementUpdateWithoutDirectMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: DmDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    event?: DmDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: DmDiscussionMessageUpdateManyWithoutRelatedNestedInput
    authorRelation?: UserUpdateOneRequiredWithoutDmDiscussionElementNestedInput
  }

  export type DmDiscussionElementUncheckedUpdateWithoutDirectMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    author?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relatedOf?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type DmDiscussionElementUncheckedUpdateManyWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    author?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DmDiscussionMessageCreateManyRelatedInput = {
    id?: string
    content: string
  }

  export type DmDiscussionMessageUpdateWithoutRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedUsers?: UserUpdateManyWithoutDmDiscussionMessageNestedInput
    discussionElement?: DmDiscussionElementUpdateOneWithoutMessageNestedInput
  }

  export type DmDiscussionMessageUncheckedUpdateWithoutRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedUsers?: UserUncheckedUpdateManyWithoutDmDiscussionMessageNestedInput
    discussionElement?: DmDiscussionElementUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type DmDiscussionMessageUncheckedUpdateManyWithoutRelatedOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutDmDiscussionMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDmDiscussionMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRelatedUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
  }

  export type RoleCreateManyChanInput = {
    id?: string
    name: string
    permissions?: RoleCreatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn: RoleApplyingType
  }

  export type MutedUserChanCreateManyChanInput = {
    id?: string
    creationDate?: Date | string
    untilDate?: Date | string | null
    mutedUserName: string
  }

  export type ChanInvitationCreateManyChanInput = {
    id?: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
    invitingUserName: string
    invitedUserName: string
    status?: ChanInvitationStatus
  }

  export type ChanDiscussionElementCreateManyChanInput = {
    id?: string
    messageId?: string | null
    eventId?: string | null
    authorName: string
    creationDate?: Date | string
    modificationDate?: Date | string | null
  }

  export type UserUpdateWithoutChansInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChansInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    chanDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type RoleUpdateWithoutChanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    roles?: RoleUpdateManyWithoutRolesSymNestedInput
    rolesSym?: RoleUpdateManyWithoutRolesNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUpdateManyWithoutRelatedRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutChanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    roles?: RoleUncheckedUpdateManyWithoutRolesSymNestedInput
    rolesSym?: RoleUncheckedUpdateManyWithoutRolesNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    relatedDiscussionMessage?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedRolesNestedInput
  }

  export type MutedUserChanUpdateWithoutChanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mutedUser?: UserUpdateOneRequiredWithoutMutedUserChanNestedInput
  }

  export type MutedUserChanUncheckedUpdateWithoutChanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mutedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type MutedUserChanUncheckedUpdateManyWithoutMutedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    untilDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mutedUserName?: StringFieldUpdateOperationsInput | string
  }

  export type ChanInvitationUpdateWithoutChanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventUpdateOneWithoutChanInvitationNestedInput
    invitingUser?: UserUpdateOneRequiredWithoutOutcomingChanInvitationNestedInput
    invitedUser?: UserUpdateOneRequiredWithoutIncomingChanInvitationNestedInput
  }

  export type ChanInvitationUncheckedUpdateWithoutChanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitingUserName?: StringFieldUpdateOperationsInput | string
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
    discussionEvent?: ChanInvitationDmDiscussionEventUncheckedUpdateOneWithoutChanInvitationNestedInput
  }

  export type ChanInvitationUncheckedUpdateManyWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitingUserName?: StringFieldUpdateOperationsInput | string
    invitedUserName?: StringFieldUpdateOperationsInput | string
    status?: EnumChanInvitationStatusFieldUpdateOperationsInput | ChanInvitationStatus
  }

  export type ChanDiscussionElementUpdateWithoutChanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: ChanDiscussionMessageUpdateOneWithoutDiscussionElementNestedInput
    event?: ChanDiscussionEventUpdateOneWithoutDiscussionElementNestedInput
    relatedOf?: ChanDiscussionMessageUpdateManyWithoutRelatedNestedInput
    author?: UserUpdateOneRequiredWithoutChanDiscussionElementNestedInput
  }

  export type ChanDiscussionElementUncheckedUpdateWithoutChanInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relatedOf?: ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedNestedInput
  }

  export type ChanDiscussionElementUncheckedUpdateManyWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChanDiscussionMessageCreateManyRelatedInput = {
    id?: string
    content: string
  }

  export type ChanDiscussionMessageUpdateWithoutRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedUsers?: UserUpdateManyWithoutChanDiscussionMessageNestedInput
    relatedRoles?: RoleUpdateManyWithoutRelatedDiscussionMessageNestedInput
    discussionElement?: ChanDiscussionElementUpdateOneWithoutMessageNestedInput
  }

  export type ChanDiscussionMessageUncheckedUpdateWithoutRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    relatedUsers?: UserUncheckedUpdateManyWithoutChanDiscussionMessageNestedInput
    relatedRoles?: RoleUncheckedUpdateManyWithoutRelatedDiscussionMessageNestedInput
    discussionElement?: ChanDiscussionElementUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type ChanDiscussionMessageUncheckedUpdateManyWithoutRelatedOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutChanDiscussionMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUpdateManyWithoutDeletingUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUpdateManyWithoutMutedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChanDiscussionMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dmPolicyLevel?: EnumdmPolicyLevelTypeFieldUpdateOperationsInput | dmPolicyLevelType
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    directMessage?: DirectMessageUncheckedUpdateManyWithoutRequestingUserNestedInput
    directMessageOf?: DirectMessageUncheckedUpdateManyWithoutRequestedUserNestedInput
    chans?: ChanUncheckedUpdateManyWithoutUsersNestedInput
    ownedChans?: ChanUncheckedUpdateManyWithoutOwnerNestedInput
    friend?: FriendShipUncheckedUpdateManyWithoutRequestingUserNestedInput
    friendOf?: FriendShipUncheckedUpdateManyWithoutRequestedUserNestedInput
    outcomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingFriendInvitation?: FriendInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    outcomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitingUserNestedInput
    incomingChanInvitation?: ChanInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    blockedUser?: BlockedShipUncheckedUpdateManyWithoutBlockingUserNestedInput
    blockedByUser?: BlockedShipUncheckedUpdateManyWithoutBlockedUserNestedInput
    chanDiscussionElement?: ChanDiscussionElementUncheckedUpdateManyWithoutAuthorNestedInput
    chanDiscussionEvent?: ChanDiscussionEventUncheckedUpdateManyWithoutConcernedUserNestedInput
    deletedMessageChanDiscussionEvent?: DeletedMessageChanDiscussionEventUncheckedUpdateManyWithoutDeletingUsersNestedInput
    dmDiscussionElement?: DmDiscussionElementUncheckedUpdateManyWithoutAuthorRelationNestedInput
    dmDiscussionMessage?: DmDiscussionMessageUncheckedUpdateManyWithoutRelatedUsersNestedInput
    mutedUserChan?: MutedUserChanUncheckedUpdateManyWithoutMutedUserNestedInput
  }

  export type RoleUpdateWithoutRelatedDiscussionMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    roles?: RoleUpdateManyWithoutRolesSymNestedInput
    rolesSym?: RoleUpdateManyWithoutRolesNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
    chan?: ChanUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutRelatedDiscussionMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    chanId?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutRolesSymNestedInput
    rolesSym?: RoleUncheckedUpdateManyWithoutRolesNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutRelatedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RoleUpdatepermissionsInput | Enumerable<PermissionList>
    roleApplyOn?: EnumRoleApplyingTypeFieldUpdateOperationsInput | RoleApplyingType
    chanId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}